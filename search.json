[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The bitLibrary",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "The bitLibrary",
    "section": "Introduction",
    "text": "Introduction\nbit is a header-only C++ library for numerical work in bit-space which mathematicians call GF(2) or \\(\\FF\\), the simplest Galois field with just two elements 0 & 1. All arithmetic operations in bit-space are mod 2 so what starts in bit-space stays in bit-space.\nThe library provides vector and matrix classes for performing linear algebra in bit-space. The bit::vector class represents bit_vectors, and the bit::matrix class represents bit-matrices. The library also has a bit::polynomial class to represent bit-polynomials over \\(\\FF\\).\nThese classes are efficient and pack the individual bit elements into natural word blocks. You can size/resize the classes at run-time.\nBecause arithmetic operations in \\(\\FF\\) are mod 2, addition/subtraction becomes the XOR operation, and multiplication/division becomes the AND operation. The bit library uses those equivalences to efficiently perform most interactions on and between bit-vectors and bit-matrices by simultaneously working on whole blocks of elements.\nThe bit library provides a rich interface to set up and manipulate bit-vectors and bit-matrices in various ways. Amongst other things, the interface includes methods to solve systems of linear equations over \\(\\FF\\) and to look at the eigen-structure of bit-matrices. The bit::polynomial class has methods to compute \\(x^N\\bmod{P(x)}\\) where \\(P(x)\\) is a polynomial over \\(\\FF\\) and \\(N\\) is a potentially huge integer.",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "The bitLibrary",
    "section": "Installation",
    "text": "Installation\nThis library is header-only, so there is nothing to compile & link–drop the bit include directory somewhere convenient, and you are good to go.\nAlternatively, if you are using CMake, you can use the standard FetchContent module by adding a few lines to your project’s CMakeLists.txt file:\ninclude(FetchContent)\nFetchContent_Declare(bit URL https://github.com/nessan/bit/releases/download/current/bit.zip)\nFetchContent_MakeAvailable(bit)\nThis command downloads and unpacks an archive of the current version of bit to your project’s build folder. You can then add a dependency on bit::bit, a CMake alias for bit. FetchContent will automatically ensure the build system knows where to find the downloaded header files and any needed compiler flags.\nUsed like this, FetchContent will only download a minimal library version without any redundant test code, sample programs, documentation files, etc.\n\n\n\n\n\n\nLibrary versions\n\n\n\nThe shown URL gets the current version of the library—whatever is in the main branch. For a fixed, stable library version (say release 2.0.0), use a URL parameter like: https://github.com/nessan/bit/releases/download/2.0.0/bit.zip.",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "index.html#example",
    "href": "index.html#example",
    "title": "The bitLibrary",
    "section": "Example",
    "text": "Example\nHere is a simple example of a program that uses bit:\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    auto M = bit::matrix&lt;&gt;::random(6, 6);\n2    auto c = bit::characteristic_polynomial(M);\n    std::cout &lt;&lt; std::format(\"Bit-matrix M:\\n{:p}\\n\", M);\n    std::cout &lt;&lt; std::format(\"Characteristic poly c(x) = {}\\n\", c);\n3    std::cout &lt;&lt; std::format(\"c(M) yields:\\n{:p}\\n\", c(M));\n}\n\n1\n\nCreates a random \\(6\\times6\\) bit-matrix \\(M\\) where 0 & 1 are equally likely to occur.\n\n2\n\nComputes its characteristic polynomial \\(c(x) = c_0 + c_1 x + c_2 x^2 + ... + c_6 x^6\\).\n\n3\n\nVerifies that \\(M\\) satisfies its own characteristic equation \\(c(M) = 0\\), as expected from the Cayley Hamilton theorem.\n\n\nSample Output (varies from run to run):\nBit-matrix M:\n│1 1 0 1 1 0│\n│0 0 0 0 0 1│\n│0 1 1 1 0 0│\n│0 0 0 1 0 1│\n│1 1 1 0 1 0│\n│1 0 0 1 1 1│\nCharacteristic poly c(x) = x^1 + x^2 + x^3 + x^5 + x^6\nc(M) yields:\n│0 0 0 0 0 0│\n│0 0 0 0 0 0│\n│0 0 0 0 0 0│\n│0 0 0 0 0 0│\n│0 0 0 0 0 0│\n│0 0 0 0 0 0│\n\n\n\n\n\n\nThe special nature of \\(\\FF\\)\n\n\n\nbit makes it possible to quickly extract the characteristic polynomial for a bit-matrix with millions of elements—​a problem that chokes a naive implementation that does not consider the special nature of arithmetic in \\(\\FF\\).",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "index.html#why-use-bit",
    "href": "index.html#why-use-bit",
    "title": "The bitLibrary",
    "section": "Why Use bit?",
    "text": "Why Use bit?\nThe standard library already has std::bitset, an efficient bitset class that is familiar and well thought through, so our bit::vector class replicates and extends much of that interface.\nAll std::bitset objects have a fixed size determined at compile time. The well-known Boost library does add a dynamic version boost::dynamic_bitset, where the bitset size can be set and changed at runtime.\nHowever, as the two names suggest, those types are aimed at bitsets instead of bit-vectors. So, for example, they print in bit-order with the least significant element/bit on the right. More importantly, those classes don’t have any particular methods aimed at linear algebra. Neither does the standard library’s vector class std::vector.\nOn the other hand, several well-known linear algebra libraries, such as Eigen, exist. Those packages efficiently manage all the standard numeric types (floats, doubles, integers, etc.) but do not correctly handle \\(\\FF\\). You can create matrices of integers where all the elements are 0 or 1, but there is no built-in knowledge in those libraries that arithmetic is mod 2.\nFor example, you might use Eigen to create an integer matrix of all 0’s and 1’s and then use a built-in function from that library to extract the characteristic polynomial. Modding the coefficients of that polynomial with 2 gets the appropriate version for \\(\\FF\\). Technically, this works, but you will have overflow problems for even relatively modest-sized matrices with just a few hundred rows and columns. Of course, you might use an underlying BitInt type that never overflows, but the calculations become dog slow for larger bit-matrices, which doesn’t help much.\nFor linear algebra problems over \\(\\FF\\), this specialized bit library is a better way to go and one to consider if, for example, your interest is in some areas of cryptography or random number generation.",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "The bitLibrary",
    "section": "Documentation",
    "text": "Documentation\nThe project’s source code repository is here.\nYou can read the project’s documentation here.\nThe documentation site was generated using Quarto.\n\nContact\nYou can contact me by email here.\n\n\nCopyright and License\nCopyright (c) 2022-present Nessan Fitzmaurice.\nYou can use this software under the MIT license.",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "content/matrix/count.html",
    "href": "content/matrix/count.html",
    "title": "bit::matrix — Bit Counts",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nCount the number of set/unset elements in a bit-matrix.\n1constexpr std::size_t count() const;\n2constexpr std::size_t count_diagonal() const;\n3constexpr bool trace() const;\n\n1\n\nReturn the number of set elements in the bit-matrix.\n\n2\n\nReturn the number of set elements on the bit-matrix diagonal.\n\n3\n\nReturn count_diagonal() % 2–the “sum” of the diagonal elements.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::matrix&lt;&gt; m1(\"0000 0000 0000 0000\");\n    bit::matrix&lt;&gt; m2(\"0101 1010 0101 1010\");\n    bit::matrix&lt;&gt; m3(\"1111 1111 1111 1111\");\n\n    std::cout\n        &lt;&lt; \"matrix\\t\\t\" &lt;&lt; \"count\\t\" &lt;&lt; \"diag\\t\" &lt;&lt; \"trace\\n\"\n        &lt;&lt; m1 &lt;&lt; '\\t' &lt;&lt; m1.count() &lt;&lt; '\\t' &lt;&lt; m1.count_diagonal() &lt;&lt; '\\t' &lt;&lt; m1.trace() &lt;&lt; \"\\n\\n\"\n        &lt;&lt; m2 &lt;&lt; '\\t' &lt;&lt; m2.count() &lt;&lt; '\\t' &lt;&lt; m2.count_diagonal() &lt;&lt; '\\t' &lt;&lt; m2.trace() &lt;&lt; \"\\n\\n\"\n        &lt;&lt; m3 &lt;&lt; '\\t' &lt;&lt; m3.count() &lt;&lt; '\\t' &lt;&lt; m3.count_diagonal() &lt;&lt; '\\t' &lt;&lt; m3.trace() &lt;&lt; '\\n';\n}\nOutput\nmatrix          count   diag    trace\n│0 0 0 0│\n│0 0 0 0│\n│0 0 0 0│\n│0 0 0 0│       0       0       0\n\n│0 1 0 1│\n│1 0 1 0│\n│0 1 0 1│\n│1 0 1 0│       8       0       0\n\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│       16      4       0\n\nSee Also\nmatrix::rows\nmatrix::cols\nmatrix::size\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/logical-op.html",
    "href": "content/matrix/logical-op.html",
    "title": "bit::matrix — Logical Operators",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nMethods to perform element-by-element binary AND, XOR, OR, +, -, * between two equal sized bit-matrix.\ntemplate&lt;std::unsigned_integral Block, typename Alloc&gt;\nconstexpr bit::matrix&lt;Block, Alloc&gt;\noperator&(const bit::matrix&lt;Block, Alloc&gt; &lhs,\n1          const bit::matrix&lt;Block, Alloc&gt; &rhs);\noperator^(const bit::matrix&lt;Block, Alloc&gt; &lhs,\n2          const bit::matrix&lt;Block, Alloc&gt; &rhs);\noperator|(const bit::matrix&lt;Block, Alloc&gt; &lhs,\n3          const bit::matrix&lt;Block, Alloc&gt; &rhs);\noperator+(const bit::matrix&lt;Block, Alloc&gt; &lhs,\n4          const bit::matrix&lt;Block, Alloc&gt; &rhs);\noperator-(const bit::matrix&lt;Block, Alloc&gt; &lhs,\n5          const bit::matrix&lt;Block, Alloc&gt; &rhs);\noperator*(const bit::matrix&lt;Block, Alloc&gt; &lhs,\n6          const bit::matrix&lt;Block, Alloc&gt; &rhs);\n\n1\n\nReturns a bit-matrix, the binary AND of rhs & lhs.\n\n2\n\nReturns a bit-matrix, the binary XOR of rhs & lhs.\n\n3\n\nReturns a bit-matrix, the binary OR of rhs & lhs.\n\n4\n\nReturns a bit-matrix, the binary XOR of rhs & lhs.\nIn \\(\\FF\\), addition corresponds to XOR.\n\n5\n\nReturns a bit-matrix, the binary XOR of rhs & lhs.\nIn \\(\\FF\\), subtraction corresponds to XOR.\n\n6\n\nReturns a bit-matrix, the binary AND of rhs & lhs.\nIn \\(\\FF\\), multiplication corresponds to AND.\n\n\n\n\n\n\n\n\nDimensions must match\n\n\n\nThe two bit-matrices in question must have the same dimensions. Set the BIT_DEBUG flag at compile time to check this condition — any violation will cause the program to abort with a helpful message.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::matrix&lt;&gt; m1(4,[](std::size_t i, std::size_t j) { return (i + j) % 2; });\n    auto m2 = bit::matrix&lt;&gt;::ones(4);\n\n    std::cout &lt;&lt; \"m1:\\n\" &lt;&lt; m1  &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m2:\\n\" &lt;&lt; m2  &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m1 & m2:\\n\" &lt;&lt; (m1 & m2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m1 | m2:\\n\" &lt;&lt; (m1 | m2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m1 ^ m2:\\n\" &lt;&lt; (m1 ^ m2) &lt;&lt; '\\n';\n}\nOutput\nm1:\n│0 1 0 1│\n│1 0 1 0│\n│0 1 0 1│\n│1 0 1 0│\nm2:\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\nm1 & m2:\n│0 1 0 1│\n│1 0 1 0│\n│0 1 0 1│\n│1 0 1 0│\nm1 | m2:\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\nm1 ^ m2:\n│1 0 1 0│\n│0 1 0 1│\n│1 0 1 0│\n│0 1 0 1│\n\nSee Also\nmatrix::operator&=\nmatrix::operator|=\nmatrix::operator^=\nmatrix::operator+=\nmatrix::operator-=\nmatrix::operator*=\nmatrix::operator~\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/print.html",
    "href": "content/matrix/print.html",
    "title": "bit::matrix — Side-by-Side Printing",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have functions that print a bit-matrix and some bit-vectors or two or three bit-matrices side by side to a stream.\n\nVersions that print to an arbitrary stream\nprint(std::ostream &s,\n      const bit::matrix &A,\n      const bit::vector &b,\n1      std::string_view delim = \"\\t\");\n\nprint(std::ostream &s,\n      const bit::matrix &A,\n      const bit::vector &b, const bit::vector &c,\n2      std::string_view delim = \"\\t\");\n\nprint(std::ostream &s,\n      const bit::matrix &A,\n      const bit::vector &b, const bit::vector &c, const bit::vector &d,\n3      std::string_view delim = \"\\t\");\n\nprint(std::ostream &s,\n      const bit::matrix &A,\n      const bit::matrix &B,\n4      std::string_view delim = \"\\t\");\n\nprint(std::ostream &s,\n      const bit::matrix &A,\n      const bit::matrix &B, const bit::matrix &C,\n5      std::string_view delim = \"\\t\");\n\n1\n\nPrints a bit-matrix and a bit-vector side by side to an arbitrary stream.\n\n2\n\nPrints a bit-matrix and two bit-vectors side by side to an arbitrary stream.\n\n3\n\nPrints a bit-matrix and three bit-vectors side by side to an arbitrary stream.\n\n4\n\nPrints two bit-matrices side by side to an arbitrary stream.\n\n5\n\nPrints three bit-matrices side by side to an arbitrary stream.\n\n\n\n\nVersions that print to std::cout\nprint(const bit::matrix &A,\n      const bit::vector &b,\n1      std::string_view delim = \"\\t\");\n\nprint(const bit::matrix &A,\n      const bit::vector &b, const bit::vector &c,\n2      std::string_view delim = \"\\t\");\n\nprint(const bit::matrix &A,\n      const bit::vector &b, const bit::vector &c, const bit::vector &d,\n3      std::string_view delim = \"\\t\");\n\nprint(const bit::matrix &A,\n      const bit::matrix &B,\n4      std::string_view delim = \"\\t\");\n\nprint(const bit::matrix &A,\n      const bit::matrix &B, const bit::matrix &C,\n5      std::string_view delim = \"\\t\");\n\n1\n\nPrints a bit-matrix and a bit-vector side by side to std::cout.\n\n2\n\nPrints a bit-matrix and two bit-vectors side by side to std::cout.\n\n3\n\nPrints a bit-matrix and three bit-vectors side by side to std::cout.\n\n4\n\nPrints two bit-matrices side by side to std::cout.\n\n5\n\nPrints three bit-matrices side by side to std::cout.\n\n\nEach non-member function is void (i.e., returns nothing). In practice, each has all the appropriate template parameters (not shown here for brevity).\nThe delimiter string delim separates the various bit-matrices and bit-vectors in the output stream.\n\n\n\n\n\n\nUtility function\n\n\n\nThe need for this sort of printing turns up often enough to make it sensible to include the code in the library directly. In particular, these functions gracefully handle cases where the number of rows in the arguments does not match.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto M1 = bit::matrix&lt;&gt;::random(8, 6);\n    auto M2 = bit::matrix&lt;&gt;::random(10);\n    auto M3 = bit::matrix&lt;&gt;::random(6, 8);\n    std::cout &lt;&lt; \"M1           M2          M3\\n\";\n    print(M1, M2, M3, \" | \");\n}\nOutput where the specific numbers vary from run to run\nM1           M2          M3\n001011 | 0111010001 | 00111010\n111101 | 0100100010 | 11100100\n011101 | 0010110111 | 00100011\n100111 | 0100111110 | 00100011\n011001 | 1010110010 | 11001001\n011001 | 1101010100 | 01000001\n010010 | 1011000001 |\n011011 | 1101001010 |\n       | 0100111101 |\n       | 1101111001 |\n\n\nSee Also\nmatrix::stream&lt;&lt;\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/transpose.html",
    "href": "content/matrix/transpose.html",
    "title": "bit::matrix — Transpose a Bit-Matrix",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe supply a member function to transpose a square bit-matrix in place and a free function that transposes an arbitrary bit-matrix.\n1constexpr bit::matrix &to_transpose();\n\ntemplate&lt;std::unsigned_integral Block, typename Allocator&gt;\nconstexpr matrix&lt;Block, Allocator&gt;\n2transpose(const matrix&lt;Block, Allocator&gt; &M);\n\n1\n\nMember function to transpose a square bit-matrix in place.\n\n2\n\nFree function that returns the transpose of an arbitrary bit-matrix.\n\n\nThe transpose of a matrix \\(M\\) with elements \\(M_{ij}\\) is the matrix \\(M^T\\) whose elements are \\[\nM^T_{ij} = M_{ji}\n\\]\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::matrix&lt;&gt; m(4, [](std::size_t i, std::size_t) { return (i + 1)%2; });\n    auto m1 = m;\n    std::cout &lt;&lt; \"Original and transposed matrices:\\n\";\n    bit::print(m, m1.to_transpose());\n\n    bit::matrix&lt;&gt; m2(4, 8, [](std::size_t i, std::size_t) { return (i + 1)%2; });\n    std::cout &lt;&lt; \"Original and transposed matrices:\\n\";\n    bit::print(m2, bit::transpose(m2));\n}\nOutput\nOriginal and transposed matrices:\n1111    1010\n0000    1010\n1111    1010\n0000    1010\nOriginal and transposed matrices:\n11111111        1010\n00000000        1010\n11111111        1010\n00000000        1010\n                1010\n                1010\n                1010\n                1010\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/random.html",
    "href": "content/matrix/random.html",
    "title": "bit::matrix — Random Fill",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nFactory method to construct a bit-matrix whose elements come from independent random draws from a Bernoulli distribution\n1static bit::matrix random(std::size_t r, std::size_t c, double prob_one);\n2static bit::matrix random(std::size_t r, std::size_t c);\n3static bit::matrix random(std::size_t n);\n\n1\n\nReturns an r x c bit-matrix where the probability that any element in the bit-matrix is 1 is prob_one.\n\n2\n\nReturns an r x c bit-matrix where the probability that any element in the bit-matrix is 1 is 0.5.\n\n3\n\nReturns an n x n square bit-matrix where the probability that an element in the bit-matrix is 1 is 0.5.\n\n\nThe probability that an element in the bit-matrix is 1 is prob_one. The default probability value is 0.5, so element values are determined by tossing a fair coin a total of r x c times.\n\n\n\n\n\n\nProbability must be valid\n\n\n\nThese throw a std::invalid_argument exception if prob_one is not in the valid range \\([0, 1\\)].\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto m1 = bit::matrix&lt;&gt;::random(8);\n    std::cout &lt;&lt; m1 &lt;&lt; std::endl;\n}\nOutput (varies from run to run)\n│1 0 1 1 1 1 1 0│\n│1 1 0 0 1 1 1 0│\n│1 1 0 0 0 0 1 0│\n│1 0 1 0 0 1 1 0│\n│1 1 0 1 1 0 1 1│\n│0 0 0 1 0 0 1 0│\n│1 0 0 0 1 1 0 0│\n│1 1 0 0 1 1 1 0│\n\nSee Also\nmatrix::ones\nmatrix::zeros\nmatrix::identity\nmatrix::checker_board\nmatrix::shift\nmatrix::rotate\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/pow.html",
    "href": "content/matrix/pow.html",
    "title": "bit::matrix — Powers of a Bit-Matrix",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods that raise a square bit-matrix to a power \\(n\\) or \\(2^n\\).\ntemplate&lt;std::unsigned_integral Block, typename Allocator&gt;\nconstexpr matrix&lt;Block, Allocator&gt;\n1pow(const matrix&lt;Block, Allocator&gt; &M, std::size_t n);\n\ntemplate&lt;std::unsigned_integral Block, typename Allocator&gt;\nconstexpr matrix&lt;Block, Allocator&gt;\n2pow2(const matrix&lt;Block, Allocator&gt; &M, std::size_t n);\n\n1\n\nReturns \\(M^n\\).\n\n2\n\nReturns \\(M^{2^n}\\).\n\n\nFor example, we can raise \\(M\\) to the power \\(2^{128}\\), which is not representable as a typical std::size_t.\nWe use repeated squaring to compute the powers efficiently. It is also worth noting that all arithmetic in \\(\\FF\\) is mod 2, so there are no overflow issues even for large \\(n\\).\n\n\n\n\n\n\nThe bit-matrix argument must be square\n\n\n\nThe input matrix must be square, and the bit_always_assert macro checks that pre-condition.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto M = bit::matrix&lt;&gt;::random(4);\n    std::cout &lt;&lt; \"M:\\n\"             &lt;&lt; M            &lt;&lt; '\\n';\n1    std::cout &lt;&lt; \"M^2:\\n\"           &lt;&lt; pow(M,2)     &lt;&lt; '\\n';\n2    std::cout &lt;&lt; \"M^{256}:\\n\"       &lt;&lt; pow(M,256)   &lt;&lt; '\\n';\n3    std::cout &lt;&lt; \"M^{2^8}:\\n\"       &lt;&lt; pow2(M,8)    &lt;&lt; '\\n';\n4    std::cout &lt;&lt; \"M^{2^{100}}:\\n\"   &lt;&lt; pow2(M,100)  &lt;&lt; '\\n';\n}\n\n1\n\nSimple square of a small random bit-matrix.\n\n2\n\nRaise to the power \\(256\\) using pow.\n\n3\n\nRaise to the power \\(2^8 = 256\\) using pow2.\n\n4\n\nRaise to the power \\(2^{100} = 1,267,650,600,228,229,401,496,703,205,376\\).\n\n\nOutput\nM:\n│1 0 1 1│\n│1 1 0 1│\n│0 0 0 1│\n│1 1 1 1│\nM^2:\n│0 1 0 1│\n│1 0 0 1│\n│1 1 1 1│\n│1 0 0 0│\nM^{256}:\n│0 0 0 1│\n│1 1 0 1│\n│1 0 1 1│\n│0 1 0 1│\nM^{2^8}:\n│0 0 0 1│\n│1 1 0 1│\n│1 0 1 1│\n│0 1 0 1│\nM^{2^{100}}:\n│0 0 0 1│\n│1 1 0 1│\n│1 0 1 1│\n│0 1 0 1│\n\nSee Also\npolynomial::operator()\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/invert.html",
    "href": "content/matrix/invert.html",
    "title": "bit::matrix — Bit-Matrix Inversion",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have a non-member function that attempts to invert a square bit-matrix.\ntemplate&lt;std::unsigned_integral Block, typename Allocator&gt;\nstd::optional&lt;matrix&lt;Block, Allocator&gt;&gt;\nbit::invert(const matrix&lt;Block, Allocator&gt; &M);\nIf this method succeeds, it will return \\(M^{-1}\\) wrapped in a std::optional. If the input matrix \\(M\\) is singular, it will return std::nullopt instead.\n\n\n\n\n\n\nBit-matrices are often singular\n\n\n\nRandomly filled matrices over \\(\\FF\\) are likely to be singular. In fact, for matrices that are \\(10 \\times 10\\) or larger, there is a 71% chance the matrix is singular if the elements were set by flipping fair coins. Contrast that to matrices over the reals where, mathematically at least, matrices are almost surely invertible (though the numerics of the situation may not be so sure).\n\n\n\n\n\n\n\n\nThe bit-matrix argument must be square\n\n\n\nThe input matrix must be square, and the bit_always_assert macro checks that pre-condition.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    auto A = bit::matrix&lt;&gt;::rotate(8);\n    auto B = bit::invert(A);\n    if(B) {\n        std::cout &lt;&lt; \"bit::matrix, its inverse, their product:\\n\";\n        bit::print(A,*B, bit::dot(A,*B));\n    }\n    else {\n        std::cout &lt;&lt; \"bit::matrix:\\n\" &lt;&lt; A &lt;&lt; \"\\n\" &lt;&lt; \"Is singular!\\n\";\n    }\n}\n\n1\n\nThe product of A and any 8-element bit-vector will rotate the elements in the vector one place to the left — see matrix::rotate. Obviously, A is invertible, so B exists and acts on bit-vectors by rotating their elements one place to the right.\n\n\nOutput\nbit::matrix, its inverse, their product:\n00000001        01000000        10000000\n10000000        00100000        01000000\n01000000        00010000        00100000\n00100000        00001000        00010000\n00010000        00000100        00001000\n00001000        00000010        00000100\n00000100        00000001        00000010\n00000010        10000000        00000001\n\nSee Also\nmatrix::probability_invertible\nmatrix::probability_singular\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/set_if.html",
    "href": "content/matrix/set_if.html",
    "title": "bit::matrix — Conditional Set/Flip",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods to set or flip the element values in a bit-matrix based on the return value from a function call.\nconstexpr bit::matrix&\n1set_if(std::invocable&lt;std::size_t, std::size_t&gt; auto f);\n\nconstexpr bit::matrix&\n2flip_if(std::invocable&lt;std::size_t, std::size_t&gt; auto f);\n\n1\n\nSets element at (i, j) to 1 if f(i,j) != 0, otherwise sets it to 0.\n\n2\n\nFlips the value of element (i, j) if f(i,j) != 0, otherwise leaves it unchanged.\n\n\nf is a function we expect to call as f(i,j) for each index pair.\nBoth methods return a reference to *this so they can be chained with other calls.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::matrix&lt;&gt; m(4,8);\n    std::cout &lt;&lt; \"m:\\n\" &lt;&lt; m &lt;&lt; '\\n';\n    m.set_if([](std::size_t i, std::size_t j) { return (i + j) % 2; });\n    std::cout &lt;&lt; \"m:\\n\" &lt;&lt; m &lt;&lt; '\\n';\n    m.flip_if([](std::size_t i, std::size_t j) { return (i + j) % 2; });\n    std::cout &lt;&lt; \"m:\\n\" &lt;&lt; m &lt;&lt; '\\n';\n}\nOutput\nm:\n│0 0 0 0 0 0 0 0│\n│0 0 0 0 0 0 0 0│\n│0 0 0 0 0 0 0 0│\n│0 0 0 0 0 0 0 0│\nm:\n│0 1 0 1 0 1 0 1│\n│1 0 1 0 1 0 1 0│\n│0 1 0 1 0 1 0 1│\n│1 0 1 0 1 0 1 0│\nm:\n│0 0 0 0 0 0 0 0│\n│0 0 0 0 0 0 0 0│\n│0 0 0 0 0 0 0 0│\n│0 0 0 0 0 0 0 0│\n\nSee Also\nmatrix::set\nmatrix::reset\nmatrix::set_diagonal\nmatrix::reset_diagonal\nmatrix::flip\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/resize.html",
    "href": "content/matrix/resize.html",
    "title": "bit::matrix — Resize a Bit-Matrix",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nResizes the bit-matrix, initializing any added elements to 0.\n1constexpr bit::matrix &resize(std::size_t r, std::size_t c);\n2constexpr bit::matrix &resize(std::size_t n);\n\n1\n\nResize the bit-matrix to be r x c.\n\n2\n\nResize the bit-matrix to be n x n.\n\n\nIf r &lt; rows(), the bit-matrix is reduced in size to the first r rows.\nIf r &gt; rows(), we append extra rows of zeros to the end of the bit-matrix.\nIf c &lt; cols(), the bit-matrix is reduced in size to the first c columns.\nIf c &gt; cols(), we append extra columns of zeros to the end of the bit-matrix.\nThis method returns a reference to *this so it can be chained with other calls.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    auto m = bit::matrix&lt;&gt;::random(4);\n    std::cout &lt;&lt; \"m:\\n\" &lt;&lt; m &lt;&lt; '\\n';\n2    m.resize(6,8);\n    std::cout &lt;&lt; \"m:\\n\" &lt;&lt; m &lt;&lt; '\\n';\n3    m.resize(4);\n    std::cout &lt;&lt; \"m:\\n\" &lt;&lt; m &lt;&lt; '\\n';\n}\n\n1\n\nConstruct a 4 x 4 bit-matrix with a random fill.\n\n2\n\nResize the bit-matrix to have 6 x 8. The extra two rows and columns get initialized with zeros.\n\n3\n\nResize the bit-matrix to the original 4 x 4 size.\n\n\nOutput\nm:\n│1 1 0 0│\n│1 1 0 1│\n│1 1 1 0│\n│1 1 1 0│\nm:\n│1 1 0 0 0 0 0 0│\n│1 1 0 1 0 0 0 0│\n│1 1 1 0 0 0 0 0│\n│1 1 1 0 0 0 0 0│\n│0 0 0 0 0 0 0 0│\n│0 0 0 0 0 0 0 0│\nm:\n│1 1 0 0│\n│1 1 0 1│\n│1 1 1 0│\n│1 1 1 0│\n\nSee Also\nmatrix::clear\nmatrix::add_row\nmatrix::add_col\nmatrix::pop_row\nmatrix::pop_col\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/sub.html",
    "href": "content/matrix/sub.html",
    "title": "bit::matrix — Extract a Sub-Bit-Matrix",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods to extract a sub-matrix as a stand-alone, distinct copy of elements from this bit-matrix.\nconstexpr bit::matrix\n1sub(std::size_t i0, std::size_t j0, std::size_t r, std::size_t c) const;\n\nconstexpr bit::matrix\n2sub(std::size_t r, std::size_t c) const;\n\nconstexpr bit::matrix\n3sub(std::size_t n) const const;\n\n1\n\nReturns an r x c bit-matrix, a copy from this bit-matrix starting at (i0, j0)\n\n2\n\nReturns an r x c bit-matrix, a copy from this bit-matrix starting at (0, 0).\n\n3\n\nReturns an n x n square bit-matrix, a copy from this bit-matrix starting at (0, 0)\n\n\n\n\n\n\n\n\nBounds checking\n\n\n\n(i0, j0) has to be a valid index pair, and the requested dimensions must fit as a valid sub-matrix. Set the BIT_DEBUG flag at compile time to check these conditions — any violation will cause the program to abort with a helpful message.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    auto m = bit::matrix&lt;&gt;::random(8);\n    std::cout &lt;&lt; \"m:                \\n\" &lt;&lt; m                &lt;&lt; \"\\n\";\n2    std::cout &lt;&lt; \"m.sub(4):         \\n\" &lt;&lt; m.sub(4)         &lt;&lt; \"\\n\";\n3    std::cout &lt;&lt; \"m.sub(2,4):       \\n\" &lt;&lt; m.sub(2,4)       &lt;&lt; \"\\n\";\n4    std::cout &lt;&lt; \"m.sub(5,5,3,3):   \\n\" &lt;&lt; m.sub(5,5,3,3)   &lt;&lt; \"\\n\";\n}\n\n1\n\nThis constructs an 8 x 8 bit-matrix a random fill.\n\n2\n\nExtract the 4 x 4 elements starting at index (0, 0).\n\n3\n\nExtract the 2 x 4 elements starting at index (0, 0).\n\n4\n\nExtract the 3 x 3 elements starting at index (5, 5).\n\n\nOutput\nm:\n│0 1 0 0 1 1 0 1│\n│1 0 1 1 0 0 1 1│\n│1 0 0 0 0 0 0 1│\n│0 0 0 0 1 0 1 1│\n│0 0 1 1 0 1 0 0│\n│0 0 0 1 0 0 0 0│\n│1 1 1 0 1 1 0 1│\n│1 1 1 1 1 0 0 1│\nm.sub(4):\n│0 1 0 0│\n│1 0 1 1│\n│1 0 0 0│\n│0 0 0 0│\nm.sub(2,4):\n│0 1 0 0│\n│1 0 1 1│\nm.sub(5,5,3,3):\n│0 0 0│\n│1 0 1│\n│0 0 1│\n\nSee Also\nmatrix::replace\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/size.html",
    "href": "content/matrix/size.html",
    "title": "bit::matrix — Size Queries",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nHow many rows, columns, elements, etc., are in the bit-matrix?\n1constexpr std::size_t rows()  const;\n2constexpr std::size_t cols()  const;\n3constexpr std::size_t size()  const;\n4constexpr bool        empty() const;\n\n1\n\nReturns the number of rows in the bit-matrix.\n\n2\n\nReturns the number of columns in the bit-matrix.\n\n3\n\nReturns the number of elements in the bit-matrix.\n\n4\n\nReturns true if the bit-matrix has no elements (so size() == 0), returns false otherwise.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::matrix&lt;&gt; m(3, 4);\n    std::cout &lt;&lt; \"m.rows():      \" &lt;&lt; m.rows()      &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m.cols():      \" &lt;&lt; m.cols()      &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m.size():      \" &lt;&lt; m.size()      &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m.empty():     \" &lt;&lt; (m.empty()  ? \"YES\" : \"NO\") &lt;&lt; '\\n';\n}\nOutput\nm.rows():      3\nm.cols():      4\nm.size():      12\nm.empty():     NO\n\nSee Also\nmatrix::count\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/echelon.html",
    "href": "content/matrix/echelon.html",
    "title": "bit::matrix — Echelon Forms",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\nConverts a matrix to row-echelon form or reduced row-echelon form:"
  },
  {
    "objectID": "content/matrix/echelon.html#pivots-free-variables",
    "href": "content/matrix/echelon.html#pivots-free-variables",
    "title": "bit::matrix — Echelon Forms",
    "section": "Pivots & free variables",
    "text": "Pivots & free variables\nThe methods both take an optional pointer to another bit-vector p. If p is present, hat bit-vector will be resized appropriately and filled with the “pivots”.\nIn particular, if p-&gt;element(j) is one, column j now contains a pivot for the bit-matrix. The rank of the bit-matrix will be p-&gt;count(), and the number of free variables will be rows() - p-&gt;count(). p-&gt;flip() indicates the indices of the free variables.\nSee the example below.\nExample\n#include &lt;bit/bit.h&gt;\nint\nmain()\n{\n    // Create a matrix and get its echelon & reduced echelon forms\n    auto          A = bit::matrix&lt;&gt;::random(12);\n    bit::vector&lt;&gt; pivots;\n    std::cout &lt;&lt; \"Original, Row-Echelon, Reduced-Row-Echelon versions of a bit::matrix:\\n\";\n    bit::print(A, echelon_form(A), reduced_echelon_form(A, &pivots));\n\n    // Analyze the rank of the matrix, etc.\n    auto n = A.rows();\n    auto r = pivots.count();\n    auto f = n - r;\n    std::cout &lt;&lt; \"matrix size:               \" &lt;&lt; n &lt;&lt; \" x \" &lt;&lt; n &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"matrix rank:               \" &lt;&lt; r &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Number of free variables:  \" &lt;&lt; f &lt;&lt; \"\\n\";\n    if (f &gt; 0) {\n        std::cout &lt;&lt; \"Indices of free variables: \";\n        pivots.flip().if_set_call([](std::size_t k) { std::cout &lt;&lt; k &lt;&lt; ' '; });\n    }\n    std::cout &lt;&lt; std::endl;\n    return 0;\n}\nOutput (specific values will depend on the random fill)\nOriginal, Row-Echelon, Reduced-Row-Echelon versions of a bit::matrix:\n010000000111    111001001001    100000000001\n001001000000    010000000111    010000000000\n111001001001    001001000000    001001000000\n001100111111    000101111111    000101000001\n001010110000    000011110000    000011000001\n000011100000    000000100110    000000100001\n110011100110    000000011111    000000010000\n000011110010    000000001111    000000001000\n101111011001    000000000111    000000000101\n100101010111    000000000010    000000000010\n001100111101    000000000000    000000000000\n110101001010    000000000000    000000000000\nmatrix size:               12 x 12\nmatrix rank:               10\nNumber of free variables:  2\nIndices of free variables: 5 11\n\nSee Also\nmatrix::invert"
  },
  {
    "objectID": "content/matrix/probability.html",
    "href": "content/matrix/probability.html",
    "title": "bit::matrix — Probability of Inversion",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe provide class methods that calculate the probability that a square bit-matrix with a fair fill is invertible or singular.\n1double bit::matrix&lt;&gt;::probability_invertible(std::size_t n);\n2double bit::matrix&lt;&gt;::probability_singular(std::size_t n);\n\n1\n\nReturns the probability that an \\(n \\times n\\) bit-matrix filled by flipping fair coins is invertible.\n\n2\n\nReturns the probability that an \\(n \\times n\\) bit-matrix filled by flipping fair coins is singular (i.e. non-invertible).\n\n\n\n\n\n\n\n\nEmpty matrices are not allowed\n\n\n\nWe throw an exception if the parameter n is zero.\n\n\nThe simplest case is a \\(1 \\times 1\\) matrix \\(A = [a_{11}]\\). As \\(a_{11}\\) is either 0 or 1, \\(A\\) is invertible 50% of the time if the fill is fair.\nOne can show that any \\(n \\times n\\) bit-matrix with a fair random fill of zeros and ones has the following probability of being invertible: \\[\n    p(n) = \\prod_{k = 1}^{n} (1 - 2^{-k}).\n\\] Now \\(\\lim\\limits_{n \\to \\infty} p(n) \\approx 0.289\\) and that limit is reached quickly. Bit-matrices \\(10 \\times 10\\) or larger have a roughly 71% chance of being singular if the matrix elements were set by flipping fair coins.\nContrast that to real-valued matrices where, mathematically at least, matrices are almost certainly invertible (of course, the numerics of the situation over \\(\\R\\) may not be so sure).\nExample — Create lots of \\(N \\times N\\) matrices and see how many are singular\n#include &lt;bit/bit.h&gt;\nint\nmain()\n{\n1    std::size_t N = 100;\n2    std::size_t trials = 1000;\n    std::size_t fails = 0;\n    for (std::size_t trial = 0; trial &lt; trials; ++trial) {\n3        auto A = bit::matrix&lt;&gt;::random(N, N);\n4        auto B = bit::invert(A);\n5        if (!B) ++fails;\n    }\n    auto p = bit::matrix&lt;&gt;::probability_singular(N);\n6    std::cout &lt;&lt; \"Matrix size: \" &lt;&lt; N &lt;&lt; \" x \" &lt;&lt; N &lt;&lt; \"\\n\"\n              &lt;&lt; \"P[singular]: \" &lt;&lt; 100 * p &lt;&lt; \"%\\n\"\n              &lt;&lt; \"Trials:      \" &lt;&lt; trials &lt;&lt; \"\\n\"\n              &lt;&lt; \"No inverse:  \" &lt;&lt; fails &lt;&lt; \" times\\n\"\n              &lt;&lt; \"Expected:    \" &lt;&lt; int(p * double(trials)) &lt;&lt; \" times\\n\";\n\n    return 0;\n}\n\n1\n\nWe will create an \\(N \\times N\\) matrix in each trial.\n\n2\n\nRun this number of trials.\n\n3\n\nEach matrix is filled at random by flipping fair coins.\n\n4\n\nThen, we attempt to invert the matrix.\n\n5\n\nWe count the number of times the inversion fails–i.e., how often the matrix is singular.\n\n6\n\nPrint the outcome of the trials and compare those to the expectation.\n\n\nOutput (actual numbers vary from run to run)\nMatrix size: 100 x 100\nP[singular]: 71.1212%\nTrials:      1000\nNo inverse:  703 times\nExpected:    711 times\n\nSee Also\nmatrix::invert\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/capacity.html",
    "href": "content/matrix/capacity.html",
    "title": "bit::matrix — Capacity Queries",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nHow many rows or columns can the bit-matrix accommodate with any more memory allocations?\n1constexpr std::size_t row_capacity() const;\n2constexpr std::size_t col_capacity() const;\n\n1\n\nHow many rows can be added without a memory allocation?\n\n2\n\nHow many columns can be added without a memory allocation?\n\n\n\n\n\n\n\n\nEach row is not checked.\n\n\n\nThe rows may not all have the same capacity — the col_capacity() method reports the capacity of the first row.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::matrix&lt;&gt; m(3, 4);\n    std::cout &lt;&lt; \"m.rows():         \" &lt;&lt; m.rows()           &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m.cols():         \" &lt;&lt; m.cols()           &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m.row_capacity(): \" &lt;&lt; m.row_capacity()   &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m.col_capacity(): \" &lt;&lt; m.col_capacity()   &lt;&lt; '\\n';\n}\nOutput\nm.rows():         3\nm.cols():         4\nm.row_capacity(): 3\nm.col_capacity(): 64\n\nSee Also\nvector::capacity\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/to_string.html",
    "href": "content/matrix/to_string.html",
    "title": "bit::matrix — Encode as a String",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods to encode a bit-matrix as a string in a binary or hex format.\nstd::string\nto_string(const std::string& delim = \"\\n\",\n1          char off = '0', char on = '1') const;\n\nstd::string\n2to_pretty_string(char off = '0', char on = '1') const;\n\nstd::string\n3to_hex(const std::string& delim = \"\\n\") const;\n\n1\n\nGet a binary-string representation for the bit-matrix using the given characters for set and unset elements.\n\n2\n\nGet a nicely formatted string representation of the bit-matrix.\n\n3\n\nGet a hex-string representation for the bit-matrix.\n\n\nThese methods print the rows of the bit-matrix as documented in the vector::to_string page. The rows are separated by whatever the delim string is — it defaults to newlines.\nExample — Binary encodings\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::matrix&lt;&gt; m(4, 8, [](std::size_t i, std::size_t j) { return (i + j)%2; });\n    std::cout &lt;&lt; \"In matrix form ...       \\n\";\n    std::cout &lt;&lt; m.to_string()         &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Pretty version ...       \\n\";\n    std::cout &lt;&lt; m.to_pretty_string()  &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"On a single line ...     \\n\";\n    std::cout &lt;&lt; m.to_string(\"; \")     &lt;&lt; '\\n';\n}\nOutput\nIn matrix form ...\n01010101\n10101010\n01010101\n10101010\nPretty version ...\n│0 1 0 1 0 1 0 1│\n│1 0 1 0 1 0 1 0│\n│0 1 0 1 0 1 0 1│\n│1 0 1 0 1 0 1 0│\nOn a single line ...\n01010101; 10101010; 01010101; 10101010\nExample — Hex encodings\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto m3 = bit::matrix&lt;&gt;::ones(3);\n    auto m4 = bit::matrix&lt;&gt;::ones(4);\n    auto m5 = bit::matrix&lt;&gt;::ones(5);\n    auto m6 = bit::matrix&lt;&gt;::ones(6);\n    std::cout &lt;&lt; \"m3.to_hex(\\\"; \\\"): \" &lt;&lt; m3.to_hex(\"; \")  &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m4.to_hex(\\\"; \\\"): \" &lt;&lt; m4.to_hex(\"; \")  &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m5.to_hex(\\\"; \\\"): \" &lt;&lt; m5.to_hex(\"; \")  &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m6.to_hex(\\\"; \\\"): \" &lt;&lt; m6.to_hex(\"; \")  &lt;&lt; '\\n';\n}\nOutput\nm3.to_hex(\"; \"): 0x7_8;  0x7_8;  0x7_8\nm4.to_hex(\"; \"): 0xF;    0xF;    0xF;    0xF\nm5.to_hex(\"; \"): 0xF1_2; 0xF1_2; 0xF1_2; 0xF1_2; 0xF1_2\nm6.to_hex(\"; \"): 0xF3_4; 0xF3_4; 0xF3_4; 0xF3_4; 0xF3_4; 0xF3_4\nExample — Reconstituting bit-matrices from hex encodings\n#include &lt;bit/bit.h&gt;\n\nint main()\n{\n1    auto m3 = bit::matrix&lt;&gt;::random(3);\n    auto m4 = bit::matrix&lt;&gt;::random(4);\n    auto m5 = bit::matrix&lt;&gt;::random(5);\n    auto m6 = bit::matrix&lt;&gt;::random(6);\n\n2    auto s3 = m3.to_hex(\"; \");\n    auto s4 = m4.to_hex(\"; \");\n    auto s5 = m5.to_hex(\"; \");\n    auto s6 = m6.to_hex(\"; \");\n\n3    bit::matrix&lt;&gt; c3(s3);\n    bit::matrix&lt;&gt; c4(s4);\n    bit::matrix&lt;&gt; c5(s5);\n    bit::matrix&lt;&gt; c6(s6);\n\n4\n    std::cout &lt;&lt; \"m3: \" &lt;&lt; s3 &lt;&lt; '\\n' &lt;&lt; \"c3: \" &lt;&lt; c3.to_hex(\"; \")\n              &lt;&lt; (c3 == m3 ? \" MATCH!\" : \"FAIL\") &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m4: \" &lt;&lt; s4 &lt;&lt; '\\n' &lt;&lt; \"c4: \" &lt;&lt; c4.to_hex(\"; \")\n              &lt;&lt; (c4 == m4 ? \" MATCH!\" : \"FAIL\") &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m5: \" &lt;&lt; s5 &lt;&lt; '\\n'  &lt;&lt; \"c5: \" &lt;&lt; c5.to_hex(\"; \")\n              &lt;&lt; (c5 == m5 ? \" MATCH!\" : \"FAIL\") &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m6: \" &lt;&lt; s6 &lt;&lt; '\\n' &lt;&lt; \"c6: \" &lt;&lt; c6.to_hex(\"; \")\n              &lt;&lt; (c6 == m6 ? \" MATCH!\" : \"FAIL\") &lt;&lt; '\\n';\n}\n\n1\n\nSet up some bit-matrices of various sizes with random 50-50 fills.\n\n2\n\nConvert the bit-matrices to hex-strings.\n\n3\n\nUse the strings to construct bit-matrices.\n\n4\n\nCheck that the two sets of vectors match.\n\n\nOutput\nm3: 0x3_8; 0x4_8; 0x7_8\nc3: 0x3_8; 0x4_8; 0x7_8 MATCH!\nm4: 0xB; 0xB; 0x0; 0xE\nc4: 0xB; 0xB; 0x0; 0xE MATCH!\nm5: 0x40_2; 0x11_2; 0x40_2; 0x30_2; 0xA0_2\nc5: 0x40_2; 0x11_2; 0x40_2; 0x30_2; 0xA0_2 MATCH!\nm6: 0x11_4; 0xC2_4; 0x00_4; 0x32_4; 0xD2_4; 0x70_4\nc6: 0x11_4; 0xC2_4; 0x00_4; 0x32_4; 0xD2_4; 0x70_4 MATCH!\n\nSee Also\nvector::to_string\nmatrix::stream&lt;&lt;\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/shift.html",
    "href": "content/matrix/shift.html",
    "title": "bit::matrix — Logical Shift Operators",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nMethods to perform binary left and right shifts on the rows in a bit-matrix.\n1constexpr bit::matrix &operator&lt;&lt;=(std::size_t p);\n2constexpr bit::matrix &operator&gt;&gt;=(std::size_t p);\n\n3constexpr bit::matrix operator&lt;&lt;(std::size_t p) const;\n4constexpr bit::matrix operator&gt;&gt;(std::size_t p) const;\n\n1\n\nLeft-shift the rows in this bit-matrix p places with zeros shifted in as needed.\n\n2\n\nRight-shift the rows in this bit-matrix p places with zeros shifted in as needed.\n\n3\n\nReturns a bit-matrix that is this one with its rows left shifted by p places\n\n4\n\nReturns a bit-matrix that is this one with its rows right shifted by p places\n\n\nThe first two methods are destructive (i.e., operate in-place) and return a reference to *this so they can be chained with other calls.\n\n\n\n\n\n\nBit-order vs. vector-order\n\n\n\nShifts in the bit library work in vector-order so if a row is [e0, e1, e2, e3] then a left shift turns that into [e1, e2, e3, 0] and a right shift turns it into [0, e0, e1, e2]. Vector-order shifts are the opposite of bit-order shifts!\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint\nmain()\n{\n    auto m = bit::matrix&lt;&gt;::ones(4,4);\n    std::cout &lt;&lt; \"Left shift:\\n\";\n    std::cout &lt;&lt; \"m:     \\n\" &lt;&lt; m          &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m &lt;&lt; 1:\\n\" &lt;&lt; ((m &lt;&lt; 1)) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m &lt;&lt; 3:\\n\" &lt;&lt; ((m &lt;&lt; 3)) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m &lt;&lt; 5:\\n\" &lt;&lt; ((m &lt;&lt; 5)) &lt;&lt; '\\n';\n\n    std::cout &lt;&lt; \"Right shift:\\n\";\n    std::cout &lt;&lt; \"m:     \\n\" &lt;&lt; m          &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m &gt;&gt; 1:\\n\" &lt;&lt; ((m &gt;&gt; 1)) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m &gt;&gt; 3:\\n\" &lt;&lt; ((m &gt;&gt; 3)) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m &gt;&gt; 5:\\n\" &lt;&lt; ((m &gt;&gt; 5)) &lt;&lt; '\\n';\n}\nOutput\nLeft shift:\nm:\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\nm &lt;&lt; 1:\n│1 1 1 0│\n│1 1 1 0│\n│1 1 1 0│\n│1 1 1 0│\nm &lt;&lt; 3:\n│1 0 0 0│\n│1 0 0 0│\n│1 0 0 0│\n│1 0 0 0│\nm &lt;&lt; 5:\n│0 0 0 0│\n│0 0 0 0│\n│0 0 0 0│\n│0 0 0 0│\n\nRight shift:\nm:\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\nm &gt;&gt; 1:\n│0 1 1 1│\n│0 1 1 1│\n│0 1 1 1│\n│0 1 1 1│\nm &gt;&gt; 3:\n│0 0 0 1│\n│0 0 0 1│\n│0 0 0 1│\n│0 0 0 1│\nm &gt;&gt; 5:\n│0 0 0 0│\n│0 0 0 0│\n│0 0 0 0│\n│0 0 0 0│\n\nSee Also\nmatrix::operator&=\nmatrix::operator|=\nmatrix::operator^=\nmatrix::operator+=\nmatrix::operator-=\nmatrix::operator*=\nmatrix::operator~\nvector::operator&lt;&lt;=\nvector::operator&gt;&gt;=\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/from.html",
    "href": "content/matrix/from.html",
    "title": "bit::matrix — Construction from Strings",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe provide a factory method that attempts to parse a string as a bit-matrix.\nOf course, that isn’t always possible, so this factory method returns a std::optional.\nstatic std::optional&lt;bit::matrix&gt;\n1from(std::string_view src, bool bit_order = false);\n\n1\n\nAttempts to parse a bit-matrix from a string and returns std::nullopt on failure.\n\n\n\n\n\n\n\n\nBit-matrices are stored by row\n\n\n\nThe input string should hold the bit-matrix row by row. Newlines, white spaces, commas, or semi-colons must separate the rows. Each row should be encoded in a string as documented in the vector::constructors page.\n\n\nExample — Binary strings\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    auto m1 = bit::matrix&lt;&gt;::from(\"0b111 0b000 0b111\");\n2    auto m2 = bit::matrix&lt;&gt;::from(\"111 000 111\");\n3    auto m3 = bit::matrix&lt;&gt;::from(\"0b111.0b000.0b111\");\n\n    std::cout &lt;&lt; \"m1:\\n\" &lt;&lt; (m1 ? m1-&gt;to_string() : \"FAILED TO PARSE\") &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"m2:\\n\" &lt;&lt; (m2 ? m2-&gt;to_string() : \"FAILED TO PARSE\") &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"m3:\\n\" &lt;&lt; (m3 ? m3-&gt;to_string() : \"FAILED TO PARSE\") &lt;&lt; \"\\n\";\n}\n\n1\n\nThe row strings are each prefixed by ‘0b’, so each is encoded as a binary string.\n\n2\n\nIn this case, there is no prefix, but the string is all zeros and ones, so we assume the rows are in a binary encoding.\n\n3\n\nThis is a string with a deliberate error–the row separator is invalid.\n\n\nOutput\nm1:\n111\n000\n111\n\nm2:\n111\n000\n111\n\n1m3:\nFAILED TO PARSE\n\n1\n\nThe last string cannot be interpreted as a valid bit-vector.\n\n\nExample — Hex strings\n#include &lt;bit/bit.h&gt;\nint\nmain()\n{\n1    auto m0 = bit::matrix&lt;&gt;::from(\"0b111  0b000   0b111\");\n2    auto m1 = bit::matrix&lt;&gt;::from(\"0x111  0x000   0x111\");\n3    auto m2 = bit::matrix&lt;&gt;::from(\"0x1    0x1     0x1\");\n4    auto m3 = bit::matrix&lt;&gt;::from(\"0x1_8  0x1_8   0x1_8\");\n5    auto m4 = bit::matrix&lt;&gt;::from(\"0x1_4  0x1_4   0x1_4\");\n6    auto m5 = bit::matrix&lt;&gt;::from(\"0x1_2  0x1_2   0x1_2\");\n\n    if (m0) std::cout &lt;&lt; \"m0:\\n\" &lt;&lt; *m0 &lt;&lt; \"\\n\\n\";\n    if (m1) std::cout &lt;&lt; \"m1:\\n\" &lt;&lt; *m1 &lt;&lt; \"\\n\\n\";\n    if (m2) std::cout &lt;&lt; \"m2:\\n\" &lt;&lt; *m2 &lt;&lt; \"\\n\\n\";\n    if (m3) std::cout &lt;&lt; \"m3:\\n\" &lt;&lt; *m3 &lt;&lt; \"\\n\\n\";\n    if (m4) std::cout &lt;&lt; \"m4:\\n\" &lt;&lt; *m4 &lt;&lt; \"\\n\\n\";\n    if (m5) std::cout &lt;&lt; \"m5:\\n\" &lt;&lt; *m5 &lt;&lt; \"\\n\";\n}\n\n1\n\nEach row string is prefixed by ‘0b’, so interpreted as binary.\n\n2\n\nThis string has the same digits, but thanks to the ‘0x’ prefix, each row will be interpreted as a hex string.\n\n3\n\nConstruction where the row characters have no suffix, so by default, parsed as hex/base-16 numbers.\n\n4\n\nConstruction where the row characters have a suffix _8, so parsed as base-8 numbers.\n\n5\n\nConstruction where the row characters have a suffix _4, so parsed as base-4 numbers.\n\n6\n\nConstruction where the row characters have a suffix _2, so parsed as base-2 numbers.\n\n\nOutput\n1m0:\n│1 1 1│\n│0 0 0│\n│1 1 1│\n\n2m1:\n│1 0 0 0 1 0 0 0 1 0 0 0│\n│0 0 0 0 0 0 0 0 0 0 0 0│\n│1 0 0 0 1 0 0 0 1 0 0 0│\n\n3m2:\n│1 0 0 0│\n│1 0 0 0│\n│1 0 0 0│\n\n4m3:\n│1 0 0│\n│1 0 0│\n│1 0 0│\n\n5m4:\n│1 0│\n│1 0│\n│1 0│\n\n6m5:\n│1│\n│1│\n│1│\n\n1\n\nRows are binary strings, so each character is a single element in the bit-vector row.\n\n2\n\nSame digits but now in hex, so each character is four elements in the bit-vector row.\n\n3\n\nThe final ‘1’ is interpreted as 1 base 16 by default.\n\n4\n\nThe final ‘1_8’ is interpreted as 1 base 8.\n\n5\n\nThe final ‘1_4’ is interpreted as 1 base 4.\n\n6\n\nThe final ‘1_2’ is interpreted as 1 base 2.\n\n\n\nSee Also\nmatrix::constructors\nmatrix::to_string\nvector::to_string\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/triangle.html",
    "href": "content/matrix/triangle.html",
    "title": "bit::matrix — Upper & Lower Triangles",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods to extract the upper or lower triangular sub-matrix as a stand-alone, distinct copy of the elements from this bit-matrix.\n1constexpr bit::matrix lower() const;\n2constexpr bit::matrix strictly_lower() const;\n3constexpr bit::matrix upper() const;\n4constexpr bit::matrix strictly_lower() const;\n\n1\n\nReturns a copy of the lower triangle with zeros above the diagonal.\n\n2\n\nReturns a copy of the lower triangle with zeros on or above the diagonal.\n\n3\n\nReturns a copy of the upper triangle with zeros below the diagonal.\n\n4\n\nReturns a copy of the upper triangle with zeros on or below the diagonal.\n\n\n\n\n\n\n\n\nThe starting point is always the top left\n\n\n\nThese methods work with arbitrary rectangular bit-matrices, always starting with the top left (0,0) element as the anchor for the diagonal.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    std::size_t M = 6;\n2    std::size_t N = 16;\n    bit::matrix A(M, N);\n3    A.set();\n\n    std::cout &lt;&lt; \"bit-matrix, lower triangular sub-matrix, and the strictly lower triangular sub-matrix:\\n\";\n    print(A, A.lower(), A.strictly_lower());\n\n    std::cout &lt;&lt; \"bit-matrix, upper triangular sub-matrix, and the strictly upper triangular sub-matrix:\\n\";\n    print(A, A.upper(), A.strictly_upper());\n\n    return 0;\n}\n\n1\n\nNumber of rows.\n\n2\n\nNumber of columns.\n\n3\n\nA is an M x N bit-matrix of all ones.\n\n\nOutput\nbit-matrix, lower triangular sub-matrix, and the strictly lower triangular sub-matrix:\n1111111111111111        1000000000000000        0000000000000000\n1111111111111111        1100000000000000        1000000000000000\n1111111111111111        1110000000000000        1100000000000000\n1111111111111111        1111000000000000        1110000000000000\n1111111111111111        1111100000000000        1111000000000000\n1111111111111111        1111110000000000        1111100000000000\nbit-matrix, upper triangular sub-matrix, and the strictly upper triangular sub-matrix:\n1111111111111111        1111111111111111        0111111111111111\n1111111111111111        0111111111111111        0011111111111111\n1111111111111111        0011111111111111        0001111111111111\n1111111111111111        0001111111111111        0000111111111111\n1111111111111111        0000111111111111        0000011111111111\n1111111111111111        0000011111111111        0000001111111111\n\nSee Also\nmatrix::sub\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/clear.html",
    "href": "content/matrix/clear.html",
    "title": "bit::matrix — Clear out a Bit-Matrix",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe provide a method to remove all elements from a bit-matrix.\nconstexpr bit::matrix &clear();\nThe bit-matrix’s rows(), cols(), and size() all become 0, but the capacity is not changed. This method returns a reference to *this so it can be chained with other calls.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto m = bit::matrix&lt;&gt;::random(8ul, 16ul);\n    std::cout &lt;&lt; \"Pre-clear:\\n\"  &lt;&lt; m         &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Post-clear:\\n\" &lt;&lt; m.clear() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m.rows(): \"    &lt;&lt; m.rows()  &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m.cols(): \"    &lt;&lt; m.cols()  &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m.size(): \"    &lt;&lt; m.size()  &lt;&lt; '\\n';\n}\nOutput\nPre-clear:\n│0 1 0 1 0 0 1 0 0 1 0 0 0 1 1 1│\n│0 0 1 1 0 0 0 0 1 1 1 0 1 1 1 0│\n│0 1 0 1 0 0 0 0 0 0 1 1 0 1 1 0│\n│1 0 0 0 1 1 1 0 0 0 1 1 1 1 1 1│\n│0 0 0 0 1 0 0 1 0 1 0 1 1 1 1 0│\n│1 0 1 1 1 1 0 0 1 0 0 1 1 1 1 1│\n│1 1 0 0 0 1 0 0 1 1 1 1 0 1 1 0│\n│1 1 0 0 0 0 1 0 1 0 1 1 0 1 1 1│\nPost-clear:\n[]\nm.rows(): 0\nm.cols(): 0\nm.size(): 0\n\nSee Also\nmatrix::add_row\nmatrix::add_col\nmatrix::pop_row\nmatrix::pop_col\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/polynomial/count.html",
    "href": "content/polynomial/count.html",
    "title": "bit::polynomial — Coefficient Counts",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods to count the number of ones and zeros in the vector of polynomial coefficients.\n1constexpr std::size_t count0() const;\n2constexpr std::size_t count1() const;\n\n1\n\nReturns the number of zero coefficients in the polynomial.\n\n2\n\nReturns the number of one coefficients in the polynomial.\n\n\n\nSee Also\npolynomial::size\npolynomial::empty\nvector::count\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/polynomial/random.html",
    "href": "content/polynomial/random.html",
    "title": "bit::polynomial — Random Polynomials",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nFactory method to construct a fixed degree bit-polynomial whose coefficients come from independent random draws from a Bernoulli distribution\nstatic bit::polynomial random(std::size_t n, double prob_one = 0.5);\nThis method returns a polynomial of degree \\(n\\) with \\(n+1\\) coefficients.\nIf \\(n &gt; 0\\) then \\(p_n = 1\\) and all the other coefficients in the polynomial are 1 with probability prob_one. If \\(n = 0\\) then the single coefficient \\(p_0\\) is 1 with probability prob_one.\nThe default probability value is 0.5, so n coefficient values are determined by tossing a fair coin.\nAt the extremes, if this parameter is 1.0, the coefficients will all be 1; if it is 0.0, the elements will all be 0.\n\n\n\n\n\n\nThe probability value needs to be valid\n\n\n\nThis method throws a std::invalid_argument exception if the prob_one argument is not in the valid range \\([0, 1]\\).\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    // lambda: Turns the degree of a polynomial into a string.\n    auto deg = [](auto& p) { return p.degree() == bit::polynomial&lt;&gt;::ndeg ? \"NONE\" : std::format(\"{}\", p.degree()); };\n\n    auto p0 = bit::polynomial&lt;&gt;::random(0);\n    std::cout &lt;&lt; std::format(\"p0(x) = {} has degree: {}.\\n\", p0, deg(p0));\n\n    auto p1 = bit::polynomial&lt;&gt;::random(7);\n    std::cout &lt;&lt; std::format(\"p0(x) = {} has degree: {}.\\n\", p1, deg(p1));\n\n    auto p2 = bit::polynomial&lt;&gt;::random(7, 0.9);\n    std::cout &lt;&lt; std::format(\"p0(x) = {} has degree: {}.\\n\", p2, deg(p2));\n}\nOutput (will vary from run to run)\np0(x) = 0 has degree: NONE.\np0(x) = x^1 + x^3 + x^5 + x^7 has degree: 7.\np0(x) = 1 + x^1 + x^2 + x^3 + x^4 + x^5 + x^6 + x^7 has degree: 7.\n\nSee Also\npolynomial::constructors\npolynomial::power\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/polynomial/shrink_to_fit.html",
    "href": "content/polynomial/shrink_to_fit.html",
    "title": "bit::polynomial — Memory Reduction",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have a method that attempts to minimize the memory footprint of a bit-polynomial.\nconstexpr polynomial& shrink_to_fit();\nThis is a request to minimize the unused/excess vector::capacity in the bit-vector holding the polynomial coefficients. The method may do nothing though after the call any nonzero polynomial is guaranteed to be monic.\nThe bulk of the memory used by most polynomials is the bit-vector of its coefficients.\nshrink_to_fit() first uses the polynomial::make_monic method to ensure that size() = degree() + 1 which is the least possible size. It then calls the coefficient bit-vector’s own vector::shrink_to_fit method to see if that data member can release any of its memory back to the general pool.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::polynomial&lt;&gt; p{1000};\n    p[3] = 1;\n    std::cout &lt;&lt; std::format(\"p(x) = {} has {} coefficients and capacity {}.\\n\", p, p.size(), p.capacity());\n    p.shrink_to_fit();\n    std::cout &lt;&lt; std::format(\"p(x) = {} has {} coefficients and capacity {}.\\n\", p, p.size(), p.capacity());\n}\nOutput\np(x) = x^3 has 1000 coefficients and capacity 1024.\np(x) = x^3 has 4 coefficients and capacity 64.\n\nSee Also\npolynomial::size\npolynomial::resize\npolynomial::empty\npolynomial::clear\npolynomial::monic\npolynomial::make_monic\nvector::shrink_to_fit\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/polynomial/sub.html",
    "href": "content/polynomial/sub.html",
    "title": "bit::polynomial — Sub-polynomials",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have a method that creates a new distinct polynomial by copying coefficients from this one.\nconstexpr polynomial sub(std::size_t n) const;\nHere n is the number of coefficients to copy.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::polynomial p{11};\n    p.set();\n    auto q = p.sub(7);\n    std::cout &lt;&lt; std::format(\"p         = {}\\n\", p);\n    std::cout &lt;&lt; std::format(\"q         = {}\\n\", q);\n    std::cout &lt;&lt; std::format(\"q.clear() = {}\\n\", q.clear());\n    std::cout &lt;&lt; std::format(\"p         = {}\\n\", p);\n}\nOutput\np         = 1 + x^1 + x^2 + x^3 + x^4 + x^5 + x^6 + x^7 + x^8 + x^9 + x^10\nq         = 1 + x^1 + x^2 + x^3 + x^4 + x^5 + x^6\nq.clear() = 0\np         = 1 + x^1 + x^2 + x^3 + x^4 + x^5 + x^6 + x^7 + x^8 + x^9 + x^10\nSo even though we cleared out q the original polynomial p is not affected.\n\nSee Also\npolynomial::split\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/polynomial/index.html",
    "href": "content/polynomial/index.html",
    "title": "The bit::polynomial Class",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]",
    "crumbs": [
      "Home",
      "Bit-Polynomials",
      "Introduction"
    ]
  },
  {
    "objectID": "content/polynomial/index.html#introduction",
    "href": "content/polynomial/index.html#introduction",
    "title": "The bit::polynomial Class",
    "section": "Introduction",
    "text": "Introduction\nA bit::polynomial represents a polynomial over GF(2) (also known as \\(\\FF\\)), the simplest Galois Field that has just two elements 0 & 1, where arithmetic is mod 2.\nIf \\(p(x)\\) is the bit-polynomial: \\[\np(x) = p_0 + p_1 x + p_2 x^2 + \\cdots + p_{n-1} x^{n-1},\n\\] then the argument \\(x\\) and the polynomial coefficients \\(p_0, p_1, \\ldots\\) are all elements of \\(\\FF\\).\nThe bit::polynomial class holds the polynomial coefficients in a bit::vector. Instance methods forward much of their work to that data member. However, some bit-polynomial methods need a separate implementation. For example, bit-vector addition only makes sense for two equal-sized bit-vectors, but of course, we have to be able to add two polynomials of different degrees.\n\n\n\n\n\n\nPolynomial size and degree\n\n\n\nThe size of a bit-polynomial is the number of its coefficients. The degree of a bit-polynomial is the index of the highest non-trivial power in the polynomial. Monic polynomials are nonzero and have no trailing zero coefficients.\nOperations on and between polynomials generally can ignore trailing zero coefficients. This can be an important efficiency consideration in some cases.\nAlgorithms and methods in the bit::polynomial class allow for this and internally work efficiently even if the polynomials are not monic. They do that by reimplementing some of the core bit::vector functionality to only consider underlying storage blocks up to and including the one containing the highest non-trivial power.\nWe also note that polynomial methods usually need to treat the zero-polynomial as a special, generally trivial, edge case.",
    "crumbs": [
      "Home",
      "Bit-Polynomials",
      "Introduction"
    ]
  },
  {
    "objectID": "content/polynomial/index.html#declaration",
    "href": "content/polynomial/index.html#declaration",
    "title": "The bit::polynomial Class",
    "section": "Declaration",
    "text": "Declaration\nLike everything in the library, this class is in the bit namespace and is defined in the header &lt;bit/polynomial.h&gt; as follows:\nnamespace bit {\n  template&lt;std::unsigned_integral Block = std::uint64_t,\n           Allocator = std::allocator&lt;Block&gt;&gt;\n  class polynomial;\n}\nThe bit::polynomial class holds the polynomial coefficients in a bit::vector data member that uses the two template parameters.\nThe two template parameters add some visual clutter, but they both have reasonable defaults and disappear entirely in most uses. For example, your code might have a simple line like:\nbit::polynomial p{32};\nThis code creates a polynomial with 32 coefficients set to 0 by default.\n\nTemplate Parameters\n\n\n\n\nParameter\nDescription\n\n\n\n\nBlock = std::uint64_t\nThe polynomial coefficients are packed into blocks of some std::unsigned_integral type. The default size is 64 bits.\n\n\nAllocator = std::allocator&lt;Block&gt;\nThe default Allocator should be just fine for most purposes, but you can use your custom type to handle all memory allocation/destruction for blocks.\n\n\n\n\nThe default Block is 64-bits, the native size for many modern CPUs.\nOf course, if you need to use many smaller degree bit-polynomials and have concerns about conserving space, you might use a different Block. Perhaps if the bit-polynomials all have degrees that fit in 8 bits, you might have code along the lines:\nusing poly_type= bit::polynomial&lt;uint8_t&gt;;\npoly_type p = ...\n\n\n\n\n\n\nUse a single Block type throughout your code!\n\n\n\nIn theory, there is no reason that one couldn’t intermingle operations between, say, a bit::polynomial&lt;std::uint32_t&gt; and a bit::polynomial&lt;std::uint64_t&gt;, but doing so efficiently significantly increases code complexity, and the library doesn’t support this.",
    "crumbs": [
      "Home",
      "Bit-Polynomials",
      "Introduction"
    ]
  },
  {
    "objectID": "content/polynomial/index.html#class-constants-and-types",
    "href": "content/polynomial/index.html#class-constants-and-types",
    "title": "The bit::polynomial Class",
    "section": "Class Constants and Types",
    "text": "Class Constants and Types\n\n\n\n\n\n\n\n\nItem\nDescription\n\n\n\n\nvector_type\nAlias for bit::vector — the type used to store the polynomial coefficients.\n\n\nmatrix_type\nAlias for bit::matrix — polynomials can be evaluated for scalar and square bit-matrix arguments of this type.\n\n\nndeg\nA class constant of type std::size_t used to indicate polynomials of “no degree” (the zero polynomial).\n\n\nreference\nA proxy sub-class representing an individual polynomial coefficient.",
    "crumbs": [
      "Home",
      "Bit-Polynomials",
      "Introduction"
    ]
  },
  {
    "objectID": "content/polynomial/index.html#instance-methods",
    "href": "content/polynomial/index.html#instance-methods",
    "title": "The bit::polynomial Class",
    "section": "Instance Methods",
    "text": "Instance Methods\n\nConstruction\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\npolynomial::constructors\nConstruct bit-polynomials in various ways.\n\n\npolynomial::power\nFactory method to generate the polynomial \\(p(x) = x^n\\).\n\n\npolynomial::random\nFactory method constructs a bit-polynomial with random coefficients.\n\n\n\n\n\n\nQueries\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\npolynomial::size\nHow many coefficients are there in this polynomial?\n\n\npolynomial::empty\nDoes this polynomial have no coefficients? This is treated as a form of the zero polynomial.\n\n\npolynomial::capacity\nHow many coefficients can the polynomial have without causing memory allocation.\n\n\npolynomial::zero\nIs this the zero polynomial \\(p(x) = 0\\)?\n\n\npolynomial::nonzero\nIs this polynomial nonzero?\n\n\npolynomial::one\nIs this polynomial \\(p(x) = 1\\)?\n\n\npolynomial::constant\nIs this a constant polynomial \\(p(x) = 0 \\text{ or } 1\\)?\n\n\npolynomial::degree\nReturns the degree of the polynomial.\n\n\npolynomial::monic\nIs this a monic polynomial (so no trailing zero coefficients).\n\n\npolynomial::count0\nHow many zero coefficients does this polynomial have?\n\n\npolynomial::count1\nHow many one coefficients does this polynomial have?\n\n\n\n\n\n\nModifiers\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\npolynomial::resize\nResizes the number of coefficients in the polynomial up or down. Any added coefficients are set to zero.\n\n\npolynomial::clear\nClears all the coefficients from the polynomial so that size() becomes 0.\n\n\npolynomial::make_monic\nEliminates any trailing zero coefficients to make the polynomial monic.\n\n\npolynomial::shrink_to_fit\nAttempts to free up any memory that is not used by the polynomial.\n\n\n\n\n\n\nCoefficient Access\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\npolynomial::operator[]\nAccess a particular polynomial coefficient naturally.\n\n\npolynomial::get\nRead-only access to a particular polynomial coefficient.\n\n\npolynomial::set\nWrite access to a particular polynomial coefficient or all of them at once.\n\n\npolynomial::reset\nWrite access to a particular polynomial coefficient or all of them at once.\n\n\npolynomial::coefficients\nRead-only access to the polynomial coefficients as a bit-vector.\n\n\npolynomial::set_coefficients\nWrite access to the polynomial coefficients as a bit-vector.\n\n\n\n\n\n\nPolynomial Evaluation\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\npolynomial::operator()\nEvaluate the polynomial for a scalar or bit-matrix argument.\n\n\n\n\n\n\nArithmetic\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\npolynomial::operator+=\nAdds another polynomial to this one.\n\n\npolynomial::operator-=\nSubtracts another polynomial from this one.\n\n\npolynomial::operator*=\nMultiplies this polynomial by another one.\n\n\npolynomial::times_x\nMultiplies this polynomial by a power of x.\n\n\npolynomial::squared\nReturns a new polynomial that is the square of this one.\n\n\n\n\n\n\nString Conversions\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\npolynomial::to_string\nReturns a string representation of the polynomial.\n\n\n\n\n\n\nOther Instance Methods\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\npolynomial::sub\nCreate a distinct sub-polynomial of this one.\n\n\npolynomial::split\nSplit polynomial \\(p(x)\\) into \\(p(x) = l(x) + x^n h(x)\\).\n\n\npolynomial::reduce\nReduces \\(x^e\\) by this polynomial (\\(e\\) can be very large).\n\n\n\n\n\n\nDebugging\nYou can set a compile-time flag to enable extra safety checks. These checks can have a severe performance penalty so typically are only turned on for development.\n\n\n\n\n\n\n\n\nMacro\nDescription\n\n\n\n\nBIT_DEBUG\nThis compile-time flag enables extra safety checks.\n\n\nbit_debug_assert\nThese assertions are only checked if you set the BIT_DEBUG flag at compile time.\n\n\nbit_always_assert\nThese assertions are always checked.",
    "crumbs": [
      "Home",
      "Bit-Polynomials",
      "Introduction"
    ]
  },
  {
    "objectID": "content/polynomial/index.html#non-member-functions",
    "href": "content/polynomial/index.html#non-member-functions",
    "title": "The bit::polynomial Class",
    "section": "Non-member Functions",
    "text": "Non-member Functions\n\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\npolynomial::operator+\nAdd two polynomials to get a new one.\n\n\npolynomial::operator-\nSubtract polynomials to get a new one.\n\n\npolynomial::operator*\nMultiply two polynomials to get a new one.\n\n\npolynomial::times_x\nMultiplies a polynomial by \\(x^n\\) to get a new one.\n\n\npolynomial::stream&gt;&gt;\nStream output for bit-polynomials.\n\n\npolynomial::formatter\nConnect the bit::polynomial class to std::format.",
    "crumbs": [
      "Home",
      "Bit-Polynomials",
      "Introduction"
    ]
  },
  {
    "objectID": "content/polynomial/reduce.html",
    "href": "content/polynomial/reduce.html",
    "title": "bit::polynomial — Reduction",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have a method that computes \\(x^N \\textrm{ mod } p(x)\\) where N is potentially a very large number.\n1polynomial reduce(std::size_t N, bool N_is_exponent = false) const;\n\n1\n\nIf the second argument is true then we compute \\(x^{2^N} \\textrm{ mod } p(x)\\). This allows for huge powers like \\(2^{100}\\) that overflow standard integer types.\n\n\n\n\n\n\n\n\nNonzero polynomials only\n\n\n\nThis method only makes sense for nonzero polynomials. Calling it for a zero polynomial will cause a std::invalid_argument exception to be thrown.\n\n\nLet \\(p(x)\\) be a polynomial of degree \\(n\\) over \\(\\FF\\) \\[\np(x) = p_0 + p_1 x + \\cdots + p_n x^n,\n\\] where \\(p_n = 1\\).\nThen for any power \\(N\\), we can write \\[\nx^N= q(x) p(x) + r(x),\n\\] where \\(q(x)\\) is some quotient polynomial and the degree of the remainder polynomial \\(r(x)\\) is strictly less than the degree of \\(p(x)\\).\nIn standard notation, we write \\[\nr(x) = x^N \\textrm{ mod } p(x).\n\\] Our method computes \\(r(x)\\).\n\n\n\n\n\n\nEfficiency\n\n\n\nThe method works by repeated squaring and multiplication and is efficient for large values of \\(N\\).\n\n\n\n\n\n\n\n\nWhy would we ever need this?\n\n\n\nComputing \\(x^N \\textrm{ mod } p(x)\\) for very large \\(N\\) can be used to jump far ahead in the random number streams produced by many pseudorandom generators — see this paper.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    std::size_t N = 123'456'789;\n    std::size_t n = 7;\n    auto        p = bit::polynomial&lt;&gt;::random(n);\n    auto        r = p.reduce(N);\n    std::cout &lt;&lt; std::format(\"x^({}) mod ({}) = {}\\n\", N, p, r);\n    return 0;\n}\nOutput\nx^(123456789) mod (1 + x^1 + x^2 + x^4 + x^5 + x^6 + x^7) = 1 + x^1 + x^2 + x^3 + x^4\n\n\n\n Back to top"
  },
  {
    "objectID": "content/polynomial/squared.html",
    "href": "content/polynomial/squared.html",
    "title": "bit::polynomial — Efficient Squaring",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods that efficiently compute the square of polynomials.\n1constexpr polynomial squared()                const;\n2constexpr void       squared(polynomial& dst) const;\n\n1\n\nReturns a new polynomial that is the square of this one.\n\n2\n\nFills a destination polynomial with coefficients that make it the square of this one.\n\n\nThe second version can be used for algorithms involving repeated squaring where you want to reuse the dst storage.\nThe squared methods are faster than using the multiplication operator.\nIf \\(p(x)\\) is represented by its coefficient vector \\(\\mathbf{p} = [ p_0, p_1, p_2, \\ldots ]\\): \\[\np(x) = p_0 + p_1 x + p_2 x^2 + \\cdots,\n\\] it is easy to verify that the polynomial \\(p(x)^2\\) has coefficients that are the vector::riffled version of \\(\\mathbf{p}\\).\nFor example, if \\(p(x) = a + bx\\) then \\[\np(x)^2 = a^2 + 2 a b x + b^2 x^2\n\\] In \\(\\FF\\), you drop all multiples of 2, and it follows that \\[\np(x)^2 = a + b x^2\n\\] The general case follows by induction.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::polynomial&lt;&gt; p{6};\n    p.set();\n\n    std::cout &lt;&lt; std::format(\"p(x)      = {}\\n\", p);\n    std::cout &lt;&lt; std::format(\"p(x)^2    = {}\\n\", p.squared());\n    std::cout &lt;&lt; std::format(\"p(x)*p(x) = {}\\n\", p*p);\n}\nOutput\np(x)      = 1 + x^1 + x^2 + x^3 + x^4 + x^5\np(x)^2    = 1 + x^2 + x^4 + x^6 + x^8 + x^10\np(x)*p(x) = 1 + x^2 + x^4 + x^6 + x^8 + x^10\n\nSee Also\nvector::riffled\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/polynomial/to_string.html",
    "href": "content/polynomial/to_string.html",
    "title": "bit::polynomial — String Form",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have a method that encodes a bit-polynomial as a string.\nstd::string to_string(std::string_view x = \"x\") const;\nThis method returns a string representation of the polynomial where the “variable” is x.\nThe default polynomial “variable” is x but, as shown in the following examples, you can easily change that.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto p = bit::polynomial&lt;&gt;::random(7);\n    std::cout &lt;&lt; \"Polynomial with default specifier:        \" &lt;&lt; p.to_string() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Polynomial with variable 'y' specified:   \" &lt;&lt; p.to_string(\"y\") &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Polynomial with variable 'M' specified:   \" &lt;&lt; p.to_string(\"M\") &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Polynomial with variable 'mat' specified: \" &lt;&lt; p.to_string(\"mat\") &lt;&lt; '\\n';\n}\nOutput\nPolynomial with default specifier:        1 + x^3 + x^5 + x^7\nPolynomial with variable 'y' specified:   1 + y^3 + y^5 + y^7\nPolynomial with variable 'M' specified:   1 + M^3 + M^5 + M^7\nPolynomial with variable 'mat' specified: 1 + mat^3 + mat^5 + mat^7\n\nSee Also\npolynomial::formatter\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/polynomial/formatter.html",
    "href": "content/polynomial/formatter.html",
    "title": "bit::polynomial — Custom Formatting",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe specialize the std::formatter class to connect any bit::polynomial to std::format and friends.\ntemplate&lt;std::unsigned_integral Block, typename Allocator&gt;\nstruct std::formatter&lt;bit::polynomial&lt;Block, Allocator&gt;&gt; {\n    ...\n};\nUnder the covers, this custom class calls the bit-polynomial’s to_string() method. The default polynomial “variable” is x but, as shown in the following examples, you can easily change that.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto p = bit::polynomial&lt;&gt;::random(7);\n    std::cout &lt;&lt; std::format(\"Polynomial with default specifier:        {}\\n\", p);\n    std::cout &lt;&lt; std::format(\"Polynomial with variable 'y' specified:   {:y}\\n\", p);\n    std::cout &lt;&lt; std::format(\"Polynomial with variable 'M' specified:   {:M}\\n\", p);\n    std::cout &lt;&lt; std::format(\"Polynomial with variable 'mat' specified: {:mat}\\n\", p);\n}\nOutput\nPolynomial with default specifier:        1 + x^1 + x^2 + x^3 + x^7\nPolynomial with variable 'y' specified:   1 + y^1 + y^2 + y^3 + y^7\nPolynomial with variable 'M' specified:   1 + M^1 + M^2 + M^3 + M^7\nPolynomial with variable 'mat' specified: 1 + mat^1 + mat^2 + mat^3 + mat^7\n\nSee Also\npolynomial::to_string\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/polynomial/monic.html",
    "href": "content/polynomial/monic.html",
    "title": "bit::polynomial — Monic",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have a method to query if this polynomial is monic and another that makes it monic if that is possible.\n1constexpr bool        monic() const;\n2constexpr polynomial& make_monic();\n\n1\n\nReturns true if this is a monic polynomial.\n\n2\n\nAttempts to shrink the polynomial to be monic. This does not change the memory footprint of the polynomial.\n\n\nA monic polynomial has no trailing zero coefficients.\nA monic polynomial of degree \\(n\\) will have exactly \\(n+1\\) coefficients \\(p_0, p_1, \\ldots, p_{n-1}\\) where \\[\np(x) = p_0 + p_q x + \\cdots + p_{n-1} x^{n-1},\n\\] and \\(p_{n-1} = 1\\).\nAfter a call to make_monic() any nonzero polynomial will have size() = degree() + 1.\n\n\n\n\n\n\nThe zero polynomial\n\n\n\nThe zero polynomial has no degree and is not monic.\nPolynomial methods usually need to treat the zero-polynomial as a special, generally trivial, edge case. The make_monic() method does nothing to a zero polynomial.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::polynomial&lt;&gt; p;\n    std::cout &lt;&lt; std::format(\"p(x) = {} has coefficients = {:p}.\\n\", p, p.coefficients());\n    std::cout &lt;&lt; std::format(\"Size: {}, monic: {}.\\n\\n\", p.size(), p.monic());\n\n    p.resize(7);\n    std::cout &lt;&lt; std::format(\"p(x) = {} has coefficients = {:p}.\\n\", p, p.coefficients());\n    std::cout &lt;&lt; std::format(\"Size: {}, monic: {}.\\n\\n\", p.size(), p.monic());\n\n    p[1] = p[3] = 1;\n    std::cout &lt;&lt; std::format(\"p(x) = {} has coefficients = {:p}.\\n\", p, p.coefficients());\n    std::cout &lt;&lt; std::format(\"Size: {}, monic: {}.\\n\\n\", p.size(), p.monic());\n\n    p.make_monic();\n    std::cout &lt;&lt; std::format(\"p(x) = {} has coefficients = {:p}.\\n\", p, p.coefficients());\n    std::cout &lt;&lt; std::format(\"Size: {}, monic: {}.\\n\", p.size(), p.monic());\n}\nOutput\np(x) = 0 has coefficients = [].\nSize: 0, monic: false.\n\np(x) = 0 has coefficients = [0 0 0 0 0 0 0].\nSize: 7, monic: false.\n\np(x) = x^1 + x^3 has coefficients = [0 1 0 1 0 0 0].\nSize: 7, monic: false.\n\np(x) = x^1 + x^3 has coefficients = [0 1 0 1].\nSize: 4, monic: true.\n\nSee Also\npolynomial::size\npolynomial::degree\npolynomial::to_string\npolynomial::shrink_to_fit\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/polynomial/power.html",
    "href": "content/polynomial/power.html",
    "title": "bit::polynomial — Power Polynomial",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nFactory method to construct the polynomial \\(p(x) = x^n\\).\nstatic bit::polynomial power(std::size_t n);\nThis polynomial will have \\(n+1\\) coefficients.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto p0 = bit::polynomial&lt;&gt;::power(0);\n    std::cout &lt;&lt; std::format(\"p0(x) = {} has coefficients {:p}.\\n\", p0, p0.coefficients());\n\n    auto p1 = bit::polynomial&lt;&gt;::power(7);\n    std::cout &lt;&lt; std::format(\"p1(x) = {} has coefficients {:p}.\\n\", p1, p1.coefficients());\n}\nOutput\np0(x) = 1 has coefficients [1].\np1(x) = x^7 has coefficients [0 0 0 0 0 0 0 1].\n\nSee Also\npolynomial::constructors\npolynomial::random\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/count.html",
    "href": "content/vector/count.html",
    "title": "bit::vector — Bit Counts",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nThese methods count the number of set/unset elements in a bit-vector.\n1constexpr std::size_t count()  const;\n2constexpr std::size_t count1() const;\n3constexpr std::size_t count0() const;\n4constexpr bool parity() const;\n\n1\n\nReturns the number of elements in the bit-vector set to 1.\n\n2\n\nReturns the number of elements in the bit-vector set to 1 (synonym for count())\n\n3\n\nReturns the number of elements in the bit-vector set to 0.\n\n4\n\nReturns count() % 2— the number of set elements mod 2.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto v1 = bit::vector&lt;&gt;::zeros(5);\n    auto v2 = bit::vector&lt;&gt;::checker_board(5);\n    auto v3 = bit::vector&lt;&gt;::ones(5);\n\n    std::cout\n        &lt;&lt; \"vector\\t\\t\" &lt;&lt; \"count1\\t\" &lt;&lt; \"count0\\t\" &lt;&lt; \"parity\\n\"\n        &lt;&lt; v1 &lt;&lt; '\\t' &lt;&lt; v1.count1() &lt;&lt; '\\t' &lt;&lt; v1.count0() &lt;&lt; '\\t' &lt;&lt; v1.parity() &lt;&lt; '\\n'\n        &lt;&lt; v2 &lt;&lt; '\\t' &lt;&lt; v2.count1() &lt;&lt; '\\t' &lt;&lt; v2.count0() &lt;&lt; '\\t' &lt;&lt; v2.parity() &lt;&lt; '\\n'\n        &lt;&lt; v3 &lt;&lt; '\\t' &lt;&lt; v3.count1() &lt;&lt; '\\t' &lt;&lt; v3.count0() &lt;&lt; '\\t' &lt;&lt; v3.parity() &lt;&lt; '\\n';\n}\nOutput\nvector          count1  count0  parity\n[0 0 0 0 0]     0       5       0\n[0 1 0 1 0]     2       3       0\n[1 1 1 1 1]     5       0       1\n\nSee Also\nvector::size\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/logical-op.html",
    "href": "content/vector/logical-op.html",
    "title": "bit::vector — Logical Op Operators",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nThese are non-member functions to perform element-by-element binary AND, XOR, OR, DIFF between two equal-sized bit-vectors.\ntemplate&lt;std::unsigned_integral Block, typename Alloc&gt;\nconstexpr bit::vector&lt;Block, Alloc&gt;\noperator&(const bit::vector&lt;Block, Alloc&gt; &lhs,\n1          const bit::vector&lt;Block, Alloc&gt; &rhs);\noperator^(const bit::vector&lt;Block, Alloc&gt; &lhs,\n2          const bit::vector&lt;Block, Alloc&gt; &rhs);\noperator|(const bit::vector&lt;Block, Alloc&gt; &lhs,\n3          const bit::vector&lt;Block, Alloc&gt; &rhs);\noperator+(const bit::vector&lt;Block, Alloc&gt; &lhs,\n4          const bit::vector&lt;Block, Alloc&gt; &rhs);\noperator-(const bit::vector&lt;Block, Alloc&gt; &lhs,\n5          const bit::vector&lt;Block, Alloc&gt; &rhs);\noperator*(const bit::vector&lt;Block, Alloc&gt; &lhs,\n6          const bit::vector&lt;Block, Alloc&gt; &rhs);\n\n1\n\nReturns a bit-vector whose bits result from binary AND between the corresponding pairs of bits of rhs and lhs.\n\n2\n\nReturns a bit-vector whose bits result from binary XOR between the corresponding pairs of bits of rhs and lhs.\n\n3\n\nReturns a bit-vector whose bits result from binary OR between the corresponding pairs of bits of rhs and lhs.\n\n4\n\nReturns a bit-vector whose bits result from binary XOR between the corresponding pairs of bits of rhs and lhs.\nIn GF(2), addition corresponds to the logical XOR operation.\n\n5\n\nReturns a bit-vector whose bits result from binary XOR between the corresponding pairs of bits of rhs and lhs.\nIn GF(2), subtraction corresponds to the logical XOR operation.\n\n6\n\nReturns a bit-vector whose bits result from binary AND between the corresponding pairs of bits of rhs and lhs.\nIn GF(2), multiplication corresponds to the logical AND operation.\n\n\n\n\n\n\n\n\nSize checking\n\n\n\nThe two vectors in question must be of the same size.\nSet the BIT_DEBUG flag at compile time to check this condition — any violation will cause the program to abort with a helpful message.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    bit::vector&lt;&gt; u(11, [&](size_t k) { return k % 2; });\n2    bit::vector&lt;&gt; v(11, [&](size_t k) { return (k + 1) % 2; });\n    std::cout &lt;&lt; u &lt;&lt; \" & \" &lt;&lt; v &lt;&lt; \" = \" &lt;&lt; (u & v) &lt;&lt; '\\n';\n    std::cout &lt;&lt; u &lt;&lt; \" ^ \" &lt;&lt; v &lt;&lt; \" = \" &lt;&lt; (u ^ v) &lt;&lt; '\\n';\n    std::cout &lt;&lt; u &lt;&lt; \" | \" &lt;&lt; v &lt;&lt; \" = \" &lt;&lt; (u | v) &lt;&lt; '\\n';\n}\n\n1\n\nCreates a vector of size 11 by calling a lambda that sets all the even indices.\n\n2\n\nCreates a vector of size 11 by calling a lambda that sets all the odd indices.\n\n\nOutput\n[0 1 0 1 0 1 0 1 0 1 0] & [1 0 1 0 1 0 1 0 1 0 1] = [0 0 0 0 0 0 0 0 0 0 0]\n[0 1 0 1 0 1 0 1 0 1 0] ^ [1 0 1 0 1 0 1 0 1 0 1] = [1 1 1 1 1 1 1 1 1 1 1]\n[0 1 0 1 0 1 0 1 0 1 0] | [1 0 1 0 1 0 1 0 1 0 1] = [1 1 1 1 1 1 1 1 1 1 1]\n\nSee Also\nvector::operator&=\nvector::operator|=\nvector::operator^=\nvector::operator+=\nvector::operator-=\nvector::operator*=\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/swap.html",
    "href": "content/vector/swap.html",
    "title": "bit::vector — Swap All Content",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nSwap the bits of this bit-vector with that of another.\nconstexpr bit::vector &swap(bit::vector &other);\nThis method returns a reference to *this so it can be chained with other calls.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto u = bit::vector&lt;&gt;::zeros(2);\n    auto v = bit::vector&lt;&gt;::ones(4);\n    std::cout &lt;&lt; \"u, v: \" &lt;&lt; u &lt;&lt; \", \" &lt;&lt; v &lt;&lt; '\\n';\n    u.swap(v);\n    std::cout &lt;&lt; \"u, v: \" &lt;&lt; u &lt;&lt; \", \" &lt;&lt; v &lt;&lt; '\\n';\n}\nOutput\nu, v: [0 0], [1 1 1 1]\nu, v: [1 1 1 1], [0 0]\n\nSee Also\nvector::swap_elements\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/if_set_call.html",
    "href": "content/vector/if_set_call.html",
    "title": "bit::vector — Iterate over the Set Bits",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods that iterate over the elements in a bit-vector calling a function f(i) for every index i where the corresponding element is 1.\n1constexpr void if_set_call(std::invocable&lt;std::size_t&gt; auto f) const;\n2constexpr void reverse_if_set_call(std::invocable&lt;std::size_t&gt; auto f) const;\n\n1\n\nThe iteration here is in the order vector.first_set() forward to vector.final_set().\n\n2\n\nThe iteration here is in the order vector.final_set() backward to vector.first_set().\n\n\nIn these methods, the f parameter is any function taking an index as its argument. See std::invocable. For each set element index pos, these methods will be called f(pos).\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    bit::vector&lt;&gt; v(11, [&](size_t k) { return (k + 1) % 2; });\n    std::cout &lt;&lt; \"The set indices in \" &lt;&lt; v &lt;&lt; \" are \";\n2    v.if_set_call([](std::size_t k) { std::cout &lt;&lt; k &lt;&lt; ' '; });\n    std::cout &lt;&lt; std::endl;\n}\n\n1\n\nCreates a vector of size 11 by calling a lambda that sets all the even indices.\n\n2\n\nThe trivial print to std::cout lambda is called if the corresponding element in v is set.\n\n\nOutput\nThe set indices in [1 0 1 0 1 0 1 0 1 0 1] are 0 2 4 6 8 10\n\nSee Also\nvector::first_set\nvector::final_set\nvector::next_set\nvector::prev_set\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/replace.html",
    "href": "content/vector/replace.html",
    "title": "bit::vector — Replace Elements",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nDefines methods that replace some of this bit-vector’s values with those of another.\n1constexpr bit::vector &replace(std::size_t i0, const bit::vector &with);\n2constexpr bit::vector &replace(const bit::vector &with);\n\n1\n\nStarting at element i0, replace the bit-vector values with those from the bit-vector with.\n\n2\n\nStarting at element 0, replace the bit-vector values with those from the bit-vector with.\n\n\n\n\n\n\n\n\nSizes must be compatible\n\n\n\nThe sub-vector with we are copying from must fit inside the existing bit-vector!\nSet the BIT_DEBUG flag at compile time to check this condition — any violation will cause the program to abort with a helpful message.\n\n\nBoth methods return a reference to *this so can be chained with other calls.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto u = bit::vector&lt;&gt;::zeros(3);\n    auto v = bit::vector&lt;&gt;::ones(10);\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; '\\n';\n1    v.replace(7,u);\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; '\\n';\n2    v.replace(u);\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; '\\n';\n}\n\n1\n\nReplace the final three elements of v with those from u.\n\n2\n\nReplace the first three elements of v with those from u.\n\n\nOutput\nv: [1 1 1 1 1 1 1 1 1 1]\nv: [1 1 1 1 1 1 1 0 0 0]\nv: [0 0 0 1 1 1 1 0 0 0]\n\nSee Also\nvector::sub\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/set_if.html",
    "href": "content/vector/set_if.html",
    "title": "bit::vector — Conditional Change",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nDefine methods to set or flip the element values in a bit-vector based on the return value from a function call.\n1constexpr bit::vector &set_if(std::invocable&lt;std::size_t, std::size_t&gt; auto f);\n2constexpr bit::vector &flip_if(std::invocable&lt;std::size_t, std::size_t&gt; auto f);\n\n1\n\nSets element i to 1 if f(i) != 0, otherwise sets it to 0.\n\n2\n\nFlips the value of element i if f(i) != 0, otherwise leaves it unchanged.\n\n\nf is a function, and we expect to call f(i) for each set index.\nThese return a reference to *this, so can be chained with other calls.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    bit::vector&lt;&gt; v(16);\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; '\\n';\n2    v.set_if([](std::size_t i) { return (i + 1) % 2; });\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; '\\n';\n3    v.flip_if([](std::size_t i) { return (i + 1) % 2; });\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; '\\n';\n}\n\n1\n\nStart with a bit-vector whose elements are all 0 by default.\n\n2\n\nUsing the set_if method with a lambda to set the even indices 0,2,4,…\n\n3\n\nUsing the flip_if method with a lambda to flip the even indices 0,2,4,…\n\n\nOutput\nv: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\nv: [1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0]\nv: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n\nSee Also\nvector::set\nvector::reset\nvector::flip\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/copy.html",
    "href": "content/vector/copy.html",
    "title": "bit::vector — Copying Bits",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\nWe supply several copy functions.\nThey all have the general form bit::copy(src, dst) where the src argument(s) is the source of bits and the dst arguments(s) is the destination for those bits."
  },
  {
    "objectID": "content/vector/copy.html#to-bit-vectors",
    "href": "content/vector/copy.html#to-bit-vectors",
    "title": "bit::vector — Copying Bits",
    "section": "To Bit-Vectors",
    "text": "To Bit-Vectors\nOne set of copy functions overwrites a destination bit-vector with bits sourced from an unsigned word, a collection of unsigned words, or a std::bitset:\ntemplate&lt;std::unsigned_integral Src, std::unsigned_integral Block, typename Alloc&gt;\nconstexpr void\n1copy(Src src, bit::vector&lt;Block, Alloc&gt; &dst);\n\ntemplate&lt;typename Iter, std::unsigned_integral Block, typename Alloc&gt;\nconstexpr void\n2copy(Iter src_b, Iter src_e, bit::vector&lt;Block, Alloc&gt; &dst);\n\ntemplate&lt;std::unsigned_integral Src, std::unsigned_integral Block, typename Alloc&gt;\nconstexpr void\n3copy(std::initializer_list&lt;Src&gt; src, bit::vector&lt;Block, Alloc&gt; &dst);\n\ntemplate&lt;std::unsigned_integral Src, std::unsigned_integral Block, typename Alloc&gt;\nconstexpr void\n4copy(const std::vector&lt;Src&gt; &src, bit::vector&lt;Block, Alloc&gt; &dst);\n\ntemplate&lt;std::unsigned_integral Src, std::size_t N, std::unsigned_integral Block, typename Alloc&gt;\nconstexpr void\n5copy(const std::array&lt;Src,N&gt; &src, bit::vector&lt;Block, Alloc&gt; &dst);\n\ntemplate&lt;std::size_t N, std::unsigned_integral Block, typename Alloc&gt;\nconstexpr void\n6copy(const std::bitset&lt;N&gt; &src, bit::vector&lt;Block, Alloc&gt; &dst);\n\n1\n\nOverwrites dst with the bits from a single word src, which is some unsigned integer type.\n\n2\n\nOverwrites dst with the bits from an iteration where the value_type of the iterator is some unsigned integer type.\n\n3\n\nOverwrites dst with the bits from an initializer-style list of unsigned integers.\n\n4\n\nOverwrites dst with the bits from a vector of unsigned integers.\n\n5\n\nOverwrites dst with the bits from a fixed array of unsigned integers.\n\n6\n\nOverwrites dst with the bits from a std::bitset.\n\n\n\n\n\n\n\n\nThese resize the destination\n\n\n\nThese functions all resize the destination bit-vector to make it absorb all the source bits."
  },
  {
    "objectID": "content/vector/copy.html#from-bit-vectors",
    "href": "content/vector/copy.html#from-bit-vectors",
    "title": "bit::vector — Copying Bits",
    "section": "From Bit-Vectors",
    "text": "From Bit-Vectors\nAnother set of copy functions uses a bit-vector as the source of bits to fill various destinations — unsigned words, collections of unsigned words, or a std::bitset:\ntemplate&lt;std::unsigned_integral Block, typename Alloc, std::unsigned_integral Dst&gt;\nconstexpr void\n1copy(const vector&lt;Block, Alloc&gt; &src, Dst &dst);\n\ntemplate&lt;std::unsigned_integral Block, typename Alloc, typename Iter&gt;\nconstexpr void\n2copy(const vector&lt;Block, Alloc&gt; &src, Iter dst_b, Iter dst_e);\n\ntemplate&lt;std::unsigned_integral Block, typename Alloc, std::unsigned_integral Dst, std::size_t N&gt;\nconstexpr void\n3copy(const vector&lt;Block, Alloc&gt; &src, std::array&lt;Dst, N&gt; &dst);\n\ntemplate&lt;std::unsigned_integral Block, typename Alloc, std::unsigned_integral Dst&gt;\nconstexpr void\n4copy(const vector&lt;Block, Alloc&gt; &src, std::vector&lt;Dst&gt; &dst);\n\ntemplate&lt;std::size_t N, std::unsigned_integral Block, typename Alloc&gt;\nconstexpr void\n5copy(const vector&lt;Block, Alloc&gt; &src, std::bitset&lt;N&gt; &dst);\n\n1\n\nInitializes word dst to zero and then fills it with as many bits as possible from the src bit-vector.\n\n2\n\nInitializes an iteration of unsigned integers to zeros and fills them with as many bits as possible from the src bit-vector.\n\n3\n\nInitializes an array of unsigned integers to zeros and fills it with as many bits as possible from the src bit-vector.\n\n4\n\nInitializes a vector of unsigned integers to zeros and fills it with as many bits as possible from the src bit-vector.\n\n5\n\nSets all the bits in a std::bitset to zero and then fills it with as many bits as possible from the src bit-vector.\n\n\n\n\n\n\n\n\nThese do not resize the destination\n\n\n\nThese functions do not resize the destination. We start sourcing bits from the beginning of the bit-vector. We stop when we run out of source bits or have no more space to put the bits. Note that the destination gets initialized to all zeros. Thus, if the source bit-vector is empty, the destination will be returned filled with zeros.\n\n\nIn many applications, we use these copy functions to flip back and forth between bit-space and word-space.\nIn word-space, the sources and destinations are often a std::vector or a std::array, so we supply specializations for those collections — one could get by just using the versions of copy that take iterators."
  },
  {
    "objectID": "content/vector/copy.html#copying-all-bits-from-a-bit-vector",
    "href": "content/vector/copy.html#copying-all-bits-from-a-bit-vector",
    "title": "bit::vector — Copying Bits",
    "section": "Copying ALL bits from a bit-vector",
    "text": "Copying ALL bits from a bit-vector\nOne final copy type function takes all the bits from a bit-vector and uses them to fill a vector of words of some unsigned type.\ntemplate&lt;std::unsigned_integral Block, typename Alloc, std::unsigned_integral Dst&gt;\nconstexpr void\ncopy_all(const vector&lt;Block, Alloc&gt; &src, std::vector&lt;Dst&gt; &dst);\nAs the name suggests, this copy function first resizes the destination vector to accommodate all the bits in the source bit-vector and then copies them."
  },
  {
    "objectID": "content/vector/copy.html#template-parameters",
    "href": "content/vector/copy.html#template-parameters",
    "title": "bit::vector — Copying Bits",
    "section": "Template Parameters",
    "text": "Template Parameters\n\n\n\n\n\n\n\n\nParameter\nDescription\n\n\n\n\nSrc\nThe type of unsigned integers whose bits will fill the destination bit-vector. There is no requirement that Src and Block are the same. For example, we can add the bits from a list of 32-bit unsigned integers while the storage scheme for the bit-vector remains the default 64-bit type.\n\n\nDst\nThe type of unsigned integers getting set from the bits in the source bit-vector. There is no requirement that Dst and Block are the same. For example, we can fill an array of 32-bit unsigned integers while the storage scheme for the bit-vector remains the default 64-bit type.\n\n\nIter\nAn iterator–might be the type returned by any std::cbegin(collection) and std::cend(collection) Iter::value_type should be some unsigned integer type, but it need not match the Block type.\n\n\n\n\nExample — Overwriting a bit-vector with the bits from unsigned words\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    bit::vector v;\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; '\\n';\n2    bit::copy(uinteight_t(0), v);\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; '\\n';\n3    bit::copy({uinteight_t(255), uinteight_t(0)}, v);\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; '\\n';\n4    std::vector&lt;uinteight_t&gt; vec{255, 0};\n    bit::copy(vec, v);\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; '\\n';\n5    bit::copy(vec.cbegin(), vec.cend(), v);\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; '\\n';\n6    std::bitset&lt;eight&gt; bs(255);\n    bit::copy(bs, v);\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; '\\n';\n}\n\n1\n\nDefault constructor makes an empty vector.\n\n2\n\nFills with eight 0-bits.\n\n3\n\nFill with a list of eight 1-bits and eight 0-bits.\n\n4\n\nFills with a std::vector with eight 1-bits and eight 0-bits.\n\n5\n\nFills with a std::vector with eight 1-bits and eight 0-bits using the usual iterators.\n\n6\n\nFills with a std::bitset with eight 1-bits.\n\n\nOutput\nv:\nv: 00000000\nv: 1111111100000000\nv: 1111111100000000\nv: 1111111100000000\nv: 11111111\nExample — Overwriting a unsigned word(s) with the bits from a bit-vector\n#include &lt;bit/bit.h&gt;\n\n/// @brief Print a `std::array` to a stream which defaults to @c std::cout\ntemplate&lt;typename T, std::size_t N&gt;\nvoid print(const std::array&lt;T, N&gt; &v, std::ostream &os = std::cout)\n{\n    if (N == 0) { os &lt;&lt; \"[]\"; return; }\n    os &lt;&lt; \"[\";\n    for (std::size_t i = 0; i &lt; N - 1; ++i) os &lt;&lt; v[i] &lt;&lt; \", \";\n    os &lt;&lt; v[N - 1] &lt;&lt; \"]\\n\";\n}\n\n/// @brief Print a `std::vector` to a stream which defaults to @c std::cout\ntemplate&lt;typename T&gt;\nvoid print(const std::vector&lt;T&gt; &v, std::ostream &os = std::cout)\n{\n    auto n = v.size();\n    if (n == 0) { os &lt;&lt; \"[]\"; return; }\n    os &lt;&lt; \"[\";\n    for (std::size_t i = 0; i &lt; n - 1; ++i) os &lt;&lt; v[i] &lt;&lt; \", \";\n    os &lt;&lt; v[n - 1] &lt;&lt; \"]\\n\";\n}\n\nint main()\n{\n    using Block = uint8_t;\n\n    auto v = bit::vector&lt;Block&gt;::ones(77);\n    std::cout &lt;&lt; \"bit::vector: \" &lt;&lt; v.to_string() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Copying that bit-vector to words of various types:\\n\";\n    uint16_t word16;  bit::copy(v, word16);\n    std::cout &lt;&lt; \"uint16_t:    \" &lt;&lt; word16 &lt;&lt; '\\n';\n    uint32_t word32;  bit::copy(v, word32);\n    std::cout &lt;&lt; \"uint32_t:    \" &lt;&lt; word32 &lt;&lt; '\\n';\n    uint64_t word64;  bit::copy(v, word64);\n    std::cout &lt;&lt; \"uint64_t:    \" &lt;&lt; word64 &lt;&lt; '\\n';\n    std::cout &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"bit::vector: \" &lt;&lt; v.to_string() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Copying that bit-vector to a std::array of words of various types:\\n\";\n    constexpr std::size_t N = 4;\n    std::array&lt;uint16_t, N&gt; arr16; bit::copy(v, arr16);\n    std::cout &lt;&lt; \"std::array&lt;uint16_t,4&gt;: \"; print(arr16);\n    std::array&lt;uint32_t, N&gt; arr32; bit::copy(v, arr32);\n    std::cout &lt;&lt; \"std::array&lt;uint32_t,4&gt;: \"; print(arr32);\n    std::array&lt;uint64_t, N&gt; arr64; bit::copy(v, arr64);\n    std::cout &lt;&lt; \"std::array&lt;uint64_t,4&gt;: \"; print(arr64);\n    std::cout &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"bit::vector: \" &lt;&lt; v.to_string() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Copying that bit-vector to a std::vector of words of various types:\\n\";\n    std::vector&lt;uint16_t&gt; vec16(N); bit::copy(v, vec16);\n    std::cout &lt;&lt; \"std::vector&lt;uint16_t&gt;: \"; print(vec16);\n    std::vector&lt;uint32_t&gt; vec32(N); bit::copy(v, vec32);\n    std::cout &lt;&lt; \"std::vector&lt;uint32_t&gt;: \"; print(vec32);\n    std::vector&lt;uint64_t&gt; vec64(N); bit::copy(v, vec64);\n    std::cout &lt;&lt; \"std::vector&lt;uint64_t&gt;: \"; print(vec64);\n    std::cout &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"bit::vector: \" &lt;&lt; v.to_string() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Copying ALL of that bit-vector to a std::vector of words of various types:\\n\";\n    bit::copy_all(v, vec16);\n    std::cout &lt;&lt; \"std::vector&lt;uint16_t&gt;: \"; print(vec16);\n    bit::copy_all(v, vec32);\n    std::cout &lt;&lt; \"std::vector&lt;uint32_t&gt;: \"; print(vec32);\n    bit::copy_all(v, vec64);\n    std::cout &lt;&lt; \"std::vector&lt;uint64_t&gt;: \"; print(vec64);\n    std::cout &lt;&lt; std::endl;\n}\nOutput\nbit::vector: 11111111111111111111111111111111111111111111111111111111111111111111111111111\nCopying that bit-vector to words of various types:\nuint16_t:    65535\nuint32_t:    4294967295\nuint64_t:    1eight446744073709551615\n\nbit::vector: 11111111111111111111111111111111111111111111111111111111111111111111111111111\nCopying that bit-vector to a std::array of words of various types:\nstd::array&lt;uint16_t,4&gt;: [65535, 65535, 65535, 65535]\nstd::array&lt;uint32_t,4&gt;: [4294967295, 4294967295, 8191, 0]\nstd::array&lt;uint64_t,4&gt;: [1eight446744073709551615, 8191, 0, 0]\n\nbit::vector: 11111111111111111111111111111111111111111111111111111111111111111111111111111\nCopying that bit-vector to a std::vector of words of various types:\nstd::vector&lt;uint16_t&gt;: [65535, 65535, 65535, 65535]\nstd::vector&lt;uint32_t&gt;: [4294967295, 4294967295, 8191, 0]\nstd::vector&lt;uint64_t&gt;: [1eight446744073709551615, 8191, 0, 0]\n\nbit::vector: 11111111111111111111111111111111111111111111111111111111111111111111111111111\nCopying ALL of that bit-vector to a std::vector of words of various types:\nstd::vector&lt;uint16_t&gt;: [65535, 65535, 65535, 65535, 8191]\nstd::vector&lt;uint32_t&gt;: [4294967295, 4294967295, 8191]\nstd::vector&lt;uint64_t&gt;: [1eight446744073709551615, 8191]\n\nSee Also\nvector::append"
  },
  {
    "objectID": "content/vector/resize.html",
    "href": "content/vector/resize.html",
    "title": "bit::vector — Resize a Bit-Vector",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nResize a bit-vector initializing added elements to 0.\nconstexpr bit::vector &resize(std::size_t n);\nIf n &lt; size(), the bit-vector is reduced in size to the first n elements. + If n &gt; size(), extra 0’s are appended to the bit-vector to get it up to size n.\nThis method returns a reference to *this so it can be chained with other calls.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    auto v = bit::vector&lt;uint8_t&gt;::checker_board(8);\n    std::cout &lt;&lt; v &lt;&lt; \":\\t\\t size \" &lt;&lt; v.size() &lt;&lt; \", capacity \" &lt;&lt; v.capacity() &lt;&lt; '\\n';\n2    v.resize(12);\n    std::cout &lt;&lt; v &lt;&lt; \":\\t size \"   &lt;&lt; v.size() &lt;&lt; \", capacity \" &lt;&lt; v.capacity()  &lt;&lt; '\\n';\n3    v.resize(8);\n    std::cout &lt;&lt;  v &lt;&lt; \":\\t\\t size \" &lt;&lt; v.size() &lt;&lt; \",capacity \" &lt;&lt; v.capacity() &lt;&lt; '\\n';\n}\n\n1\n\nConstruct a bit-vector of size eight where the underlying block size is just 8 bits.\n\n2\n\nResize the bit-vector to have twelve elements where the extra four are all 0.\n\n3\n\nResize the bit-vector back down to the original eight elements.\n\n\nOutput\n[1 0 1 0 1 0 1 0]:               size 8,  capacity 8\n[1 0 1 0 1 0 1 0 0 0 0 0]:       size 12, capacity 16\n[1 0 1 0 1 0 1 0]:               size 8,  capacity 16\n\nSee Also\nvector::reserve\nvector::description\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/logical-op-eq.html",
    "href": "content/vector/logical-op-eq.html",
    "title": "bit::vector — Logical Op= Operators",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nThese methods perform element-by-element binary AND, XOR, OR with another equal sized bit-vector.\n1constexpr bit::vector &operator&=(const bit::vector &other);\n2constexpr bit::vector &operator^=(const bit::vector &other);\n3constexpr bit::vector &operator|=(const bit::vector &other);\n4constexpr bit::vector &operator+=(const bit::vector &other);\n5constexpr bit::vector &operator-=(const bit::vector &other);\n6constexpr bit::vector &operator*=(const bit::vector &other);\n\n1\n\nSets this bit-vector’s bits to the result of binary AND between the corresponding pairs of bits of *this and other.\n\n2\n\nSets this bit-vector’s bits to the result of binary XOR between the corresponding pairs of bits of *this and other.\n\n3\n\nSets this bit-vector’s bits to the result of binary OR between the corresponding pairs of bits of *this and other.\n\n4\n\nSets this bit-vector’s bits to the result of binary XOR between the corresponding pairs of bits of *this and other.\nIn GF(2), addition corresponds to the logical XOR operation.\n\n5\n\nSets this bit-vector’s bits to the result of binary XOR between the corresponding pairs of bits of *this and other.\nIn GF(2), subtraction corresponds to the logical XOR operation.\n\n6\n\nSets this bit-vector’s bits to the result of binary AND between the corresponding pairs of bits of *this and other.\nIn GF(2), multiplication corresponds to the logical AND operation.\n\n\nThese methods all return a reference to *this so they can be chained with other calls.\n\n\n\n\n\n\nSize checking\n\n\n\nThe two vectors in question must be of the same size.\nSet the BIT_DEBUG flag at compile time to check this condition — any violation will cause the program to abort with a helpful message.\n\n\n1constexpr bit::vector operator~() const;\n\n1\n\nReturns a copy of the bit-vector with all the bits flipped\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    bit::vector&lt;&gt; u(11, [&](size_t k) { return k % 2; });\n2    bit::vector&lt;&gt; v(11, [&](size_t k) { return (k + 1) % 2; });\n    std::cout &lt;&lt; \"u:        \" &lt;&lt; u &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v:        \" &lt;&lt; v &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"(u &= v): \" &lt;&lt; (u &= v) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"(u |= v): \" &lt;&lt; (u |= v) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"(u ^= v): \" &lt;&lt; (u ^= v) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"~u:       \" &lt;&lt; ~u &lt;&lt; '\\n';\n}\n\n1\n\nCreates a vector of size 11 by calling a lambda that sets all the even indices.\n\n2\n\nCreates a vector of size 11 by calling a lambda that sets all the odd indices.\n\n\nOutput\nu:        [0 1 0 1 0 1 0 1 0 1 0]\nv:        [1 0 1 0 1 0 1 0 1 0 1]\n(u &= v): [0 0 0 0 0 0 0 0 0 0 0]\n(u |= v): [1 0 1 0 1 0 1 0 1 0 1]\n(u ^= v): [0 0 0 0 0 0 0 0 0 0 0]\n~u:       [1 1 1 1 1 1 1 1 1 1 1]\n\nSee Also\nvector::operator&\nvector::operator|\nvector::operator^\nvector::operator+\nvector::operator-\nvector::operator*\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/size.html",
    "href": "content/vector/size.html",
    "title": "bit::vector — Size Queries",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nHow many elements are in the bit-vector?\n1constexpr std::size_t size() const;\n2constexpr bool empty() const;\n\n1\n\nReturns the number of elements in the bit-vector.\n\n2\n\nReturns true if the bit-vector has no elements (so size() == 0), returns false otherwise.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::vector&lt;&gt; v1;\n    auto v2 = bit::vector&lt;&gt;::checker_board(4);\n    std::cout\n        &lt;&lt; \"vector\\t\\t\" &lt;&lt; \"size\\t\" &lt;&lt; \"empty?\\n\"\n        &lt;&lt; v1 &lt;&lt; \"\\t\\t\" &lt;&lt; v1.size() &lt;&lt; '\\t' &lt;&lt; v1.empty() &lt;&lt; '\\n'\n        &lt;&lt; v2 &lt;&lt; '\\t'   &lt;&lt; v2.size() &lt;&lt; '\\t' &lt;&lt; v2.empty() &lt;&lt; '\\n';\n}\nOutput\nvector          size    empty?\n[]              0       1\n[0 1 0 1]       4       0\n\nSee Also\nvector::count\nvector::description\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/diff.html",
    "href": "content/vector/diff.html",
    "title": "bit::vector — Logical Differences",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nCompute the logical DIFF of two equal-sized bit-vectors.\ntemplate&lt;std::unsigned_integral Block, typename Allocator&gt;\nconstexpr bit::vector&lt;Block, Allocator&gt;\ndiff(const bit::vector&lt;Block, Allocator&gt; &u,\n1     const bit::vector&lt;Block, Allocator&gt; &v);\n\n1\n\nReturns a bit-vector w where w[i] = 1 if u[i] != v[i] and 0 otherwise.\n\n\n\n\n\n\n\n\nSize checking\n\n\n\nThe two vectors in question must be of the same size.\nSet the BIT_DEBUG flag at compile time to check this condition — any violation will cause the program to abort with a helpful message.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto u = bit::vector&lt;&gt;::ones(6);\n    auto v = bit::vector&lt;&gt;::checker_board(6);\n    std::cout &lt;&lt; \"diff(\" &lt;&lt; u.to_string() &lt;&lt; \", \"&lt;&lt; v.to_string() &lt;&lt; \") yields \"\n              &lt;&lt; bit::diff(u, v).to_string() &lt;&lt; '\\n';\n}\nOutput\ndiff(111111, 010101) yields 101010\n\nSee Also\nvector::append\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/dot.html",
    "href": "content/vector/dot.html",
    "title": "bit::vector — Dot Product for Bit-Vectors",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nCompute the dot product of two equal-sized bit-vectors.\n1constexpr bool dot(const bit::vector &v);\n\ntemplate&lt;std::unsigned_integral Block, typename Allocator&gt;\nconstexpr bool\n2dot(const bit::vector&lt;Block, Allocator&gt; &u,\n    const bit::vector&lt;Block, Allocator&gt; &v);\n\n1\n\nInstance method that returns the dot product of this bit-vector with another equal-sized bit-vector v.\n\n2\n\nNon-member function that returns the dot product of two equal-sized bit-vectors u and v.\n\n\nThe dot product is defined by \\[\n\\mathbf{u} \\cdot \\mathbf{v} = \\sum_i u_i v_i.\n\\] In the case of bit-vectors, products are replaced by logical AND and sums by the logical XOR operation.\nThe dot product is a critical operation in linear algebra, so it is fortunate that AND’ing and XOR’ing for bit-vectors can be done efficiently over blocks of elements simultaneously.\nThe required result is just the one-liner (lhs & rhs).parity().\n\n\n\n\n\n\nSize checking\n\n\n\nThe two vectors in question must be of the same size.\nSet the BIT_DEBUG flag at compile time to check this condition — any violation will cause the program to abort with a helpful message.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::vector&lt;&gt; u(\"01111110\");\n    bit::vector&lt;&gt; v(\"10101010\");\n\n    auto u_str = u.to_string();\n    auto v_str = v.to_string();\n\n    std::cout &lt;&lt; \"bit::dot(\" &lt;&lt; u_str &lt;&lt; \", \" &lt;&lt; v_str &lt;&lt; \") = \" &lt;&lt; bit::dot(u, v) &lt;&lt; '\\n';\n    std::cout &lt;&lt; u_str &lt;&lt; \".dot(\" &lt;&lt; v_str &lt;&lt; \") = \" &lt;&lt; u.dot(v) &lt;&lt; '\\n';\n}\nOutput\nbit::dot(01111110, 10101010) = 1\n01111110.dot(10101010) = 1\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/access.html",
    "href": "content/vector/access.html",
    "title": "bit::vector — Element Access",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\n1constexpr bool      element(std::size_t i) const;\n2constexpr reference element(std::size_t i);\n\n3constexpr bool      operator[](std::size_t i) const;\nconstexpr reference operator[](std::size_t i);\n\n4constexpr bool      operator()(std::size_t i) const;\nconstexpr reference operator()(std::size_t i);\n\n5constexpr bool      test(std::size_t i) const;\n\n6constexpr bool      front() const;\nconstexpr reference front()\n\n7constexpr bool      back() const;\nconstexpr reference back()\n\n1\n\nAccesses the value for bit-vector element i.\n\n2\n\nReturns a vector::reference object — allows modification of the value at index i.\n\n3\n\nThe operator[] methods are synonyms for the element methods.\n\n4\n\nThe operator() methods are also synonyms for the element methods.\n\n5\n\nAnother way to access the value for element i.\n\n6\n\nAccess the element at index 0.\n\n7\n\nAccess the element at index size() - 1.\n\n\n\n\n\n\n\n\nBounds checking\n\n\n\nGenerally, these methods do not check whether the index i is in bounds. The behavior is undefined if it is out of bounds, but it will surely not be good! Set the BIT_DEBUG flag at compile time to check this condition — any violation will cause the program to abort with a helpful message.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    std::size_t n = 11;\n    bit::vector&lt;&gt; v(n);\n    std::cout &lt;&lt; \"Setting successive bits:\\n\";\n    std::cout &lt;&lt; v &lt;&lt; '\\n';\n    for (std::size_t i = 0; i &lt; n; ++i) {\n        v[i] = true;\n        std::cout &lt;&lt; v &lt;&lt; '\\n';\n    }\n    std::cout &lt;&lt; \"Resetting the front and back elements of v ...\\n\";\n    v.front() = 0;\n    v.back()  = 0;\n    std::cout &lt;&lt; v &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v.front(): \" &lt;&lt; v.front() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v.back():  \" &lt;&lt; v.back()  &lt;&lt; '\\n';\n}\nOutput\nSetting successive bits:\n[0 0 0 0 0 0 0 0 0 0 0]\n[1 0 0 0 0 0 0 0 0 0 0]\n[1 1 0 0 0 0 0 0 0 0 0]\n[1 1 1 0 0 0 0 0 0 0 0]\n[1 1 1 1 0 0 0 0 0 0 0]\n[1 1 1 1 1 0 0 0 0 0 0]\n[1 1 1 1 1 1 0 0 0 0 0]\n[1 1 1 1 1 1 1 0 0 0 0]\n[1 1 1 1 1 1 1 1 0 0 0]\n[1 1 1 1 1 1 1 1 1 0 0]\n[1 1 1 1 1 1 1 1 1 1 0]\n[1 1 1 1 1 1 1 1 1 1 1]\nResetting the front and back elements of v ...\n[0 1 1 1 1 1 1 1 1 1 0]\nv.front(): 0\nv.back():  0\n\nSee Also\nvector::reference\nvector::size\n[bit_assert]\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/join.html",
    "href": "content/vector/join.html",
    "title": "bit::vector — Join Bit-Vectors",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nJoins two or three arbitrary-sized bit-vectors to get one longer one.\ntemplate&lt;std::unsigned_integral Block, typename Alloc&gt;\nconstexpr bit::vector&lt;Block, Alloc&gt;\njoin(const bit::vector&lt;Block, Alloc&gt; &u,\n     const bit::vector&lt;Block, Alloc&gt; &v);\n\ntemplate&lt;std::unsigned_integral Block, typename Alloc&gt;\nconstexpr bit::vector&lt;Block, Alloc&gt;\njoin(const bit::vector&lt;Block, Alloc&gt; &u,\n     const bit::vector&lt;Block, Alloc&gt; &v,\n     const bit::vector&lt;Block, Alloc&gt; &w);\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto u = bit::vector&lt;&gt;::ones(8);\n    auto v = bit::vector&lt;&gt;::zeros(4);\n    std::cout &lt;&lt; u &lt;&lt; \" joined with \" &lt;&lt; v &lt;&lt; \" yields \" &lt;&lt; join(u, v) &lt;&lt; '\\n';\n    std::cout &lt;&lt; v &lt;&lt; \" joined with \" &lt;&lt; u &lt;&lt; \" yields \" &lt;&lt; join(v, u) &lt;&lt; '\\n';\n}\nOutput\n[1 1 1 1 1 1 1 1] joined with [0 0 0 0] yields [1 1 1 1 1 1 1 1 0 0 0 0]\n[0 0 0 0] joined with [1 1 1 1 1 1 1 1] yields [0 0 0 0 1 1 1 1 1 1 1 1]\n\nSee Also\nvector::append\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/to_string.html",
    "href": "content/vector/to_string.html",
    "title": "bit::vector — String Encodings",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\nWe have methods to encode a bit-vector in various string formats."
  },
  {
    "objectID": "content/vector/to_string.html#character-encodings",
    "href": "content/vector/to_string.html#character-encodings",
    "title": "bit::vector — String Encodings",
    "section": "Character Encodings",
    "text": "Character Encodings\n\nThere are two principal ways we can encode a bit-vector as a string:\n\nBinary String Encodings\nThe straightforward character encoding for a bit-vector is a binary string containing just 0’s and 1’s, e.g., “10101”. Each character in a binary string represents a single element in the bit-vector.\nBy default, we encode bit-vectors to binary strings in vector order \\(v_0 v_1  \\cdots v_{n-1}\\). However, methods that read or write binary strings typically have an extra boolean argument, bit_order. This argument always defaults to false, but if present and set to true, then the binary string will encode the bit-vector in bit-order where the least significant bit v0 is on the right so \\(v_{n-1} \\cdots v_1 v_0\\). Hex-strings ignore the bit_order parameter.\n\n\nHex String Encodings\nThe other supported encoding for bit-vectors is a compact hex type string containing just the 16 hex characters 0123456789ABCDEF. For example, the string “3ED02”. We allow for hex strings with an optional prefix “0x” or “0X,” e.g. “0x3ED02”.\nHex strings are not affected by a bit_order argument — we ignore that argument.\nEach hex character naturally translates to four elements in a bit::vector. The hex string 0x0 is equivalent to the binary string 0000, and so on, up to string 0xF which is the same as the binary 1111.\nThe hex pair 0x0F will be interpreted in the vector as 00001111. Of course, this is the advantage of hex. It is a more compact format that occupies a quarter of the space needed to write out the equivalent binary string.\nHowever, what happens if you want to encode a vector whose size is not a multiple of 4? We handle that by allowing the final character in the string to have a base that is not 16. To accomplish that, we allow for an optional suffix, which must be one of _2, _4, or _8. If present, the prefix gives the base for just the preceding character in the otherwise hex-based string. If there is no suffix, the final character is assumed to be hex like all the others.\nSo the string 0x1 (no suffix, so the last character is the default hex base 16) is equivalent to 0001. On the other hand, the string 0x1_8 (the last character is base 8) is equivalent to 001. Similarly, the string 0x1_4 (the last character is base 4) is equivalent to 01 and finally, the string 0x1_2 (the previous character is base 2) is comparable to 1\nIn the string 0x3ED01_8, the first four characters 3, E, D, and 0 are interpreted as hex values, and each will consume four slots in the vector. However, that final 1_8 is parsed as an octal 1, which takes up three slots 001. Therefore, this vector has size 19 (i.e., 4*4 + 3).\n\n\n\n\n\n\nCareful with that final suffix character\n\n\n\nIf the suffix is present, the final character must fit inside the base given by that suffix. The string 0x3_8 is OK, but trying to parse 0x3_2 will result in a std::nullopt return value because the final character is not either 0 or 1, which are the only valid options for something that is supposed to be base 2."
  },
  {
    "objectID": "content/vector/to_string.html#example-to-binary",
    "href": "content/vector/to_string.html#example-to-binary",
    "title": "bit::vector — String Encodings",
    "section": "Example: To Binary",
    "text": "Example: To Binary\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    bit::vector v(16, [](size_t k) { return (k + 1) % 2; });\n2    std::cout &lt;&lt; \"v:    \" &lt;&lt; v.to_string() &lt;&lt; '\\n';\n3    std::cout &lt;&lt; \"v:    \" &lt;&lt; v.to_bit_order() &lt;&lt; '\\n';\n4    std::cout &lt;&lt; \"v:    \" &lt;&lt; v.to_bit_order('.', '-') &lt;&lt; '\\n';\n5    std::cout &lt;&lt; \"v:    \" &lt;&lt; v.to_pretty_string() &lt;&lt; '\\n';\n6    std::cout &lt;&lt; \"v:    \" &lt;&lt; v.to_string(\"{\", \"}\", \", \") &lt;&lt; '\\n';\n}\n\n1\n\nv has all the even elements set to 1.\n\n2\n\nPrinting v in vector_order using the default 0’s and 1’s for the element values. v0 is on the left.\n\n3\n\nPrinting v in bit_order using the default 0’s and 1’s for the element values. v0 is on the right.\n\n4\n\nPrinting v in bit_order using dots and dashes for the element values. v0 is on the right.\n\n5\n\nPrinting v in a more formatted, element-by-element style.\n\n6\n\nPrinting v in a custom formatted style.\n\n\nOutput\nv:    1010101010101010\nv:    0101010101010101\nv:    .-.-.-.-.-.-.-.-\nv:    [1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0]\nv:    {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0}"
  },
  {
    "objectID": "content/vector/to_string.html#example-to-hex",
    "href": "content/vector/to_string.html#example-to-hex",
    "title": "bit::vector — String Encodings",
    "section": "Example: To Hex",
    "text": "Example: To Hex\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto v5 = bit::vector&lt;&gt;::ones(5);\n    auto v6 = bit::vector&lt;&gt;::ones(6);\n    auto v7 = bit::vector&lt;&gt;::ones(7);\n    auto v8 = bit::vector&lt;&gt;::ones(8);\n    auto v9 = bit::vector&lt;&gt;::ones(9);\n    std::cout &lt;&lt; \"v5: \" &lt;&lt; v5.to_string() &lt;&lt; \"\\t hex: \" &lt;&lt; v5.to_hex() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v6: \" &lt;&lt; v6.to_string() &lt;&lt; \"\\t hex: \" &lt;&lt; v6.to_hex() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v7: \" &lt;&lt; v7.to_string() &lt;&lt; \"\\t hex: \" &lt;&lt; v7.to_hex() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v8: \" &lt;&lt; v8.to_string() &lt;&lt; \"\\t hex: \" &lt;&lt; v8.to_hex() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v9: \" &lt;&lt; v9.to_string() &lt;&lt; \"\\t hex: \" &lt;&lt; v9.to_hex() &lt;&lt; '\\n';\n}\nOutput\nv5: 11111        hex: 0xF1_2\nv6: 111111       hex: 0xF3_4\nv7: 1111111      hex: 0xF7_8\nv8: 11111111     hex: 0xFF\nv9: 111111111    hex: 0xFF1_2"
  },
  {
    "objectID": "content/vector/to_string.html#example-from-hex",
    "href": "content/vector/to_string.html#example-from-hex",
    "title": "bit::vector — String Encodings",
    "section": "Example: From Hex",
    "text": "Example: From Hex\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    auto v5 = bit::vector&lt;&gt;::random(5);\n    auto v6 = bit::vector&lt;&gt;::random(6);\n    auto v7 = bit::vector&lt;&gt;::random(7);\n    auto v8 = bit::vector&lt;&gt;::random(8);\n    auto v9 = bit::vector&lt;&gt;::random(9);\n\n2    auto u5 = bit::vector&lt;&gt;::from(v5.to_hex());\n    auto u6 = bit::vector&lt;&gt;::from(v6.to_hex());\n    auto u7 = bit::vector&lt;&gt;::from(v7.to_hex());\n    auto u8 = bit::vector&lt;&gt;::from(v8.to_hex());\n    auto u9 = bit::vector&lt;&gt;::from(v9.to_hex());\n\n    std::cout &lt;&lt; \"v5 \" &lt;&lt; v5 &lt;&lt; \"\\t\\t u5 \" &lt;&lt; *u5 &lt;&lt; (v5 == *u5 ? \"\\t match \" : \"\\t FAIL\") &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v6 \" &lt;&lt; v6 &lt;&lt; \"\\t u6 \" &lt;&lt; *u6 &lt;&lt; (v6 == *u6 ? \"\\t match \" : \"\\t FAIL\") &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v7 \" &lt;&lt; v7 &lt;&lt; \"\\t u7 \" &lt;&lt; *u7 &lt;&lt; (v7 == *u7 ? \"\\t match \" : \"\\t FAIL\") &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v8 \" &lt;&lt; v8 &lt;&lt; \"\\t u8 \" &lt;&lt; *u8 &lt;&lt; (v8 == *u8 ? \"\\t match \" : \"\\t FAIL\") &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v9 \" &lt;&lt; v9 &lt;&lt; \"\\t u9 \" &lt;&lt; *u9 &lt;&lt; (v9 == *u9 ? \"\\t match \" : \"\\t FAIL\") &lt;&lt; '\\n';\n}\n\n1\n\nSet up some bit-vectors of various lengths with random 50-50 fills.\n\n2\n\nConvert the bit-vectors to hex-strings and use those to construct bit-vectors. Check that the two sets of vectors match.\n\n\nOutput (varies from run to run)\nv5 [0 0 1 1 0]           u5 [0 0 1 1 0]          match\nv6 [1 0 1 1 1 0]         u6 [1 0 1 1 1 0]        match\nv7 [0 1 1 0 0 1 1]       u7 [0 1 1 0 0 1 1]      match\nv8 [1 1 1 1 1 0 0 0]     u8 [1 1 1 1 1 0 0 0]    match\nv9 [0 0 0 0 0 0 0 0 1]   u9 [0 0 0 0 0 0 0 0 1]  match\n\nSee Also\nvector::stream&lt;&lt;\nvector::stream&gt;&gt;\nvector::formatter"
  },
  {
    "objectID": "content/vector/first_set.html",
    "href": "content/vector/first_set.html",
    "title": "bit::vector — Iteration Over Set Bits",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe provide methods to iterate over the set elements/bits in a bit-vector.\n1constexpr std::size_t first_set() const;\n2constexpr std::size_t final_set() const;\n3constexpr std::size_t next_set(std::size_t pos) const;\n4constexpr std::size_t prev_set(std::size_t pos) const;\n\n1\n\nReturns the index of the first set element or npos if none are set.\n\n2\n\nReturns the index of the final set element or npos if none are set.\n\n3\n\nReturns the index of the next set element after the argument or npos if there are no more set elements.\n\n4\n\nReturns the index of the previous set element before the argument or npos if there are no more set elements.\n\n\nIn these methods, pos is the index from which to start a search. It doesn’t have to be the index of a set element.\nA return value of bit::vector::npos indicates that the search failed.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    bit::vector&lt;&gt; v(11, [&](size_t k) { return (k + 1) % 2; });\n    std::cout &lt;&lt; \"The set indices in \" &lt;&lt; v &lt;&lt; \" are \";\n2    auto pos = v.first_set();\n3    while (pos != bit::vector&lt;&gt;::npos) {\n        std::cout &lt;&lt; pos &lt;&lt; ' ';\n4        pos = v.next_set(pos);\n    }\n    std::cout &lt;&lt; '\\n';\n}\n\n1\n\nCreates a vector of size 11 by calling a lambda that sets all the even indices.\n\n2\n\nFind the index of the first set element (should be 0).\n\n3\n\nKeep going until the search fails.\n\n4\n\nFind the index of a set bit after the current pos.\n\n\nOutput\nThe set indices in [1 0 1 0 1 0 1 0 1 0 1] are 0 2 4 6 8 10\n\nSee Also\nvector::if_set_call\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/formatter.html",
    "href": "content/vector/formatter.html",
    "title": "bit::vector — Custom Formatting",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\nWe specialize the std::formatter class to connect any bit::vector to std::format and friends.\nAs shown in the example below, if \\(\\mathbf{v}\\) is a bit-vector of size \\(n\\), this std::formatter supports the four different format specifiers:"
  },
  {
    "objectID": "content/vector/formatter.html#string-encodings",
    "href": "content/vector/formatter.html#string-encodings",
    "title": "bit::vector — Custom Formatting",
    "section": "String Encodings",
    "text": "String Encodings\n\nThere are two principal ways we can encode a bit-vector as a string:\n\nBinary String Encodings\nThe straightforward character encoding for a bit-vector is a binary string containing just 0’s and 1’s, e.g., “10101”. Each character in a binary string represents a single element in the bit-vector.\nBy default, we encode bit-vectors to binary strings in vector order \\(v_0 v_1  \\cdots v_{n-1}\\). However, methods that read or write binary strings typically have an extra boolean argument, bit_order. This argument always defaults to false, but if present and set to true, then the binary string will encode the bit-vector in bit-order where the least significant bit v0 is on the right so \\(v_{n-1} \\cdots v_1 v_0\\). Hex-strings ignore the bit_order parameter.\n\n\nHex String Encodings\nThe other supported encoding for bit-vectors is a compact hex type string containing just the 16 hex characters 0123456789ABCDEF. For example, the string “3ED02”. We allow for hex strings with an optional prefix “0x” or “0X,” e.g. “0x3ED02”.\nHex strings are not affected by a bit_order argument — we ignore that argument.\nEach hex character naturally translates to four elements in a bit::vector. The hex string 0x0 is equivalent to the binary string 0000, and so on, up to string 0xF which is the same as the binary 1111.\nThe hex pair 0x0F will be interpreted in the vector as 00001111. Of course, this is the advantage of hex. It is a more compact format that occupies a quarter of the space needed to write out the equivalent binary string.\nHowever, what happens if you want to encode a vector whose size is not a multiple of 4? We handle that by allowing the final character in the string to have a base that is not 16. To accomplish that, we allow for an optional suffix, which must be one of _2, _4, or _8. If present, the prefix gives the base for just the preceding character in the otherwise hex-based string. If there is no suffix, the final character is assumed to be hex like all the others.\nSo the string 0x1 (no suffix, so the last character is the default hex base 16) is equivalent to 0001. On the other hand, the string 0x1_8 (the last character is base 8) is equivalent to 001. Similarly, the string 0x1_4 (the last character is base 4) is equivalent to 01 and finally, the string 0x1_2 (the previous character is base 2) is comparable to 1\nIn the string 0x3ED01_8, the first four characters 3, E, D, and 0 are interpreted as hex values, and each will consume four slots in the vector. However, that final 1_8 is parsed as an octal 1, which takes up three slots 001. Therefore, this vector has size 19 (i.e., 4*4 + 3).\n\n\n\n\n\n\nCareful with that final suffix character\n\n\n\nIf the suffix is present, the final character must fit inside the base given by that suffix. The string 0x3_8 is OK, but trying to parse 0x3_2 will result in a std::nullopt return value because the final character is not either 0 or 1, which are the only valid options for something that is supposed to be base 2.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto v = bit::vector&lt;&gt;::random(18);\n    std::cout &lt;&lt; std::format(\"Vector default specifier:   {}\\n\", v);\n    std::cout &lt;&lt; std::format(\"Vector bit-order specifier: {:b}\\n\", v);\n    std::cout &lt;&lt; std::format(\"Vector pretty specifier:    {:p}\\n\", v);\n    std::cout &lt;&lt; std::format(\"Vector hex specifier:       {:x}\\n\", v);\n    std::cout &lt;&lt; std::format(\"Vector invalid specifier:   {:X}\\n\", v);\n}\nOutput\nVector default specifier:   011100000001100010\nVector bit-order specifier: 010001100000001110\nVector pretty specifier:    [0 1 1 1 0 0 0 0 0 0 0 1 1 0 0 0 1 0]\nVector hex specifier:       0xE0811_4\nVector invalid specifier:   'UNRECOGNIZED FORMAT SPECIFIER FOR BIT-VECTOR'\n\n\nSee Also\nvector::to_string\nvector::to_pretty_string\nvector::to_bit_order\nvector::to_hex"
  },
  {
    "objectID": "content/vector/from.html",
    "href": "content/vector/from.html",
    "title": "bit::vector — Factory Constructors",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]"
  },
  {
    "objectID": "content/vector/from.html#from-unsigned-integers",
    "href": "content/vector/from.html#from-unsigned-integers",
    "title": "bit::vector — Factory Constructors",
    "section": "From Unsigned Integers",
    "text": "From Unsigned Integers\nWe can always copy the bits of any unsigned integer value to create a valid bit-vector.\n1static constexpr bit::vector from(std::unsigned_integral auto src);\n\n1\n\nThis templated method returns a bit-vector constructed from the bits that make up the src word.\n\n\nThe size of the bit-vector will be the std::sizeof for the specific std::unsigned_integral used as the argument. Note that there is no requirement for the argument type and Block to be the same. The argument might be a 32-bit unsigned, creating a bit-vector of size 32 packed into the default 64-bit block.\n\n\n\n\n\n\nWhy not a constructor with this argument type?\n\n\n\nThis method isn’t a constructor because we don’t want src to be treated as the number of vector elements. Instead, we copy the actual bits from src into the bit-vector.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    uint16_t val = 65535;\n    auto v1 = bit::vector&lt;&gt;::from(val);\n    std::cout &lt;&lt; \"v1 = \" &lt;&lt; v1 &lt;&lt; \" has size \" &lt;&lt; v1.size() &lt;&lt; '\\n';\n}\nOutput\nv1 = [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1] has size 16"
  },
  {
    "objectID": "content/vector/from.html#from-strings",
    "href": "content/vector/from.html#from-strings",
    "title": "bit::vector — Factory Constructors",
    "section": "From Strings",
    "text": "From Strings\nWe provide a factory method that attempts to parse a string as a bit-vector.\nOf course, that isn’t always possible, so this method returns a std::optional\nstatic std::optional&lt;bit::vector&gt;\n1from(std::string_view src, bool bit_order = false);\n\n1\n\nAttempts to parse a bit-vector from a string and returns std::nullopt on failure.\n\n\n\nThere are two principal ways we can encode a bit-vector as a string:\n\nBinary String Encodings\nThe straightforward character encoding for a bit-vector is a binary string containing just 0’s and 1’s, e.g., “10101”. Each character in a binary string represents a single element in the bit-vector.\nBy default, we encode bit-vectors to binary strings in vector order \\(v_0 v_1  \\cdots v_{n-1}\\). However, methods that read or write binary strings typically have an extra boolean argument, bit_order. This argument always defaults to false, but if present and set to true, then the binary string will encode the bit-vector in bit-order where the least significant bit v0 is on the right so \\(v_{n-1} \\cdots v_1 v_0\\). Hex-strings ignore the bit_order parameter.\n\n\nHex String Encodings\nThe other supported encoding for bit-vectors is a compact hex type string containing just the 16 hex characters 0123456789ABCDEF. For example, the string “3ED02”. We allow for hex strings with an optional prefix “0x” or “0X,” e.g. “0x3ED02”.\nHex strings are not affected by a bit_order argument — we ignore that argument.\nEach hex character naturally translates to four elements in a bit::vector. The hex string 0x0 is equivalent to the binary string 0000, and so on, up to string 0xF which is the same as the binary 1111.\nThe hex pair 0x0F will be interpreted in the vector as 00001111. Of course, this is the advantage of hex. It is a more compact format that occupies a quarter of the space needed to write out the equivalent binary string.\nHowever, what happens if you want to encode a vector whose size is not a multiple of 4? We handle that by allowing the final character in the string to have a base that is not 16. To accomplish that, we allow for an optional suffix, which must be one of _2, _4, or _8. If present, the prefix gives the base for just the preceding character in the otherwise hex-based string. If there is no suffix, the final character is assumed to be hex like all the others.\nSo the string 0x1 (no suffix, so the last character is the default hex base 16) is equivalent to 0001. On the other hand, the string 0x1_8 (the last character is base 8) is equivalent to 001. Similarly, the string 0x1_4 (the last character is base 4) is equivalent to 01 and finally, the string 0x1_2 (the previous character is base 2) is comparable to 1\nIn the string 0x3ED01_8, the first four characters 3, E, D, and 0 are interpreted as hex values, and each will consume four slots in the vector. However, that final 1_8 is parsed as an octal 1, which takes up three slots 001. Therefore, this vector has size 19 (i.e., 4*4 + 3).\n\n\n\n\n\n\nCareful with that final suffix character\n\n\n\nIf the suffix is present, the final character must fit inside the base given by that suffix. The string 0x3_8 is OK, but trying to parse 0x3_2 will result in a std::nullopt return value because the final character is not either 0 or 1, which are the only valid options for something that is supposed to be base 2.\n\n\n\nBinary String Example:\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    auto v1 = bit::vector&lt;&gt;::from(\"11100\");\n2    auto v2 = bit::vector&lt;&gt;::from(\"11100\", true);\n3    auto v3 = bit::vector&lt;&gt;::from(\"1  1  1\");\n\n    std::cout &lt;&lt; \"v1 = \" &lt;&lt; (v2 ? v2-&gt;to_string() : \"FAILED TO PARSE\") &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v2 = \" &lt;&lt; (v3 ? v3-&gt;to_string() : \"FAILED TO PARSE\") &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v3 = \" &lt;&lt; (v4 ? v4-&gt;to_string() : \"FAILED TO PARSE\") &lt;&lt; '\\n';\n}\n\n1\n\nThe string without a prefix is all zeros and ones, so we assume it’s a binary encoding.\n\n2\n\nThis is the same thing, but now we interpret the bits as having the least significant bit v0 is on the right.\n\n3\n\nThis is a string with a deliberate error.\n\n\nOutput\nv1 = 11100\n1v2 = 00111\n2v3 = FAILED TO PARSE\n\n1\n\nThe characters are interpreted as encoding the least significant bit v0 is on the right.\n\n2\n\nThe last string cannot be interpreted as a valid bit-vector.\n\n\n\n\nHex String Example\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    auto v1 = bit::vector&lt;&gt;::from(\"111\");\n2    auto v2 = bit::vector&lt;&gt;::from(\"0x111\");\n3    auto v3 = bit::vector&lt;&gt;::from(\"0xF1\");\n4    auto v4 = bit::vector&lt;&gt;::from(\"0xF1_8\");\n5    auto v5 = bit::vector&lt;&gt;::from(\"0xF1_4\");\n6    auto v6 = bit::vector&lt;&gt;::from(\"0xF1_2\");\n\n    if(v1) std::cout &lt;&lt; \"v1 = \" &lt;&lt; *v1 &lt;&lt; '\\n';\n    if(v2) std::cout &lt;&lt; \"v2 = \" &lt;&lt; *v2 &lt;&lt; '\\n';\n    if(v3) std::cout &lt;&lt; \"v3 = \" &lt;&lt; *v3 &lt;&lt; '\\n';\n    if(v4) std::cout &lt;&lt; \"v4 = \" &lt;&lt; *v4 &lt;&lt; '\\n';\n    if(v5) std::cout &lt;&lt; \"v5 = \" &lt;&lt; *v5 &lt;&lt; '\\n';\n    if(v6) std::cout &lt;&lt; \"v6 = \" &lt;&lt; *v6 &lt;&lt; '\\n';\n}\n\n1\n\nThis string without a prefix is all zeros and ones, so we assume it’s a binary encoding.\n\n2\n\nThis string has the same digits, but thanks to the ‘0x’ prefix, it will be interpreted as a hex string.\n\n3\n\nConstruction where the final character has no suffix, so by default, it is parsed as a hex/base-16 number.\n\n4\n\nConstruction where the final character has a suffix _8 so is parsed as a base-8 number.\n\n5\n\nConstruction where the final character has a suffix _4 so is parsed as a base-4 number.\n\n6\n\nConstruction where the final character has a suffix _2 so is parsed as a base-2 number.\n\n\nOutput\n1v1 = [1 1 1]\n2v2 = [1 0 0 0 1 0 0 0 1 0 0 0]\n3v3 = [1 1 1 1 1 0 0 0]\n4v4 = [1 1 1 1 1 0 0]\n5v5 = [1 1 1 1 1 0]\n6v6 = [1 1 1 1 1]\n\n1\n\nBinary string so each character is a single element in the bit-vector.\n\n2\n\nSame digits, but now it is hex, so each character is four elements in the bit-vector.\n\n3\n\nThe final 1 is interpreted as 1 base 16.\n\n4\n\nThe final 1_8 is interpreted as 1 base 8.\n\n5\n\nThe final 1_4 is interpreted as 1 base 4.\n\n6\n\nThe final 1_2 is interpreted as 1 base 2.\n\n\n\n\n\nSee Also\nvector::constructors\nvector::to_string"
  },
  {
    "objectID": "content/vector/all.html",
    "href": "content/vector/all.html",
    "title": "bit::vector — State Queries",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\n1constexpr bool all() const;\n2constexpr bool any() const;\n3constexpr bool none() const;\n\n1\n\nReturns true if all the elements in the bit-vector are 1; otherwise, returns false.\n\n2\n\nReturns true if any elements in the bit-vector are 1; otherwise, returns false.\n\n3\n\nReturns true if none of the elements in the bit-vector are 1; otherwise, returns false.\n\n\n\n\n\n\n\n\nEmpty bit-vectors\n\n\n\nCalling these methods for an empty bit-vector is likely an error — if you set the BIT_DEBUG flag at compile time, we throw an exception with a helpful message. If the BIT_DEBUG flag is not set, all() and none() both return true while any() will return false.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto v1 = bit::vector&lt;&gt;::zeros(4);\n    auto v2 = bit::vector&lt;&gt;::checker_board(4);\n    auto v3 = bit::vector&lt;&gt;::ones(4);\n\n    std::cout\n        &lt;&lt; \"vector\\t\\t\" &lt;&lt; \"all\\t\" &lt;&lt; \"any\\t\" &lt;&lt; \"none\\n\"\n        &lt;&lt; v1 &lt;&lt; '\\t' &lt;&lt; v1.all() &lt;&lt; '\\t' &lt;&lt; v1.any() &lt;&lt; '\\t' &lt;&lt; v1.none() &lt;&lt; '\\n'\n        &lt;&lt; v2 &lt;&lt; '\\t' &lt;&lt; v2.all() &lt;&lt; '\\t' &lt;&lt; v2.any() &lt;&lt; '\\t' &lt;&lt; v2.none() &lt;&lt; '\\n'\n        &lt;&lt; v3 &lt;&lt; '\\t' &lt;&lt; v3.all() &lt;&lt; '\\t' &lt;&lt; v3.any() &lt;&lt; '\\t' &lt;&lt; v3.none() &lt;&lt; '\\n';\n}\nOutput\nvector          all     any     none\n[0 0 0 0]       0       0       1\n[0 1 0 1]       0       1       0\n[1 1 1 1]       1       1       0\n\nSee Also\nvector::count\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/clear.html",
    "href": "content/vector/clear.html",
    "title": "bit::vector — Clear",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nClears out the contents of a bit-vector:\nconstexpr bit::vector &clear();\nThe bit-vector’s size() becomes 0, but its capacity is not changed. This method returns a reference to *this so it can be chained with other calls.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto v = bit::vector&lt;&gt;::ones(8);\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; '\\n';\n    v.clear();\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; '\\n';\n}\nOutput\nv: [1 1 1 1 1 1 1 1]\nv: []\n\nSee Also\nvector::pop\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/unit_floor.html",
    "href": "content/vector/unit_floor.html",
    "title": "bit::vector — Special Unit Bit-Vectors",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nInstance methods that return some special unit bit-vectors:\n1constexpr bit::vector unit_floor(bool trimmed = true) const;\n2constexpr bit::vector unit_ceil(bool trimmed = true) const;\n\n1\n\nReturn a unit bit-vector with a single 1 at the location of our final set bit.\n\n2\n\nReturn a unit bit-vector with a single 1 at one slot past the location of our final set bit.\n\n\nIf the trimmed argument is true, the returned bit-vector will be as small as possible. Otherwise, in the first method, the returned bit-vector will be identical to our size; in the second method, it will be one larger than that.\nIn the first method, we will return an empty vector if there are no set bits.\nThese methods are analogous to the standard library functions std::bit_ceil and std::bit_floor that work on unsigned integers.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    std::size_t   n = 4;\n    bit::vector&lt;&gt; v(n);\n\n    std::cout &lt;&lt; \"Smallest possible unit floor bit-vectors:\\n\";\n    v.reset();\n    for (std::size_t i = 0; i &lt; n+1; v.set(i), ++i)\n        std::cout &lt;&lt; v &lt;&lt; \".unit_floor():      \" &lt;&lt; v.unit_floor() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"\\n\";\n\n    std::cout &lt;&lt; \"Fixed size unit floor bit-vectors:\\n\";\n    v.reset();\n    for (std::size_t i = 0; i &lt; n+1; v.set(i), ++i)\n        std::cout &lt;&lt; v &lt;&lt; \".unit_floor(false): \" &lt;&lt; v.unit_floor(false) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"\\n\";\n\n    std::cout &lt;&lt; \"Smallest possible unit ceiling bit-vectors:\\n\";\n    v.reset();\n    for (std::size_t i = 0; i &lt; n+1; v.set(i), ++i)\n        std::cout &lt;&lt; v &lt;&lt; \".unit_ceil():       \" &lt;&lt; v.unit_ceil() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"\\n\";\n\n    std::cout &lt;&lt; \"Fixed size unit ceiling bit-vectors:\\n\";\n    v.reset();\n    for (std::size_t i = 0; i &lt; n+1; v.set(i), ++i)\n        std::cout &lt;&lt; v &lt;&lt; \".unit_ceil(false):  \" &lt;&lt; v.unit_ceil(false) &lt;&lt; \"\\n\";\n}\nOutput\nSmallest possible unit floor bit-vectors:\n[0 0 0 0].unit_floor():      []\n[1 0 0 0].unit_floor():      [1]\n[1 1 0 0].unit_floor():      [0 1]\n[1 1 1 0].unit_floor():      [0 0 1]\n[1 1 1 1].unit_floor():      [0 0 0 1]\n\nFixed size unit floor bit-vectors:\n[0 0 0 0].unit_floor(false): []\n[1 0 0 0].unit_floor(false): [1 0 0 0]\n[1 1 0 0].unit_floor(false): [0 1 0 0]\n[1 1 1 0].unit_floor(false): [0 0 1 0]\n[1 1 1 1].unit_floor(false): [0 0 0 1]\n\nSmallest possible unit ceiling bit-vectors:\n[0 0 0 0].unit_ceil():       [1]\n[1 0 0 0].unit_ceil():       [0 1]\n[1 1 0 0].unit_ceil():       [0 0 1]\n[1 1 1 0].unit_ceil():       [0 0 0 1]\n[1 1 1 1].unit_ceil():       [0 0 0 0 1]\n\nFixed size unit ceiling bit-vectors:\n[0 0 0 0].unit_ceil(false):  [1 0 0 0 0]\n[1 0 0 0].unit_ceil(false):  [0 1 0 0 0]\n[1 1 0 0].unit_ceil(false):  [0 0 1 0 0]\n[1 1 1 0].unit_ceil(false):  [0 0 0 1 0]\n[1 1 1 1].unit_ceil(false):  [0 0 0 0 1]\n\nSee Also\nvector::first_set\nvector::final_set\nstd::bit_floor\nstd::bit_ceil\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/lu/permute.html",
    "href": "content/lu/permute.html",
    "title": "bit::lu — Row Permutations",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nIf lu was constructed from the bit-matrix \\(A\\) so that \\[\nP \\cdot A = L \\cdot U.\n\\] We provide access to the permutation matrix \\(P\\) in two different compact forms and the action of \\(P\\) on bit-matrices and bit-vectors.\n1std::vector&lt;std::size_t&gt; row_swaps() const;\n2std::vector&lt;std::size_t&gt; permutation_vector() const;\n\n3constexpr void permute(bit::vector &b) const;\n4constexpr void permute(bit::matrix &B) const;\n\n1\n\nReturns \\(P\\) in row-swaps instruction form (see below).\n\n2\n\nReturns \\(P\\) as a vector of permuted indices.\n\n3\n\nApplies the permutation \\(P\\) to the elements of an input bit-vector in-place.\n\n4\n\nApplies the permutation \\(P\\) to the rows of an input bit-matrix in-place.\n\n\nA permutation matrix \\(P\\) is just some row permutation of the identity matrix, so it has a single non-zero, 1, entry in each row or column. You don’t need to store the entire \\(N \\times N\\) matrix but instead store the locations of those 1’s.\nIn the literature, the permutation matrix is often given as a permutation of the index vector $[0,1,2,3,$]. For example, the permutation vector $[0, 2, 1, 4, 3$] tells you that elements/rows 1 and 2 are swapped, as are elements/rows 3 and 4. This form is easy to interpret at a glance. However, it is pretty tedious to use as a guide to executing the permutations in-place!\nThe venerableLAPACK software instead uses an equally compact scheme to store \\(P\\) that looks a little odd at first but is much easier to use if you want to permute rows/elements of matrices/vectors in-place.\nThis row-swaps scheme gives swapping instructions to be applied one after the other. Our example in this format becomes $[0, 2, 2, 4, 4$]. This vector can be interpreted as no swap on row 0, followed by a swap of rows 1 and 2, then no further swap on row 2, followed by a swap of rows 3 and 4, and finally, no further swap on row 4.\n\n\n\n\n\n\nThis is for information only\n\n\n\nInternally, we store and use \\(P\\) in the row-swaps instruction form. The index permutation form is provided only for informational purposes.\n\n\n\nSee Also\nlu::operator()\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/lu/index.html",
    "href": "content/lu/index.html",
    "title": "The bit::lu Class",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]",
    "crumbs": [
      "Home",
      "LU Decomposition",
      "Introduction"
    ]
  },
  {
    "objectID": "content/lu/index.html#introduction",
    "href": "content/lu/index.html#introduction",
    "title": "The bit::lu Class",
    "section": "Introduction",
    "text": "Introduction\nA bit::lu object computes the LU Decomposition for a square \\(n \\times n\\) bit-matrix \\(A\\). Formally, we write: \\[\nP \\cdot A = L \\cdot U,\n\\] where \\(P\\) is the permutation matrix, \\(U\\) is an upper-triangular bit-matrix, and \\(L\\) is a unit-lower-triangular bit-matrix.\nIn practice, \\(L\\) and \\(U\\) are packed compactly into an \\(n \\times n\\) bit-matrix, and the permutation “matrix” is stored as a vector.",
    "crumbs": [
      "Home",
      "LU Decomposition",
      "Introduction"
    ]
  },
  {
    "objectID": "content/lu/index.html#declaration",
    "href": "content/lu/index.html#declaration",
    "title": "The bit::lu Class",
    "section": "Declaration",
    "text": "Declaration\nLike everything in the library, this class is in the bit namespace.\nWe define it in the header &lt;bit/lu.h&gt; as follows:\nnamespace bit {\n    template&lt;\n        std::unsigned_integral Block = uint64_t,\n        Allocator = std::allocator&lt;Block&gt;\n    &gt; class lu;\n}\nSee the documentation for bit::vector and bit::matrix for more information on the two template parameters.",
    "crumbs": [
      "Home",
      "LU Decomposition",
      "Introduction"
    ]
  },
  {
    "objectID": "content/lu/index.html#class-types",
    "href": "content/lu/index.html#class-types",
    "title": "The bit::lu Class",
    "section": "Class Types",
    "text": "Class Types\n\n\n\n\n\n\n\n\nItem\nDescription\n\n\n\n\nvector_type\nAn alias for bit::vector\n\n\nmatrix_type\nAn alias for bit::matrix",
    "crumbs": [
      "Home",
      "LU Decomposition",
      "Introduction"
    ]
  },
  {
    "objectID": "content/lu/index.html#instance-methods",
    "href": "content/lu/index.html#instance-methods",
    "title": "The bit::lu Class",
    "section": "Instance Methods",
    "text": "Instance Methods\n\nConstruction\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nlu::constructors\nCreate a lu object for a bit-matrix \\(A\\).\n\n\n\n\n\n\nQueries\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nlu::singular\nIs the underlying bit-matrix singular?\n\n\nlu::non_singular\nIs the underlying bit-matrix non-singular?\n\n\nlu::determinant\nWhat is the determinant of the underlying bit-matrix?\n\n\nlu::rank\nWhat is the rank of the underlying bit-matrix?\n\n\n\n\n\n\nThe Decomposition\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nlu::L\nReturns \\(L\\) where \\(P \\cdot A = L \\cdot U\\).\n\n\nlu::U\nReturns \\(L\\) where \\(P \\cdot A = L \\cdot U\\).\n\n\nlu::LU\nReturns \\(L\\) & \\(U\\) packed into a compact form.\n\n\nlu::permutation_vector\nReturns a vector that is a compact representation of the permutation matrix \\(P\\).\n\n\nlu::row_swaps\nReturns an alternative, more generally applicable, representation of that permutation vector.\n\n\nlu::permute\nApply the row permutations from the LU Decomposition to another bit-vector or bit-matrix\n\n\nlu::operator()\nUse the decomposition to quickly solve a system \\(A \\cdot x = b\\) or multiple systems \\(A \\cdot x = B\\) for each column of \\(B\\).\n\n\nlu::invert\nUse the decomposition to invert the matrix \\(A\\)",
    "crumbs": [
      "Home",
      "LU Decomposition",
      "Introduction"
    ]
  },
  {
    "objectID": "content/lu/access.html",
    "href": "content/lu/access.html",
    "title": "bit::lu — Access",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nIf lu was constructed from the bit-matrix \\(A\\), these methods provide read-only access to the unit lower triangular bit-matrix \\(L\\) and the upper triangular bit-matrix \\(U\\) where \\[\nP \\cdot A = L \\cdot U\n\\] and \\(P\\) is a permutation matrix — see lu::permutation_vector.\n1bit::matrix L()  const;\n2bit::matrix U()  const;\n3bit::matrix LU() const;\n\n1\n\nReturns a copy of \\(L\\) as a stand-alone unit lower triangular bit-matrix.\n\n2\n\nReturns a copy of \\(U\\) as a stand-alone upper triangular bit-matrix.\n\n3\n\nReturns the bit-matrices \\(L\\) and \\(U\\) packed into a single bit-matrix.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    std::size_t m = 12;\n\n    auto A = bit::matrix&lt;&gt;::random(m);\n    auto lu = bit::lu(A);\n    auto L = lu.L();\n    auto U = lu.U();\n    std::cout &lt;&lt; \"bit::matrix A, L, and U:\\n\";\n    bit::print(A, L, U);\n    std::cout &lt;&lt; \"A is singular? \" &lt;&lt; (lu.singular() ? \"YES\" : \"NO\") &lt;&lt; \"\\n\";\n\n    // Check that P.A = L.U\n    auto PA = A;\n    lu.permute(PA);\n    auto LU = bit::dot(L,U);\n    std::cout &lt;&lt; \"P.A and L.U:\\n\";\n    bit::print(PA, LU);\n    std::cout &lt;&lt; \"P.A == L.U? \" &lt;&lt; (PA == LU ? \"YES\" : \"NO\") &lt;&lt; \"\\n\";\n}\nOutput (depends on the values of the random inputs)\nbit::matrix A, L, and U:\n001111101100    100000000000    111001010000\n111001010000    110000000000    011001100000\n111000011010    001000000000    001111101100\n000111100101    000100000000    000111100101\n100000110000    101010000000    000010111010\n110110101110    100001000000    000001001010\n110100000110    101000100000    000000010010\n011100110101    011100010000    000000010100\n101101101111    111010001000    000000001001\n010101110011    011011001100    000000000110\n010001111101    010110001010    000000000011\n001001000011    001101000001    000000000000\nA is singular? YES\nP.A and L.U:\n111001010000    111001010000\n100000110000    100000110000\n001111101100    001111101100\n000111100101    000111100101\n110100000110    110100000110\n111000011010    111000011010\n110110101110    110110101110\n010001111101    010001111101\n101101101111    101101101111\n010101110011    010101110011\n011100110101    011100110101\n001001000011    001001000011\nP.A == L.U? YES\n\nSee Also\nlu::constructors\nlu::permutation_vector\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/notes/reduction.html",
    "href": "content/notes/reduction.html",
    "title": "Modular Reduction of \\(x^N\\) in GF(2)",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\bold}[1]{\\mathbf{#1}}\n\\renewcommand{\\mod}{\\mid}\n\\]",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Polynomial Reduction"
    ]
  },
  {
    "objectID": "content/notes/reduction.html#introduction",
    "href": "content/notes/reduction.html#introduction",
    "title": "Modular Reduction of \\(x^N\\) in GF(2)",
    "section": "Introduction",
    "text": "Introduction\nLet \\(P(x)\\) be a nonzero polynomial of degree \\(n\\) over \\(\\FF\\).\nAny polynomial \\(h(x)\\) over \\(\\FF\\) can be decomposed as: \\[\n    h(x) = q(x) P(x) + r(x),\n\\] \\(q(x)\\) is the quotient polynomial for \\(h(x)\\), and the remainder polynomial \\(r(x)\\) has degree less than \\(n\\).\nWe say that \\(r(x)\\) is the modular reduction of \\(h(x)\\) by \\(P(x)\\) \\[\n    r(x) = h(x)\\bmod{P(x)}.\n\\] As a shorthand, we will also use “\\(\\mod\\)” to represent the modulo operation and write: \\[\n    r(x) = h(x) \\mod P(x) \\equiv h(x)\\bmod{P(x)}.\n\\]",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Polynomial Reduction"
    ]
  },
  {
    "objectID": "content/notes/reduction.html#power-polynomials-xn",
    "href": "content/notes/reduction.html#power-polynomials-xn",
    "title": "Modular Reduction of \\(x^N\\) in GF(2)",
    "section": "Power Polynomials \\(x^N\\)",
    "text": "Power Polynomials \\(x^N\\)\nThe simplest, single-term, polynomials \\(h(x) = x^N\\) are of particular importance especially for cases where \\(N \\gg 1\\).\nThis is because some numerical algorithms have a critical iteration step that can formally be written as: \\[\n    \\bold{v} \\gets M \\cdot \\bold{v},\n\\] where \\(\\bold{v}\\) is a bit-vector bucket of \\(n\\) bits and \\(M\\) is an \\(n \\times n\\) bit-matrix.\nFor example, many well-known random number generators can be cast into this form where a state vector \\(\\bold{v}\\) is advanced at each step before it is reduced to the next random number. We note in passing that the generator is unlikely to be coded as matrix-vector multiply in GF(2) — \\(M\\) is typically rather sparse and special so the iteration can be carried much more efficiently by other means. Nevertheless, the mathematical analysis of the generator will depend on the structure of \\(M\\).\nNow suppose you want to jump very far ahead in a random number stream. This lets one start a parallel thread of computation using the same set of random numbers but so far ahead that there is no danger of overlaps. To jump \\(N\\) steps ahead where \\(N \\gg 1\\) we need to compute \\[\n    M^N \\cdot \\bold{v}.\n\\] Even if \\(M\\) is sparse and special there usually is no easy way to compute \\(M^N\\).\nBut suppose that \\(P(x)\\) is the known degree \\(n\\) characteristic polynomial for \\(M\\) then the Cayley Hamilton theorem tells us that: \\[\n    P(M) = 0.\n\\] We can use that as follows — first, express \\(x^N\\) as \\[\n    x^N = q(x)P(x) + r(x),\n\\] then using Cayley Hamilton we get \\[\n    M^N = q(M)P(M) + r(M) = r(M).\n\\] So we can replace \\(M^N\\) by \\(r(M)\\) where the degree of \\(r\\) is less than \\(n\\) and typically \\(N \\gg n\\).\nThus, once we know \\(r(x) = x^N \\mod P(x)\\), we can jump \\(N\\) steps ahead in the algorithm by computing the inexpensive polynomial sum \\(r(M)\\).\nFor more details see this paper.",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Polynomial Reduction"
    ]
  },
  {
    "objectID": "content/notes/reduction.html#an-iterative-technique-for-xn-mod-px",
    "href": "content/notes/reduction.html#an-iterative-technique-for-xn-mod-px",
    "title": "Modular Reduction of \\(x^N\\) in GF(2)",
    "section": "An Iterative Technique for \\(x^N \\mod P(x)\\)",
    "text": "An Iterative Technique for \\(x^N \\mod P(x)\\)\n\\(P(x)\\) has degree \\(n\\) so there is a polynomial \\(p(x)\\) of degree less than \\(n\\) such that \\[\n    P(x) = p(x) + x^n = p_0 + p_1 x + \\cdots + p_{n-1} x^{n-1} + x^n.\n\\] \\(p(x)\\) can be represented as the vector of its coefficients: \\[\n    p(x) \\sim \\bold{p} = \\lbrack p_0 p_1 \\ldots p_{n-1} \\rbrack .\n\\]\nThere are three cases to consider as we compute \\(x^N \\mod P(x)\\).\n\nCase \\(N &lt; n\\):\nIf \\(N &lt; n\\) then \\(P(x)\\) does not divide \\(x^N\\) so \\[\n    x^N \\mod P(x) = x^N.\n\\] Defining \\(\\bold{u}_N\\) as the unit bit-vector of size \\(n\\), which is all zeros except for a one in the \\(N^{\\mathrm{th}}\\) slot, we can write: \\[\n    x^N \\mod P(x) \\sim \\bold{u}_N \\text{ if } N &lt; n.\n\\]\n\n\nCase \\(N = n\\):\nIn this case \\(P(x) = p(x) + x^N\\) so \\(x^N = P(x) - p(x)\\).\nTherefore \\[\n    x^N \\mod P(x) = -p(x).\n\\] In \\(\\FF\\) we can ignore that minus sign and write \\[\n    x^N \\mod P(x) \\sim \\bold{p}  \\text{ if } N = n.\n\\]\n\n\nCase \\(N &gt; n\\):\nIt remains to determine \\(x^N \\mod P(x)\\) for \\(N &gt; n\\).\nNow any polynomial \\(h(x)\\) over \\(\\FF\\) can be written as some multiple of \\(P(x)\\) plus a remainder term: \\[\n    h(x) = q(x) P(x) + r(x)\n\\] where the quotient \\(q(x)\\) and remainder \\(r(x)\\) are polynomials over \\(\\FF\\) and the degree of \\(r(x)\\) is strictly less than \\(n\\). \\[\n    r(x) \\equiv h(x) \\mod P(x)\n\\]\nSuppose we already know the explicit form for \\(r(x) = h(x) \\mod P(x)\\) \\[\n    r(x) = r_0 + r_1 x + \\cdots + r_{n-2} x^{n-2} + r_{n-1} x^{n-1}.\n\\] That is, we know the elements in the bit-vector of coefficients for \\(r(x)\\) \\[\n    r(x) \\sim \\bold{r} = \\lbrack r_0 r_1 \\ldots r_{n-1} \\rbrack.\n\\]\nNow \\[\n    x\\,h(x) = x\\,q(x) P(x) + x\\,r(x) \\implies x\\,h(x) \\mod P(x) = x\\,r(x) \\mod P(x).\n\\] Thus \\[\n    x\\,h(x) \\mod P(x) = \\left(r_0 x + r_1 x^2 + \\cdots + r_{n-2} x^{n-1}\\right) \\mod P(x) + r_{n-1} x^n \\mod P(x).\n\\] Using our two known cases for \\(N &lt; n\\) and \\(N = n\\) we get \\[\n    x\\,h(x) \\mod P(x) \\sim \\lbrack 0 r_0 \\ldots r_{n-2} \\rbrack + r_{n-1} \\bold{p}.\n\\] Thus if we know that \\(h(x) \\mod P(x) \\sim \\bold{r}\\) then \\[\n    x\\,h(x) \\mod P(x) \\sim (\\bold{r} \\gg 1 ) \\; \\wedge \\; r_{n-1} \\bold{p}.\n\\] Here \\(\\bold{r} \\gg 1\\) means we shift \\(\\bold{r}\\) one place to the right and introduce a zero on the left.\n\n\nSummary\nUsing the notation \\[\n    x^N \\mod P(x) = r^N(x) \\sim \\bold{r}^N,\n\\] where \\(\\bold{r}^N\\) is a bit-vector of size \\(n\\): \\[\n    \\bold{r}^N = \\lbrack r^N_0 r^N_1 \\ldots r^N_{n-1} \\rbrack,\n\\] we can compute \\(\\bold{r}^N\\) directly for small values of \\(N\\) and iteratively for larger values of \\(N\\): \\[\n    \\bold{r}^N =\n    \\begin{cases}\n        \\bold{u}_N    & \\text{ for } N &lt; n \\\\\n        \\bold{p}      & \\text{ for } N = n \\\\\n        \\left(\\bold{r}^{N-1} \\gg 1 \\right) \\; \\wedge \\; r_{n-1}^{N-1} \\, \\bold{p}   & \\text{ for } N &gt; n\n    \\end{cases}\n\\]",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Polynomial Reduction"
    ]
  },
  {
    "objectID": "content/notes/reduction.html#a-multiply-square-technique-for-xn-mod-px",
    "href": "content/notes/reduction.html#a-multiply-square-technique-for-xn-mod-px",
    "title": "Modular Reduction of \\(x^N\\) in GF(2)",
    "section": "A Multiply & Square Technique for \\(x^N \\mod P(x)\\)",
    "text": "A Multiply & Square Technique for \\(x^N \\mod P(x)\\)\nFor cases of practical interest where \\(N \\gg 1\\), the iterative scheme outlined above is much too slow.\nWe can speed it up considerably by using a “multiply & square” approach — there are variations on the theme but observe that we can always write: \\[\n    x^N =\n    \\begin{cases}\n        x \\, \\left( x^{\\frac{N-1}{2}} \\right)^2 & N \\text{ odd,} \\\\\n        \\left( x^{\\frac{N}{2}} \\right)^2        & N \\text{ even.}\n    \\end{cases}\n\\] Of course, in our case, we want to compute \\(x^N \\mod P(x)\\) as opposed to just computing the value of \\(x^N\\) but we can still borrow one of the fast exponentiation techniques described here or more comprehensively in Knuth’s The Art of Computer Programming, Vol 2.\nTo see that, we first note that if \\(f\\) and \\(g\\) are polynomials over \\(\\FF\\) where \\[\n\\begin{align}\n    f(x) \\mod P(x) &= r_f(x), \\\\\n    g(x) \\mod P(x) &= r_g(x)\n\\end{align}\n\\] then it is easily verified that \\[\n    f(x) g(x) \\mod P(x) = r_f(x) r_g(x) \\mod P(x).\n\\] So while the product polynomial \\(f(x) g(x)\\) may have a very high degree, we can always just work with the much simpler product \\(r_f(x) r_g(x)\\) whose degree is at most \\(2n -2\\).\nIn our case, suppose we already know \\(r(x) = x^k \\mod P(x)\\) for some power \\(k\\) i.e. we know the coefficients \\(\\bold{r}\\) of the polynomial \\(r(x)\\): \\[\n    r(x) \\sim \\bold{r} = [r_0 r_1 \\ldots r_{n-1}].\n\\] To get to \\(x^N \\mod P(x)\\) from there, the multiply and square algorithm requires two procedures:\n\n\n\n\n\n\n\n\nStep\nProcedure\n\n\n\n\nMultiplyStep\n\\(\\bold{r} \\gets x r(x) \\mod P(x)\\)\n\n\nSquareStep\n\\(\\bold{r} \\gets r(x)^2 \\mod P(x)\\)\n\n\n\n\nWith those in place we can proceed as follows (this is just a sketch):\n\n\n\\begin{algorithm} \\caption{Modular Reduction of $x^N$} \\begin{algorithmic} \\Require $\\mathbf{p}$, a bit-vector of size $n$, where $P(x) = x^n + p(x)$ and $\\mathbf{p} \\sim p(x)$. Unchanged on output. \\Require $\\mathbf{r}$, a destination bit-vector of size $n$. On output $\\mathbf{r} \\sim r(x) = x^N \\mid P(x)$. \\Procedure{reduce}{$N$, $\\mathbf{p}$} \\State $\\mathbf{r} \\gets \\mathbf{0}$ \\State $r_1 = 1$ \\While{$N &gt; 0$} \\If{$N \\text{ mod } 2 = 1$} \\State \\Call{MultiplyStep}{$\\mathbf{r}$} \\EndIf \\State \\Call{SquareStep}{$\\mathbf{r}$} \\State $N \\gets N \\gg 1$ \\EndWhile \\EndProcedure \\end{algorithmic} \\end{algorithm}\n\n\nOf course, the actual code handles the decomposition of \\(P(x)\\) into the \\(x^n + p(x)\\) and manages edge cases such as \\(P(x) = 1\\). It also handles the trivial cases where \\(N \\le n\\), and for larger values of \\(N\\) uses its binary representation in the main loop. Nevertheless, the sketch shows the importance of the two sub-procedures, MultiplyStep and SquareStep which we discuss next.\n\nThe Multiply Step\nIf \\(q(x)\\) is a polynomial of degree less than \\(n\\) so that \\[\n    q(x) \\mod P(x) = q(x),\n\\] then the following procedure performs the step \\[\n    q(x) \\gets x q(x) \\mod P(x),\n\\] where \\(q(x)\\) is represented by the bit-vector of its \\(n\\) coefficients \\(\\bold{q} = [q_0, q_1, \\ldots, q_{n-1}]\\).\n\n\n\\begin{algorithm} \\caption{The step: $q(x) \\gets x q(x) \\mid P(x)$.} \\begin{algorithmic} \\Require $\\mathbf{p} \\sim p(x)$ is a known bit-vector of size $n$, where $P(x) = x^n + p(x)$. \\Require $\\mathbf{q}$ is a bit-vector of size $n &gt; 0$. \\Procedure{MultiplyStep}{$\\mathbf{q}$} \\State $tmp \\gets q_{n-1}$ \\State $\\mathbf{q} \\gets \\mathbf{q} \\gg 1$ \\If {$tmp$} \\State $\\mathbf{q} \\gets \\mathbf{q} \\wedge \\mathbf{p}$ \\EndIf \\EndProcedure \\end{algorithmic} \\end{algorithm}\n\n\n\n\nThe Square Step\nIn GF(2) if a polynomial \\(q(x)\\) is represented by the coefficient bit-vector \\(\\bold{q} = [q_0, q_1, q_2, \\ldots, q_{n-1}]\\): \\[\n    q(x) = q_0 + q_1 x + q_2 x^2 + \\ldots q_{n-1} x^{n-1},\n\\] one can easily show that \\[\n    q(x)^2 = q_0 + q_1 x^2 + q_2 x^4 + \\cdots + q_{n-1} x^{2n-2},\n\\] so \\(s(x) = q(x)^2\\) is represented by riffling the bit-vector \\(\\bold{q}\\) \\[\n    s(x) = q(x)^2 \\sim \\bold{s} = [q_0, 0, q_1, 0, q_2, \\ldots, 0, q_{n-1}],\n\\] i.e. the bit-vector we get by interspersing the elements of \\(\\bold{q}\\) with zeros.\nRiffling can be done very efficiently block by block and the library has a riffled(...) method which takes a bit-vector \\(\\bold{q}\\) and fills a destination bit-vector \\(\\bold{s}\\) with a riffled version of \\(\\bold{q}\\).\nThe library also has a method split(...) that takes a bit-vector \\(\\bold{s}\\), a number \\(n\\), and then fills two other bit-vectors \\(\\bold{l}\\) and \\(\\bold{h}\\) where \\(\\bold{l}\\) gets the first \\(n\\) elements in \\(\\bold{v}\\) and \\(\\bold{h}\\) gets the rest. \\[\n\\begin{align}\n    \\bold{l} &= [s_0, s_1, \\ldots, s_{n-1}], \\\\\n    \\bold{h} &= [s_n, s_{n+1}, \\dots].\n\\end{align}\n\\] In polynomial terms this is equivalent to the decomposition: \\[\n    s(x) = l(x) + x^n \\, h(x),\n\\] where the degree of \\(l(x)\\) is less than \\(n\\).\nGiven that \\(s(x) = q(x)^2\\) we have \\[\n    q(x)^2 \\mod P(x) = s(x) \\mod P(x) = l(x) \\mod P(x) + x^n h(x) \\mod P(x),\n\\] and because the degree of \\(l(x)\\) is less than \\(n\\) we have \\[\n    q(x)^2 \\mod P(x) = l(x) + x^n h(x) \\mod P(x).\n\\] Writing \\(h(x)\\) as \\[\nh(x) = \\sum_{i=0}^{n-1} h_i x^i\n\\] it follows that \\[\n    q(x)^2 \\mod P(x) =  l(x) + \\sum_{i=0}^{n} h_i x^{n + i} \\mod P(x).\n\\] Define the bit-vectors \\(\\bold{x}^i\\) by the equivalence: \\[\n    \\bold{x}^i \\sim x^{n+i} \\mid P(x) \\text{ for } i = 0, \\ldots, n-1.\n\\] Now we know that \\(x^n \\mod P(x) = p(x)\\) so \\[\n    \\bold{x}^0 = \\bold{p}.\n\\] With that starting point, we can easily fill in bit vectors \\(\\bold{x}^i\\) for \\(i = 1, \\ldots, n-1\\) by using Algorithm 2.\nThe squaring step looks like the following:\n\n\n\\begin{algorithm} \\caption{The step: $q(x) \\gets q(x)^2 \\mid P(x)$.} \\begin{algorithmic} \\Require $\\mathbf{p} \\sim p(x)$ is a known bit-vector of size $n$, where $P(x) = x^n + p(x)$. \\Require $\\mathbf{x}^i$ are known bit-vectors, where $\\mathbf{x}^i \\sim x^{n+i} \\mid P(x)$. \\Require $\\mathbf{s}, \\mathbf{l}$ and $\\mathbf{h}$ are available workspace bit-vectors. \\Require $\\mathbf{q}$ is a bit-vector of size $n &gt; 0$. \\Procedure{SquareStep}{$\\mathbf{q}$} \\State // \\textit{Riffle $\\mathbf{q}$ into $\\mathbf{s}$.} \\State \\Call{riffle}{$\\mathbf{q}$, $\\mathbf{s}$} \\State // \\textit{Fill $\\mathbf{l}$ with a copy of the first $n$ elements from $\\mathbf{s}$ and $\\mathbf{h}$ with the rest.} \\State \\Call{split}{$\\mathbf{s}$, $n$, $\\mathbf{l}$, $\\mathbf{h}$} \\State $\\mathbf{q} \\gets \\mathbf{l}$ \\For {$i \\gets 0, n-1$} \\If{$h_i$} \\State $\\mathbf{q} \\gets \\mathbf{q} \\wedge \\mathbf{x}^i$ \\EndIf \\EndFor \\EndProcedure \\end{algorithmic} \\end{algorithm}\n\n\nSome efficiencies can easily be implemented in that algorithm’s loop as, for example, at most every second element in \\(\\bold{h}\\) is ever set.",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Polynomial Reduction"
    ]
  },
  {
    "objectID": "content/notes/index.html",
    "href": "content/notes/index.html",
    "title": "Technical Notes",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Introduction"
    ]
  },
  {
    "objectID": "content/notes/index.html#introduction",
    "href": "content/notes/index.html#introduction",
    "title": "Technical Notes",
    "section": "Introduction",
    "text": "Introduction\nThere isn’t a lot of material on the web devoted to computational work in GF(2).\nWe add some here:\n\n\n\n\n\n\n\n\nPaper\nTopic\n\n\n\n\nWorking in GF(2)\nSome notes about the vagaries of working in \\(\\FF\\).\n\n\nLibrary Design Notes\nNotes about the overall design of the bit library.\n\n\nDanilevsky’s Method\nAn algorithm to compute the characteristic polynomial of a square matrix — the algorithm isn’t well known, so we review it here.\n\n\nPolynomial Reduction\nAn algorithm to compute \\(x^N\\) mod \\(P(x)\\) where \\(P(x)\\) is a polynomial over \\(\\FF\\) and \\(N\\) is potentially a huge integer.",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Introduction"
    ]
  },
  {
    "objectID": "content/notes/danilevsky.html",
    "href": "content/notes/danilevsky.html",
    "title": "Danilevsky’s Algorithm",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Danilevsky's Method"
    ]
  },
  {
    "objectID": "content/notes/danilevsky.html#abstract",
    "href": "content/notes/danilevsky.html#abstract",
    "title": "Danilevsky’s Algorithm",
    "section": "Abstract",
    "text": "Abstract\nDanilevsky’s algorithm is a method to compute the coefficients of the characteristic polynomial for a square matrix.\nIt isn’t well known, so we review how it works for real-valued matrices.\nWe then go on to explain how it applies explicitly to bit-matrices, i.e., matrices over GF(2), the simplest Galois field with just two elements 0 & 1 where addition/subtraction and multiplication/division operations are all done mod two which keeps everything closed in the set \\(\\{0,1\\}\\).",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Danilevsky's Method"
    ]
  },
  {
    "objectID": "content/notes/danilevsky.html#characteristic-polynomials",
    "href": "content/notes/danilevsky.html#characteristic-polynomials",
    "title": "Danilevsky’s Algorithm",
    "section": "Characteristic Polynomials",
    "text": "Characteristic Polynomials\nRecall that \\(\\lambda\\) is an eigenvalue of \\(A\\), an \\(n \\times n\\) matrix, if there is an non-zero vector \\(v\\) (an eigenvector) such that: \\[\n  A \\cdot v = \\lambda v.\n\\] Solving that equation is equivalent to finding solutions for the linear system \\[\n  (A - \\lambda I) v = 0.\n\\] which has solutions if and only if \\(A - \\lambda I\\) is singular so \\[\n   |A - \\lambda I| = 0\n\\] where we are using \\(|\\cdot|\\) to denote the determinant.\nThe characteristic polynomial of \\(A\\) is defined by the determinant \\(|A - \\lambda I|\\) thought of as a function of \\(\\lambda\\): \\[\n  c(\\lambda) = |A - \\lambda I|.\n\\] Expanding the determinant, you can explicitly get a few of the terms in this polynomial as \\[\n  c(\\lambda) = (-\\lambda)^n  + tr(A)(-\\lambda)^{n-1} + \\cdots + \\det(A)\n\\] where \\(tr(A)\\) is the trace of the matrix \\(A\\). However, it is not practical to compute all the terms in the polynomial by brute force expansion like this.\nEven if we have all the coefficients in the characteristic polynomial, getting the eigenvalues means solving \\[\n  c(\\lambda) = 0.\n\\] However, extracting the roots of a high-order polynomial is very difficult. For this reason, the method is only practical for the small matrices that turn up in homework exercises!\nHowever, the characteristic polynomial is a valuable structure for other purposes. For one thing, the well-known Cayley Hamilton theorem tells us that the characteristic polynomial is an annihilating polynomial for the matrix. Thus \\[\n  c(A) = 0.\n\\] This result is helpful in various applications. For this reason, we are still interested in computing the coefficients \\(c_i\\) of the characteristic polynomial written as \\[\n  c(\\lambda) = \\lambda^n + c_{n-1} \\lambda^{n-1} + \\cdots + c_1 \\lambda + c_0.\n\\] (where without loss of generality, we take \\(c_n = 1\\))",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Danilevsky's Method"
    ]
  },
  {
    "objectID": "content/notes/danilevsky.html#companion-matrices",
    "href": "content/notes/danilevsky.html#companion-matrices",
    "title": "Danilevsky’s Algorithm",
    "section": "Companion Matrices",
    "text": "Companion Matrices\nInvestigating square matrices of size \\(n\\) led us to consider polynomials of order \\(n\\). How about the reverse? If you have an arbitrary polynomial of the form \\[\n  c(\\lambda) = \\lambda^n + c_{n-1} \\lambda^{n-1} + \\cdots + c_1 \\lambda + c_0.\n\\] Is there a matrix with that as its characteristic polynomial?\nHere is one we will show works: \\[\nC =\n\\begin{bmatrix}\n-c_{n-1} & -c_{n-2} & -c_{n-3} & \\ldots & & -c_2 & -c_1 & -c_0 \\\\\n1        & 0        & 0        & \\ldots & & 0    & 0    & 0    \\\\\n0        & 1        & 0        & \\ldots & & 0    & 0    & 0    \\\\\n         &          &          & \\ldots                        \\\\\n0        & 0        & 0        & \\ldots & & 1    & 0    & 0    \\\\\n0        & 0        & 0        & \\ldots & & 0    & 1    & 0\n\\end{bmatrix}\n\\] This \\(C\\) has ones on the sub-diagonal and the polynomial coefficients (with a minus sign) along the first row. It is an upper Hessenberg matrix.\nComputing the determinant is difficult for all but the smallest general matrices. However, getting the determinant for triangular matrices is trivial, as you only need to multiply the elements on the diagonal. Hessenberg matrices are almost triangular and also quite amenable when it comes to computing determinants.\nTo see that our \\(C\\) has the characteristic polynomial, we want to consider the determinant: \\[\n|\\lambda I - C| =\n\\begin{vmatrix}\n\\lambda+c_{n-1}     & c_{n-2}  & c_{n-3} & \\ldots & & c_2 & c_1      & c_0    \\\\\n1        & \\lambda  & 0                  & \\ldots & & 0    & 0       & 0      \\\\\n0        & 1        & \\lambda            & \\ldots & & 0    & 0       & 0      \\\\\n         &          &                    & \\ldots                             \\\\\n0        & 0        & 0                  & \\ldots & & 1    & \\lambda & 0      \\\\\n0        & 0        & 0                  & \\ldots & & 0    & 1       & \\lambda\n\\end{vmatrix}\n\\] When you expand that determinant by the first row, then you get \\[\n(\\lambda + c_{n-1})\n\\begin{vmatrix}\n& \\lambda  & 0                  & \\ldots & & 0    & 0       & 0      \\\\\n& 1        & \\lambda            & \\ldots & & 0    & 0       & 0      \\\\\n&          &                    & \\ldots                             \\\\\n& 0        & 0                  & \\ldots & & 1    & \\lambda & 0      \\\\\n& 0        & 0                  & \\ldots & & 0    & 1       & \\lambda\n\\end{vmatrix}\n+ c_{n-2}\n\\begin{vmatrix}\n& 1  & 0                        & \\ldots & & 0    & 0       & 0      \\\\\n& 0        & \\lambda            & \\ldots & & 0    & 0       & 0      \\\\\n&          &                    & \\ldots                             \\\\\n& 0        & 0                  & \\ldots & & 1    & \\lambda & 0      \\\\\n& 0        & 0                  & \\ldots & & 0    & 1       & \\lambda\n\\end{vmatrix}\n+ \\dots\n+ c_0\n\\begin{vmatrix}\n& 1        & 0                  & \\ldots & & 0    & 0       & 0         \\\\\n& 0        & 1                  & \\ldots & & 0    & 0       & 0         \\\\\n&          &                    & \\ldots                                \\\\\n& 0        & 0                  & \\ldots & &      & 1       & \\lambda   \\\\\n& 0        & 0                  & \\ldots & & 0    & 0       & 1\n\\end{vmatrix}\n\\] The co-factors are all \\((n-1) \\times (n-1)\\) triangular so have readily computed determinants which means that: \\[\n|\\lambda I - C| =  (\\lambda + c_{n-1}) \\lambda^{n-1} + c_{n-2} \\lambda^{n-2} + \\cdots + c_0.\n\\] That is exactly the form we want.\n\n\n\n\n\n\nNote\n\n\n\nYou can make the same determinant expansion argument if the polynomial coefficients were in the final column instead of the top row. That is the version seen in some expositions.\n\n\n\\(C\\) is a “companion” for the polynomial \\(c(\\lambda)\\) and is known as a companion matrix.\n\nFrobenius Form\nFirst, note that you can create many others once you have a matrix (like the \\(C\\) above) with the desired characteristic polynomial. The reason is that similar matrices all have the same characteristic polynomial. So if \\(M\\) is any invertible \\(n \\times n\\) matrix, then \\(M^{-1} \\cdot C \\cdot M\\) will have the same characteristic polynomial as \\(C\\).\nNow let \\(A\\) be an arbitrary \\(n \\times n\\) matrix.\nA natural question then is whether you can find some invertible \\(M\\) such that \\(C = M^{-1} \\cdot A \\cdot M\\) is in companion matrix form. If so, you can read the characteristic polynomial coefficients for \\(A\\) off the top row of \\(C\\).\nGenerally, this isn’t quite possible, but instead, you can always get to Frobenius form. A Frobenius form matrix is block-diagonal, where each block is a companion matrix.\nSo there is always some \\(M\\) such that \\[\nA = M^{-1} \\cdot F \\cdot M.\n\\] And the matrix \\(F\\) has the block-diagonal form \\[\nF =\n\\begin{bmatrix}\nC_0 & 0   & 0 & \\ldots & 0 & 0 \\\\\n0   & C_1 & 0 & \\ldots & 0 & 0 \\\\\n    &     &   & \\ldots         \\\\\n0   & 0   & 0 & \\ldots & 0 & C_{k-1}\n\\end{bmatrix}\n\\] and each of the \\(k\\) diagonal blocks is a companion matrix.\nYou can read off the coefficients of each block to get a set of characteristic polynomials \\(c_i(\\lambda)\\) for \\(i = 0, \\ldots, k-1\\). Then the characteristic polynomial of \\(F\\) and hence by similarity, \\(A\\) is just: \\[\nc(\\lambda) = \\prod_{i = 0}^{k-1} c_i(\\lambda).\n\\]\nIf \\(A\\) is an arbitrary real-valued \\(n \\times n\\) matrix, Danilevsky’s algorithm applies a sequence of similarity transformations that, step by step, efficiently moves it to Frobenius form.",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Danilevsky's Method"
    ]
  },
  {
    "objectID": "content/notes/danilevsky.html#danilevsky-for-real-matrices",
    "href": "content/notes/danilevsky.html#danilevsky-for-real-matrices",
    "title": "Danilevsky’s Algorithm",
    "section": "Danilevsky for Real Matrices",
    "text": "Danilevsky for Real Matrices\nWe will describe how the algorithm works for an \\(n \\times n\\) matrix \\(A\\) with elements in \\(\\R\\). The algorithm can be written as\n\\[\nA = A_1 \\rightarrow A_2 \\rightarrow \\ldots \\rightarrow A_n\n\\] where that final matrix, \\(A_n\\), is in Frobenius form. At each stage, \\(A_{k+1}\\) is constructed from its predecessor \\(A_{k}\\) via a similarity transformation: \\[\nA_{k+1} = M^{-1}_{k} \\cdot A_k \\cdot M_k.\n\\] Here “\\(\\cdot\\)” denotes matrix multiplication.\nThe algorithm is efficient because we can readily construct the \\(M_k\\)’s and their inverses. Moreover, they are sparse matrices, meaning those two matrix multiplications can be performed quickly in \\(O(n^2)\\) operations instead of the usual \\(O(n^3)\\).\nStarting with a general matrix such as\n\\[\nA := A_1 =\n\\begin{bmatrix}\na_{11} & a_{12} & a_{13} & \\ldots & a_{1n-2} & a_{1n-1} & a_{1n} \\\\\na_{21} & a_{22} & a_{23} & \\ldots & a_{2n-2} & a_{2n-1} & a_{2n} \\\\\n& & & \\ldots \\\\\n& & & \\ldots \\\\\na_{n-11} & a_{n-12} & a_{n-13} & \\ldots & a_{n-1n-2} & a_{n-1n-1} & a_{n-1n} \\\\\na_{n1} & a_{n2} & a_{n3} & \\ldots & a_{nn-2} & a_{nn-1} & a_{nn}\n\\end{bmatrix}\n\\]\nwe would love to get to the companion matrix form\n\\[\nA_n =\n\\begin{bmatrix}\nc_1 & c_2 & c_3 & \\ldots & & c_{n-2} & c_{n-1} & c_{n} \\\\\n1 & 0 & 0 & \\ldots & & 0 & 0 & 0 \\\\\n& & & \\ldots \\\\\n& & & \\ldots \\\\\n0 & 0 & 0 & \\ldots & & 1 & 0 & 0 \\\\\n0 & 0 & 0 & \\ldots & & 0 & 1 & 0 \\\\\n\\end{bmatrix}\n\\]\nThe characteristic polynomial for \\(A\\) is then\n\\[\nc(\\lambda) = 1 + c_1 \\lambda + c_2 \\lambda^2 + \\cdots + c_{n-1} \\lambda^{n-1} + c_{n} \\lambda^{n}.\n\\]\nTo get things rolling, we need to construct a matrix \\(M\\) such that \\(A \\cdot M\\) is one step closer to companion matrix form (we are dropping the subscripts on the matrices—in a computer implementation the matrices mostly just get updated in-place anyway).\nOur aim is to find \\(M\\) so that \\(B := A \\cdot M\\) has the form\n\\[\n\\begin{bmatrix}\nb_{11} & b_{12} & b_{13} & \\ldots & b_{1n-2} & b_{1n-1} & b_{1n} \\\\\nb_{21} & b_{22} & b_{23} & \\ldots & b_{2n-2} & b_{2n-1} & b_{2n} \\\\\n& & & \\ldots \\\\\n& & & \\ldots \\\\\nb_{n-11} & b_{n-12} & b_{n-13} & \\ldots & b_{n-1n-2} & b_{n-1n-1} & b_{n-1n} \\\\\n0 & 0 & 0 & \\ldots & 0 & 1 & 0\n\\end{bmatrix}\n\\]\nAssuming that \\(a_{nn-1} \\neq 0\\), an appropriate \\(M\\) is\n\\[\nM =\n\\begin{bmatrix}\n1 & 0 & 0 & \\ldots & 0 & 0 & 0 \\\\\n0 & 1 & 0 & \\ldots & 0 & 0 & 0 \\\\\n& & & \\ldots \\\\\n& & & \\ldots \\\\\n\\frac{-a_{n1}}{a_{nn-1}} & \\frac{-a_{n2}}{a_{nn-1}} & \\frac{-a_{n3}}{a_{nn-1}} & \\ldots & \\frac{-a_{nn-2}}{a_{nn-1}} & \\frac{1}{a_{nn-1}} & \\frac{-a_{nn}}{a_{nn-1}} \\\\\n0 & 0 & 0 & \\ldots & 0 & 0 & 1\n\\end{bmatrix}\n\\]\nThat is, \\(M\\) is simply the identity matrix with the \\((n-1)\\)’st row replaced as shown. With a bit of staring, you should be able to convince yourself that \\(B = A \\cdot M\\) will indeed have a final row in Frobenius form.\nNote that each column \\(l\\) in \\(M\\) has at most two non-zero elements namely \\(M_{ll}\\) and \\(M_{n-1l}\\) This means that the elements of \\(B\\) are computed efficiently by considering just a couple of terms instead of the usual \\(n\\).\n\\[\nb_{ij} = \\sum_{l=1}^{n} a_{il}m_{lj} = a_{ij}m_{jj} + a_{in-1}m_{n-1j}\n\\]\nSo\n\\[\nb_{ij} = a_{ij} - a_{in-1} \\frac{a_{nj}}{a_{nn-1}} \\text{ for columns } j \\ne n-1,\n\\]\nand\n\\[\nb_{in-1} = \\frac{a_{in-1}}{a_{nn-1}} \\text{ for column } n-1.\n\\]\nNote that as promised \\(b_{nj} = 0 \\text{ if} j \\ne n-1\\) and that \\(b_{nn-1} = 1\\).\nOf course, \\(B = A \\cdot M\\) is not similar the original matrix \\(A\\) but \\(M^{-1} \\cdot A \\cdot M\\) is.\nFortunately \\(M^{-1}\\) is also readily computed\n\\[\nM^{-1} =\n\\begin{bmatrix}\n1 & 0 & 0 & \\ldots & 0 & 0 & 0 \\\\\n0 & 1 & 0 & \\ldots & 0 & 0 & 0 \\\\\n& & & \\ldots \\\\\n& & & \\ldots \\\\\na_{n1} & a_{n2} & a_{n3} & \\ldots & a_{nn-2} & a_{nn-1} & a_{nn} \\\\\n0 & 0 & 0 & \\ldots & 0 & 0 & 1\n\\end{bmatrix}\n\\]\nFrom the form of \\(M^{-1}\\), it is clear that the \\(n\\)’th row of \\(C := M^{-1} \\cdot B\\) is just the same as the \\(n\\)’th row of \\(B\\), so it will be in Frobenius form.\nMoreover, once again, \\(M^{-1}\\) has at most two non-zero terms in each column. Therefore, the matrix product can also be computed very efficiently:\n\\[\nc_{ij} = \\sum_{l=1}^{n} m_{il} b_{lj} = m_{ii} b_{ij} = b_{ij} \\text{ if } i \\ne n-1\n\\]\nwhile\n\\[\nc_{n-1j} = \\sum_{l=1}^{n} m_{n-1l} b_{lj} = \\sum_{l=1}^{n} a_{nl} b_{lj}\n\\]\nThus \\(C = M^{-1} \\cdot A \\cdot M\\) is similar to \\(A\\) but one step closer to companion matrix form, and happily, the elements of \\(C\\) can be efficiently computed using just \\(O(n^2)\\) operations. If everything goes well, we can repeat these operations for \\(n\\) steps to arrive at the required Frobenius form shown above. We hit a snag if \\(a_{nn-1} = 0\\), but we will deal with that below.\n\nThe Algorithm\n. Initialize a counter \\(k\\) to \\(n\\) and \\(A\\) to the input matrix.\n. If \\(a_{kk-1} = 0\\), look for an earlier element in the same row that is not zero. That is, look for \\(j &lt; k-1\\) where \\(a_{kj} \\ne 0\\).\nOn success, swap the rows and columns \\(j\\) and \\(k-1\\) of \\(A\\).\nRow and column swaps like that are permutation transformations that preserve the eigen-structure.\n\n. If by now \\(a_{kk-1} \\ne 0\\):\n.. Capture row \\(k\\) of the matrix \\(A\\) by setting \\(m = \\text{row}_k(A)\\).\nNote that by assumption \\(m_{k-1} = a_{kk-1} \\ne 0\\).\n.. Compute the elements of \\(B\\) for rows \\(i = 1, ..., k-1\\) as follows: \\[\nb_{ij} =\n\\begin{cases}\n  a_{ij} -  a_{ik-1}\\frac{m_j}{m_{k-1}} & \\text{ if } j \\ne k-1 \\\\\n  \\frac{a_{ik-1}}{m_{k-1}}              & \\text{ if } j = k-1\n\\end{cases}\n\\] You don’t need any later rows of \\(B\\).\n.. Update \\(A\\) for all columns \\(j = 1, \\ldots, n\\) as follows: \\[\n\\begin{aligned}\na_{ij}   &=  b_{ij} \\text{ for } i = 1, \\ldots, k-2, \\\\\na_{k-1j} &= \\sum_{l=1}^{n} m_l b_{lj} = m \\cdot \\text{col}_j(B) \\\\\na_{kj}   &=\n\\begin{cases}\n  0 & \\text { for } j \\ne k-1 \\\\\n  1 & \\text { for } j = k-1\n\\end{cases}\n\\end{aligned}\n\\] That last step puts row \\(k\\) of \\(A\\) into companion matrix form — the later rows of \\(A\\) are already there.\n.. If \\(k &gt; 1\\), then \\(k \\leftarrow k-1\\), and we go back to step 1. Otherwise, we are finished.\n. If \\(a_{kk-1} = 0\\) even after trying the search in step 2 then we cannot perform step 3. + The current \\(A\\) matrix must then have the following form: + \\[\nA =\n\\begin{bmatrix}\na_{11}  & a_{12} & \\ldots & a_{1k-1} & a_{1k} & a_{1k+1} & \\ldots & a_{1n-1} & a_{1n} \\\\\na_{21}  & a_{22} & \\ldots & a_{2k-1} & a_{2k} & a_{2k+1} & \\ldots & a_{2n-1} & a_{2n} \\\\\n\\vdots  & \\vdots & \\vdots & \\vdots   & \\vdots & \\vdots   & \\vdots & \\vdots   & \\vdots \\\\\n0       & 0      & \\ldots & 0        & a_{kk} & a_{kk+1} & \\ldots & a_{kn-1} & a_{kn} \\\\\n0       & 0      & \\ldots & 0        & 1      & 0        & \\ldots & 0        & 0      \\\\\n\\vdots  & \\vdots & \\vdots & \\vdots   & \\vdots & \\vdots   & \\vdots & \\vdots   & \\vdots \\\\\n0       & 0      & \\ldots & 0        & 0      & 0        & \\ldots & 1        & 0\n\\end{bmatrix} :=\n\\begin{bmatrix}\nA_1 & A_2 \\\\\n0   & A_3\n\\end{bmatrix}\n\\] + So if \\(I_n\\) represents the \\(n \\times n\\) identity matrix then: + \\[\n\\det(\\lambda I_n - A) = \\det(\\lambda I_{k-1} - A_1) \\det(\\lambda I_{n-k+1} - A_3).\n\\] + Hence the characteristic polynomial \\(c_A(x)\\) we are after is the product of two other characteristic polynomials: + \\[\nc_A(x) = c_{A_1}(x) c_{A_3}(x)\n\\] + and as \\(A_3\\) is already in companion form we can easily read off the coefficients for \\(c_{A_3}(x)\\) + \\[\nc_{A_3}(x) = 1 + a_{kk} x + a_{kk+1} x^2 + \\ldots + a_{kn} x^{n-k+1}.\n\\] + The algorithm just stores those coefficients and recurses using \\(A_1\\) as the smaller \\((k-1) \\times (k-1)\\) input matrix. + It can then convolve the coefficients of \\(c_{A_1}(x)\\) and \\(c_{A_3}(x)\\) to return the coefficients for \\(c_{A}(x)\\).\n\n\n\n\n\n\nThere are no badly conditioned matrices in \\(\\FF\\)\n\n\n\nIn the case of real valued matrices it can be that \\(a_{kk-1}\\) is non-zero but still small. Division by very small floating point numbers should be avoided as those operations tend to be ill-conditioned. For that reason, step 2. might always be performed to find the \\(a_{kj}\\) for \\(j &lt; k-1\\) that is largest in absolute value and then do the suggested row and column swaps to move that element into the all important \\((k,k-1)\\) slot.",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Danilevsky's Method"
    ]
  },
  {
    "objectID": "content/notes/danilevsky.html#danilevsky-for-bit-matrices",
    "href": "content/notes/danilevsky.html#danilevsky-for-bit-matrices",
    "title": "Danilevsky’s Algorithm",
    "section": "Danilevsky for Bit-Matrices",
    "text": "Danilevsky for Bit-Matrices\nIn the case of bit-matrices, or in more formal math-speak, matrices with elements in \\(\\FF\\), the input matrix \\(A\\) is all zeros or ones. Moreover, the usual addition and multiplication operators are performed modulo 2 so everything remains in the limited set \\(\\{0,1\\}\\). In \\(\\mathbb{F_2}\\) we can replace addition with the logical XOR operator and multiplication with the logical AND operator.\nNote that in \\(\\mathbb{F_2}\\) we have \\(1+1 = 2 \\rightarrow 0\\) so the additive inverse of 1 is 1. And of course as usual, the additive inverse of 0 is 0. This means that in \\(\\mathbb{F_2}\\) negation is a no-op and any term like \\(-b\\) can just be replaced with \\(b\\).\nWe always have \\(1 * 1 = 1\\) so the multiplicative inverse of \\(1\\) is just \\(1\\). Also just like \\(\\mathbb{R}\\), the element \\(0\\) has no multiplicative inverse in \\(\\mathbb{F_2}\\) either — you still cannot divide by zero. This means that if \\(a, b \\in \\mathbb{F_2}\\) then a term like \\(a/b\\) makes no sense if \\(b=0\\) but otherwise \\(a/b = a\\).\nLet’s reconsider that very first step we took above to move our matrix \\(A\\) closer to Frobenius form. That involved finding a matrix \\(M\\) such that \\(B = A \\cdot M\\) had its final row in the required format.\nTaking into account that now all the matrices are boolean and assuming that \\(a_{nn-1} = 1\\) then the appropriate \\(M\\) is:\n\\[\nM =\n\\begin{bmatrix}\n1 & 0 & 0 & \\ldots & 0 & 0 & 0 \\\\\n0 & 1 & 0 & \\ldots & 0 & 0 & 0 \\\\\n& & & \\ldots \\\\\n& & & \\ldots \\\\\na_{n1} & a_{n2} & a_{n3} & \\ldots & a_{nn-2} & a_{nn-1} & a_{nn} \\\\\n0 & 0 & 0 & \\ldots & 0 & 0 & 1\n\\end{bmatrix}\n\\]\nThat is, \\(M\\) is just the identity matrix with the \\((n-1)\\)’st row replaced with that row from \\(A\\).\nMoreover, using the fact that for any \\(x \\in \\mathbb{F}_2\\) we always have \\(x + x = 2x = 0\\), it is is easy to verify that \\(M^{-1} = M\\).\nSo \\(C := M \\cdot A \\cdot M\\) will be similar to \\(A\\) and one step closer to Frobenius form and, because \\(M\\) is simple and sparse, those two matrix multiplications can be performed very efficiently in \\(O(n^2)\\) operations.\nThe full algorithm for matrices over \\(\\mathbb{R}\\) also works for matrices over \\(\\mathbb{F_2}\\). As before, it proceeds in a sequence of steps that move \\(A\\) closer to companion/Frobenius matrix form at the end of each one.\n\nThe Algorithm\n\nInitialize a counter \\(k\\) to \\(n\\) and \\(A\\) to the input matrix.\nIf \\(a_{kk-1} = 0\\) look for an earlier element in the same row that is 1. That is, look for an index \\(j &lt; k-1\\) such that \\(a_{kj} = 1\\). If found then swap both the rows and the columns \\(j\\) and \\(k-1\\) of \\(A\\). These swaps are permutation transformations that preserve the eigen-structure.\nIf after step 2 we have \\(a_{kk-1} = 1\\):\n\nCapture the elements from row \\(k\\) of the matrix \\(A\\) by setting \\[\nm = \\text{row}_k(A).\n\\] Note that by assumption \\(m_{k-1} = a_{kk-1} = 1\\).\nCompute the elements of \\(B\\) for rows \\(i = 1, ..., k-1\\) as follows \\[\nb_{ij} =\n\\begin{cases}\n  a_{ij} -  a_{ik-1}\\frac{m_j}{m_{k-1}} = a_{ij} + a_{ik-1} m_j & \\text{ if } j \\ne k-1 \\\\\n  \\frac{a_{ik-1}}{m_{k-1}} = a_{ik-1}                           & \\text{ if } j = k-1\n\\end{cases}\n\\]\nUpdate \\(A\\) for all columns \\(j = 1, \\ldots, n\\) as follows \\[\n\\begin{aligned}\na_{ij}   &=  b_{ij} \\text{ for } i = 1, \\ldots, k-2, \\\\\na_{k-1j} &= \\sum_{l=1}^{n} m_l b_{lj} = m \\cdot \\text{col}_j(B) \\\\\na_{kj}   &=\n\\begin{cases}\n  0 & \\text { for } j \\ne k-1 \\\\\n  1 & \\text { for } j = k-1\n\\end{cases}\n\\end{aligned}\n\\] That last step puts row \\(k\\) of \\(A\\) into Frobenius form — later rows are already there.\nIf \\(k &gt; 1\\) then \\(k \\gets k-1\\) and we go back to step 1, otherwise, we are done.\n\nIf after step 2 we have \\(a_{kk-1} = 0\\) then we cannot perform step 3.\nIn this case, the current \\(A\\) matrix must have the following form: \\[\nA =\n\\begin{bmatrix}\nA_1 & A_2 \\\\\n0   & A_3\n\\end{bmatrix}\n\\] hence the characteristic polynomial \\(c_A(x)\\) is the product of two others:\n\\[\nc_A(x) = c_{A_1}(x) c_{A_3}(x).\n\\] As \\(A_3\\) is already in Frobenius form we can easily read off the coefficients for \\(c_{A_3}(x)\\):\n\\[\nc_{A_3}(x) = 1+ a_{kk} x + a_{kk+1} x^2 + \\ldots + a_{kn} x^{n-k+1}.\n\\] Store those coefficients and recurse using \\(A_1\\) as the \\((k-1) \\times (k-1)\\) input matrix. Convolve the coefficients of \\(c_{A_1}(x)\\) and \\(c_{A_3}(x)\\) to get the coefficients for \\(c_{A}(x)\\).\n\n\n\n\n\n\n\nRecursion is to be expected here\n\n\n\nIn \\(\\FF\\) any matrix element can only be \\(0\\) or \\(1\\). Therefore, all things being equal, you’d expect to have to perform the recursive fourth step half the time.",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Danilevsky's Method"
    ]
  },
  {
    "objectID": "content/gauss/index.html",
    "href": "content/gauss/index.html",
    "title": "The bit::gauss Class",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]",
    "crumbs": [
      "Home",
      "Gaussian Elimination",
      "Introduction"
    ]
  },
  {
    "objectID": "content/gauss/index.html#introduction",
    "href": "content/gauss/index.html#introduction",
    "title": "The bit::gauss Class",
    "section": "Introduction",
    "text": "Introduction\nWe use a bit::gauss object to find solutions for the system of linear equations \\(A \\cdot x = b\\) over \\(\\FF\\).\nHere, \\(A\\) is a known bit-matrix, \\(b\\) is a known right-hand side bit-vector, and \\(x\\) is the unknown solution to the system. \\(A\\) should be square and the size of the \\(b\\) should match the number of rows in \\(A\\).\nAs the name suggests, the solution method is Gaussian elimination, specifically Gauss-Jordan elimination.\nOn construction, the bit::gauss object captures copies of \\(A\\) and \\(b\\). Then, it uses elementary row operations to transform the left-hand side matrix to reduced row-echelon form while simultaneously performing identical operations to the right-hand side vector. With those in place, the solver can quickly produce solutions \\(x\\) by simple back-substitution.\nAs well as getting solutions for the system \\(A \\cdot x = b\\), the bit::gauss object can be queried for other helpful information such as the rank of \\(A\\), whether the system is consistent (i.e., whether any solutions at all exist), and so on. See the complete list below.\nRecognizing that often one wants to find a solution to \\(A \\cdot x = b\\) with a minimum of palaver, there is a non-member function to do just that. It can be invoked as follows:\nauto x = bit::solve(A,b);\nif(x) {\n    ...\n}\nThe x here is a bit-vector wrapped in a std::optional. If no solution exists, x will be a std::nullopt; otherwise, it can be dereferenced as a bit::vector.",
    "crumbs": [
      "Home",
      "Gaussian Elimination",
      "Introduction"
    ]
  },
  {
    "objectID": "content/gauss/index.html#multiple-solutions",
    "href": "content/gauss/index.html#multiple-solutions",
    "title": "The bit::gauss Class",
    "section": "Multiple Solutions",
    "text": "Multiple Solutions\nA system of linear equations over \\(\\R\\) has either no solutions, one solution, or an infinite number of solutions. The latter situation arises if the system is under-determined so that there is one or more free variables.\nGenerally, if you have \\(m\\) independent and consistent equations for \\(n\\) unknowns and \\(n&gt;m\\), there are \\(f=n-m\\) free variables. Reducing the matrix to echelon form lets you determine how many independent equations exist and quickly check that the system is consistent. Over \\(\\R\\), a free variable can take on any value; hence, there are an infinite number of possible solutions to the system.\nOver \\(\\FF\\), the situation is different because a free variable can only take on one of the values 0 and 1. Hence, if the system is consistent and has \\(f\\) free variables, it will have \\(2^f\\) possible solutions. So, if no free variables exist, a consistent system will have one unique solution.\nThat x in the above example will be one of those \\(2^f\\) possible solutions randomly picked. We also provide a way to iterate through many possible solutions (not necessarily all of them because if \\(f\\) is large, the number of potential solutions will explode).\nIf solver is a bit::gauss for the consistent system \\(A \\cdot x = b\\) with \\(f\\) free variables, then the call solver() will return one of the possible \\(2^f\\) solutions picked entirely at random (calling solver() again may well return a different but equally valid solution). On the other hand, a call to solver(n), where n is a std::size_t and \\(n &lt; 2^f\\), will produce a specific solution. There are many ways to produce an ordering amongst the possible solutions, but in any case, calling to solver(n) will always return the same solution.",
    "crumbs": [
      "Home",
      "Gaussian Elimination",
      "Introduction"
    ]
  },
  {
    "objectID": "content/gauss/index.html#declaration",
    "href": "content/gauss/index.html#declaration",
    "title": "The bit::gauss Class",
    "section": "Declaration",
    "text": "Declaration\nLike everything in the library, this class is in the bit namespace.\nIt is defined in the header &lt;bit/gauss.h&gt; as follows:\nnamespace bit {\n    template&lt;\n        std::unsigned_integral Block = uint64_t,\n        Allocator = std::allocator&lt;Block&gt;\n    &gt; class gauss;\n}\nSee the documentation for bit::vector and bit::matrix for more information on the two template parameters.",
    "crumbs": [
      "Home",
      "Gaussian Elimination",
      "Introduction"
    ]
  },
  {
    "objectID": "content/gauss/index.html#class-types",
    "href": "content/gauss/index.html#class-types",
    "title": "The bit::gauss Class",
    "section": "Class Types",
    "text": "Class Types\n\n\n\n\n\n\n\n\nItem\nDescription\n\n\n\n\nvector_type\nAn alias for bit::vector\n\n\nmatrix_type\nAn alias for bit::matrix\n\n\nlocation_type\nstd::vector&lt;std::size_t&gt; — index locations of the free variables",
    "crumbs": [
      "Home",
      "Gaussian Elimination",
      "Introduction"
    ]
  },
  {
    "objectID": "content/gauss/index.html#instance-methods",
    "href": "content/gauss/index.html#instance-methods",
    "title": "The bit::gauss Class",
    "section": "Instance Methods",
    "text": "Instance Methods\n\nConstruction\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\ngauss::constructors\nConstruct a gauss for a system \\(A \\cdot x = b\\).\n\n\n\n\n\n\nQueries\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\ngauss::equation_count\nReturn the number of equations in the system — the number of rows in the bit-matrix \\(A\\).\n\n\ngauss::is_consistent\nReturn true if the system of equations is consistent and solvable.\n\n\ngauss::free_count\nReturn the number of free variables in the system.\n\n\ngauss::solution_count\nReturn the number of solutions to the system we can directly address.\n\n\ngauss::rank\nReturn the rank of the bit-matrix \\(A\\).\n\n\n\n\n\n\nAccess to the Echelon Form\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\ngauss::lhs\nRead access to the reduced row echelon form for \\(A\\).\n\n\ngauss::rhs\nRead access to the equivalently manipulated version of \\(b\\).\n\n\ngauss::operator()\nReturn a random solution amongst all the possible solutions for the system \\(A \\cdot x = b\\).\n\n\ngauss::operator(i)\nReturn a specific solution (solution number i if you like) for the system \\(A \\cdot x = b\\).",
    "crumbs": [
      "Home",
      "Gaussian Elimination",
      "Introduction"
    ]
  },
  {
    "objectID": "content/gauss/index.html#non-member-functions",
    "href": "content/gauss/index.html#non-member-functions",
    "title": "The bit::gauss Class",
    "section": "Non-member Functions",
    "text": "Non-member Functions\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nbit::solve\nFunction that implicitly creates a gauss object and then uses it to try and return a single solution for the system \\(A \\cdot x = b\\). The gauss object does not live on after the call.",
    "crumbs": [
      "Home",
      "Gaussian Elimination",
      "Introduction"
    ]
  },
  {
    "objectID": "content/gauss/access.html",
    "href": "content/gauss/access.html",
    "title": "bit::gauss — Echelon Form Access",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nIf the gauss object was constructed from the system \\(A \\cdot x = b\\) these methods provide read-only access to the reduced row echelon form of the bit-matrix \\(A\\) and also to the equivalently transformed bit-vector \\(b\\).\n1const bit::matrix& lhs() const;\n2const bit::vector& rhs() const;\n\n1\n\nReturns a read-only reference to the reduced row echelon form of the bit-matrix \\(A\\).\n\n2\n\nReturns a read-only reference to the equivalently transformed bit-vector \\(b\\).\n\n\nOn construction, a gauss object computes the reduced row-echelon form of the input bit-matrix \\(A\\) using elementary row operations. It performs the same operations to a copy of the input bit-vector \\(b\\). The two methods here let you look at the transformed left-hand side bit-matrix and right-hand side bit-vector.\nExample\n#include &lt;bit/bit.h&gt;\nint\nmain()\n{\n    std::size_t m = 12;\n\n    auto A = bit::matrix&lt;&gt;::random(m);\n    auto b = bit::vector&lt;&gt;::random(m);\n    std::cout &lt;&lt; \"Solving the system A.x = b for the following A & b:\\n\";\n    print(A, b);\n\n    // Create a solver object for the system\n    bit::gauss&lt;&gt; solver(A, b);\n\n    // Print some general information\n    std::cout &lt;&lt; \"Number of equations in system:   \" &lt;&lt; solver.equation_count() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Rank of the matrix A:            \" &lt;&lt; solver.rank()           &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Number of free variables:        \" &lt;&lt; solver.free_count()     &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Number of solutions to A.x = b:  \" &lt;&lt; solver.solution_count() &lt;&lt; '\\n';\n\n    // Also have a look at the echelon form of A and the equivalently transformed b\n    std::cout &lt;&lt; \"The echelon forms of A & b are:\\n\";\n    print(solver.lhs(), solver.rhs());\n}\nOutput (depends on the values of the random inputs)\nSolving the system A.x = b for the following A & b:\n011100100101    0\n000111011100    1\n111101000011    1\n010000111110    1\n110011110000    1\n101100100100    1\n011010110010    0\n010010000111    1\n101110110001    0\n001100101110    1\n100000011010    1\n111111010100    1\nNumber of equations in system:   12\nRank of the matrix A:            11\nNumber of free variables:        1\nNumber of solutions to A.x = b:  2\nThe echelon forms of A & b are:\n100000000000    1\n010000000000    0\n001000000000    1\n000100000000    0\n000010000100    0\n000001000000    0\n000000100100    1\n000000010000    1\n000000001000    0\n000000000010    1\n000000000001    0\n000000000000    0\n\nSee Also\ngauss::constructors\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/gauss/solve.html",
    "href": "content/gauss/solve.html",
    "title": "bit::solve — Solver",
    "section": "",
    "text": "We supply a standalone non-member function that attempts to solve the system of linear equations \\(A \\cdot x = b\\) over \\(\\FF\\).\nstd::optional&lt;bit::vector&gt;\n1bit::solve(const bit::matrix &A, const bit::vector &b)\n\n1\n\nA must be square, and b must be the same size as the number of rows in A.\n\n\nIf everything goes well, the [std::optional] return value can be safely dereferenced as a bit-vector. That bit-vector will be a solution \\(x\\) to the system \\(A \\cdot x = b\\). The solution may or may not be unique.\nIf there is a problem, the return value will be a [std::nullopt]. This happens if the system of equations has no solution. It will also be the case if A is not square or if the size of b is not the same as the number of rows in A.\n\n\n\n\n\n\nThe concept\n\n\n\nThe idea here is to get one solution for a system of equations with the least possible fuss. + Over \\(\\FF\\), any free variable can take on one of the two values 0 and 1. Hence, if the system is consistent and has \\(f\\) free variables, it will have \\(2^f\\) possible solutions. So, a consistent system will have a unique solution only if \\(A\\) has full-rank. The [gauss::operator(i)] method iterates through potentially non-unique solutions if that is required.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint\nmain()\n{\n    std::size_t m = 12;\n\n    auto A = bit::matrix&lt;&gt;::random(m);\n    auto b = bit::vector&lt;&gt;::random(m);\n    auto x = bit::solve(A, b);\n\n    if(x) {\n        // Check that x is indeed a solution by computing A.x and comparing that to b\n        auto Ax = bit::dot(A, *x);\n        std::cout &lt;&lt; \"bit::matrix A, solution vector x, product A.x, and right hand side b\\n\";\n        bit::print(A, *x, Ax, b);\n        std::cout &lt;&lt; \"So A.x == b? \" &lt;&lt; (Ax == b ? \"YES\" : \"NO\") &lt;&lt; '\\n';\n    }\n    else {\n        std::cout &lt;&lt; \"System A.x = b has NO solutions for A and b as follows\\n\";\n        bit::print(A, b);\n    }\n}\nOutput for a consistent system (details depend on the values of the random inputs)\nbit::matrix A, solution vector x, product A.x, and right hand side b\n011000011001    0       0       0\n000100011010    0       0       0\n100001011010    0       0       0\n111111010000    1       1       1\n101011100101    1       1       1\n100001111100    1       0       0\n111100111110    0       0       0\n101111011010    0       0       0\n111100010110    1       1       1\n011011010000    0       0       0\n010011100101    0       1       1\n000111101001    1       1       1\nSo A.x == b? YES\nOutput for an inconsistent system (details depend on the values of the random inputs)\nSystem A.x = b has NO solutions for A and b as follows\n110000000111    0\n011111100001    1\n011111000101    0\n110110111011    1\n100111001101    0\n000010010010    1\n001110011110    0\n100010000001    0\n110001110110    1\n000100100010    0\n001101100010    0\n000000110000    0\n\nSee Also\n[gauss::operator()]\n[gauss::operator(i)]\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/faq/index.html",
    "href": "content/faq/index.html",
    "title": "FAQ",
    "section": "",
    "text": "This eventually will be a list of FAQ’s\n\n\n\n Back to top"
  },
  {
    "objectID": "content/bit_assert/index.html",
    "href": "content/bit_assert/index.html",
    "title": "Assertions",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]",
    "crumbs": [
      "Home",
      "Debugging",
      "Assertions"
    ]
  },
  {
    "objectID": "content/bit_assert/index.html#introduction",
    "href": "content/bit_assert/index.html#introduction",
    "title": "Assertions",
    "section": "Introduction",
    "text": "Introduction\nThe bit_assert.h header has two replacements for the standard assert macro — they allow for an additional string output that you can use to print the values of the variables that triggered any failure.\n1bit_debug_assert(condition, message)\n2bit_always_assert(condition, message)\n\n1\n\nAssertions of this type are only verified if you set the BIT_DEBUG flag at compile time.\n\n2\n\nAssertions of this type are always verified and cannot be turned off with a compiler flag.\n\n\nAssuming an assertion is “on,” in all cases, if condition evaluates to false, we print an error message to std::cerr, and the program will exit.\nThe error message always includes the location of the failure and an extra dynamic payload typically used to print the values of the variables that triggered the failure. The payload can be anything that can be formatted using the facilities in std::format.\n\n\n\n\n\n\nCompiler Flag\n\n\n\nIf you set the BIT_DEBUG flag, the library will perform demanding but potentially useful safety assertions on indices, size equality checks, etc. Otherwise all the bit_debug_assert calls are no-ops.\n\n\n\n\n\n\n\n\nMicrosoft compiler\n\n\n\nMicrosoft’s old traditional preprocessor is not happy with these macros, but their newer cross-platform compatible one is fine. Add the /Zc:preprocessor flag to use that upgrade at compile time. Our CMake module compiler_init does that automatically for you.",
    "crumbs": [
      "Home",
      "Debugging",
      "Assertions"
    ]
  },
  {
    "objectID": "content/bit_assert/index.html#examples",
    "href": "content/bit_assert/index.html#examples",
    "title": "Assertions",
    "section": "Examples",
    "text": "Examples\nExample — Snippet from the bit::vector&lt;&gt;::set method\n/// @brief Set the element at index `i` to 1.\nconstexpr bit::vector &set(std::size_t i)\n{\n    bit_debug_assert(i &lt; m_size, \"index `i` = \" &lt;&lt; i &lt;&lt; \" must be &lt; `m_size` which is \" &lt;&lt; m_size);\n    ...\n}\nHere m_size is holds the size of the vector — so we must have i &lt; m_size\nTo check every element access, set the BIT_DEBUG flag during compiles. If the assertion fails, the program exits with an error message that gives the offending values.\nThe bit_debug_assert line expands to nothing if the BIT_DEBUG flag is not set during compiles.\nExample — Message from an assertion failure\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    std::size_t n = 12;\n    bit::vector&lt;&gt; v(n);\n2    v.set(n);\n    std::cout &lt;&lt; v &lt;&lt; \"\\n\";\n}\n\n1\n\nConstruct a vector of size 12 and then attempt to set the “last” element.\n\n2\n\nA deliberate but typical off-by-one index error as the valid indices are from 0 to n-1, which is 11.\n\n\nCompile the sample program with the BIT_DEBUG flag set and get:\nOutput\nBIT ASSERTION FAILURE:\nFunction 'set' (vector.h, line 910):\nStatement 'i &lt; m_size' is NOT true: Index i = 12 must be &lt; `m_size` = 12\nThe program will then exit.",
    "crumbs": [
      "Home",
      "Debugging",
      "Assertions"
    ]
  },
  {
    "objectID": "content/bit_assert/index.html#design-rationale",
    "href": "content/bit_assert/index.html#design-rationale",
    "title": "Assertions",
    "section": "Design Rationale",
    "text": "Design Rationale\n\nbit_debug_assert\nIn the development cycle, it can be helpful to range-check indices and so on. However, those checks are expensive and can slow down numerical code by orders of magnitude. Therefore, we don’t want there to be any chance that those verifications are accidentally left “on” in the production code. The bit_debug_assert(...) form covers this type of verification. Turning on these checks requires the programmer to take a specific action — namely, she must set the BIT_DEBUG flag during compile time.\nFor example, here is a pre-condition from a hypothetical dot(Vector u, Vector v) function:\nbit_debug_assert(u.size() == v.size(), \"Vector sizes {} and {} DO NOT match!\", u.size(), v.size());\nThis code checks that the two vector arguments have equal length — a necessary constraint for the dot product operation to make sense. If the requirement is not satisfied, the code will exit with an informative message that includes the size of the two vectors.\nThe check here is off by default, and you need to do something special (i.e., define the BIT_DEBUG flag at compile time) to enable it. The idea is that production code may do many of these dot products, and we do not generally want to pay for the check. However, enabling these sorts of checks may be very useful during development.\nThe bit_debug_assert(...) macro expands to nothing unless you set the BIT_DEBUG flag at compile time.\n\n\nbit_always_assert\nThere may be other checks you never want to be turned off. The bit_always_assert(...) form accomplishes those tasks — it is unaffected by compiler flags.\nFor example, a pre-condition for a matrix inversion method is that the input matrix must be square. Here is how we do that check in an invert(const Matrix& M) function:\nbit_always_assert(M.is_square(), \"Cannot invert a {} x {} NON-square matrix!\", M.rows(), M.cols());\nWe can only invert square matrices. The M.is_square() call checks that condition and, on failure, exits the program with a helpful message.\nHere the cost of the check is very slight compared to the work done by the invert(...) method, so leaving it on even in production code is not a problem.\nThe decision to use one form vs. the other depends on the cost of doing the check versus the work done by the method in question. A primary use case for bit_debug_assert is to do things like bounds checking on indices — from experience, this is vital during development. However, bounds-checking every index operation incurs a considerable performance penalty and can slow down numerical code by orders of magnitude. So it makes sense to have the checks in place for development but to ensure they are never there in release builds.\nThe first form, bit_debug_assert(...), covers these types of checks. Turning on bit_debug_assert asserts requires the programmer to take a specific action, namely, setting the BIT_DEBUG flag during compile time.\nOn the other hand, some assertions are relatively cheap, especially compared to the work done by the containing function. For example, a pre-condition for the matrix::invert method is that the input bit-matrix is square. There is probably no harm if we always do that assert, which is very cheap compared to the typical cost of inverting a bit-matrix. The second form, bit_always_assert(...), is suitable for those cheaper verifications.\n\n\n\n\n\n\nMacro-land\n\n\n\nWe are in macro land here, so there are no namespaces. Typically, macros have names in caps, but the standard assert does not follow that custom, so neither do these bit_assert macros.\n\n\n\n\nSee Also\nassert",
    "crumbs": [
      "Home",
      "Debugging",
      "Assertions"
    ]
  },
  {
    "objectID": "content/index.html",
    "href": "content/index.html",
    "title": "The bitLibrary",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]"
  },
  {
    "objectID": "content/index.html#introduction",
    "href": "content/index.html#introduction",
    "title": "The bitLibrary",
    "section": "Introduction",
    "text": "Introduction\nbit is a header-only C++ library for numerical work in bit-space which mathematicians call GF(2) or \\(\\FF\\), the simplest Galois field with just two elements 0 & 1. All arithmetic operations in bit-space are mod 2 so what starts in bit-space stays in bit-space.\nThe library provides vector and matrix classes for performing linear algebra in bit-space. The bit::vector class represents bit_vectors, and the bit::matrix class represents bit-matrices. The library also has a bit::polynomial class to represent bit-polynomials over \\(\\FF\\).\nThese classes are efficient and pack the individual bit elements into natural word blocks. You can size/resize the classes at run-time.\nBecause arithmetic operations in \\(\\FF\\) are mod 2, addition/subtraction becomes the XOR operation, and multiplication/division becomes the AND operation. The bit library uses those equivalences to efficiently perform most interactions on and between bit-vectors and bit-matrices by simultaneously working on whole blocks of elements.\nThe bit library provides a rich interface to set up and manipulate bit-vectors and bit-matrices in various ways. Amongst other things, the interface includes methods to solve systems of linear equations over \\(\\FF\\) and to look at the eigen-structure of bit-matrices. The bit::polynomial class has methods to compute \\(x^N\\bmod{P(x)}\\) where \\(P(x)\\) is a polynomial over \\(\\FF\\) and \\(N\\) is a potentially huge integer."
  },
  {
    "objectID": "content/index.html#installation",
    "href": "content/index.html#installation",
    "title": "The bitLibrary",
    "section": "Installation",
    "text": "Installation\nThis library is header-only, so there is nothing to compile & link–drop the bit include directory somewhere convenient, and you are good to go.\nAlternatively, if you are using CMake, you can use the standard FetchContent module by adding a few lines to your project’s CMakeLists.txt file:\ninclude(FetchContent)\nFetchContent_Declare(bit URL https://github.com/nessan/bit/releases/download/current/bit.zip)\nFetchContent_MakeAvailable(bit)\nThis command downloads and unpacks an archive of the current version of bit to your project’s build folder. You can then add a dependency on bit::bit, a CMake alias for bit. FetchContent will automatically ensure the build system knows where to find the downloaded header files and any needed compiler flags.\nUsed like this, FetchContent will only download a minimal library version without any redundant test code, sample programs, documentation files, etc.\n\n\n\n\n\n\nLibrary versions\n\n\n\nThe shown URL gets the current version of the library—whatever is in the main branch. For a fixed, stable library version (say release 2.0.0), use a URL parameter like: https://github.com/nessan/bit/releases/download/2.0.0/bit.zip."
  },
  {
    "objectID": "content/index.html#example",
    "href": "content/index.html#example",
    "title": "The bitLibrary",
    "section": "Example",
    "text": "Example\nHere is a simple example of a program that uses bit:\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    auto M = bit::matrix&lt;&gt;::random(6, 6);\n2    auto c = bit::characteristic_polynomial(M);\n    std::cout &lt;&lt; std::format(\"Bit-matrix M:\\n{:p}\\n\", M);\n    std::cout &lt;&lt; std::format(\"Characteristic poly c(x) = {}\\n\", c);\n3    std::cout &lt;&lt; std::format(\"c(M) yields:\\n{:p}\\n\", c(M));\n}\n\n1\n\nCreates a random \\(6\\times6\\) bit-matrix \\(M\\) where 0 & 1 are equally likely to occur.\n\n2\n\nComputes its characteristic polynomial \\(c(x) = c_0 + c_1 x + c_2 x^2 + ... + c_6 x^6\\).\n\n3\n\nVerifies that \\(M\\) satisfies its own characteristic equation \\(c(M) = 0\\), as expected from the Cayley Hamilton theorem.\n\n\nSample Output (varies from run to run):\nBit-matrix M:\n│1 1 0 1 1 0│\n│0 0 0 0 0 1│\n│0 1 1 1 0 0│\n│0 0 0 1 0 1│\n│1 1 1 0 1 0│\n│1 0 0 1 1 1│\nCharacteristic poly c(x) = x^1 + x^2 + x^3 + x^5 + x^6\nc(M) yields:\n│0 0 0 0 0 0│\n│0 0 0 0 0 0│\n│0 0 0 0 0 0│\n│0 0 0 0 0 0│\n│0 0 0 0 0 0│\n│0 0 0 0 0 0│\n\n\n\n\n\n\nThe special nature of \\(\\FF\\)\n\n\n\nbit makes it possible to quickly extract the characteristic polynomial for a bit-matrix with millions of elements—​a problem that chokes a naive implementation that does not consider the special nature of arithmetic in \\(\\FF\\)."
  },
  {
    "objectID": "content/index.html#why-use-bit",
    "href": "content/index.html#why-use-bit",
    "title": "The bitLibrary",
    "section": "Why Use bit?",
    "text": "Why Use bit?\nThe standard library already has std::bitset, an efficient bitset class that is familiar and well thought through, so our bit::vector class replicates and extends much of that interface.\nAll std::bitset objects have a fixed size determined at compile time. The well-known Boost library does add a dynamic version boost::dynamic_bitset, where the bitset size can be set and changed at runtime.\nHowever, as the two names suggest, those types are aimed at bitsets instead of bit-vectors. So, for example, they print in bit-order with the least significant element/bit on the right. More importantly, those classes don’t have any particular methods aimed at linear algebra. Neither does the standard library’s vector class std::vector.\nOn the other hand, several well-known linear algebra libraries, such as Eigen, exist. Those packages efficiently manage all the standard numeric types (floats, doubles, integers, etc.) but do not correctly handle \\(\\FF\\). You can create matrices of integers where all the elements are 0 or 1, but there is no built-in knowledge in those libraries that arithmetic is mod 2.\nFor example, you might use Eigen to create an integer matrix of all 0’s and 1’s and then use a built-in function from that library to extract the characteristic polynomial. Modding the coefficients of that polynomial with 2 gets the appropriate version for \\(\\FF\\). Technically, this works, but you will have overflow problems for even relatively modest-sized matrices with just a few hundred rows and columns. Of course, you might use an underlying BitInt type that never overflows, but the calculations become dog slow for larger bit-matrices, which doesn’t help much.\nFor linear algebra problems over \\(\\FF\\), this specialized bit library is a better way to go and one to consider if, for example, your interest is in some areas of cryptography or random number generation."
  },
  {
    "objectID": "content/index.html#documentation",
    "href": "content/index.html#documentation",
    "title": "The bitLibrary",
    "section": "Documentation",
    "text": "Documentation\nThe project’s source code repository is here.\nYou can read the project’s documentation here.\nThe documentation site was generated using Quarto.\n\nContact\nYou can contact me by email here.\n\n\nCopyright and License\nCopyright (c) 2022-present Nessan Fitzmaurice.\nYou can use this software under the MIT license."
  },
  {
    "objectID": "content/gauss/queries.html",
    "href": "content/gauss/queries.html",
    "title": "bit::gauss — System Queries",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe supply methods to access the information that a gauss object can provide for the system \\(A \\cdot x = b\\).\n1constexpr std::size_t equation_count() const;\n2constexpr bool        is_consistent()  const;\n3constexpr std::size_t free_count()     const;\n4constexpr std::size_t solution_count() const;\n5constexpr std::size_t rank()           const;\n\n1\n\nReturns the number of equations in the system (the number of rows in \\(A\\)).\n\n2\n\nReturns true if the system of equations is consistent. If the system is not consistent, then there are no solutions.\n\n3\n\nReturns the number of free variables in the system.\n\n4\n\nReturns the number of solutions to the system we can directly address.\n\n5\n\nReturns the rank of the bit-matrix \\(A\\).\n\n\nGenerally, if the system is consistent (so has at least one solution) with \\(m\\) independent equations for \\(n\\) unknowns and \\(n&gt;m\\), then it has \\(f = n-m\\) free variables.\nA gauss object transforms (a copy of) \\(A\\) into reduced row echelon form, which allows it to check whether or not the system is consistent quickly and to compute just how many independent equations there really are in the system and hence compute \\(f\\).\nThe rank of \\(A\\) is \\(n - f\\).\nOver \\(\\R\\), a free variable can take on any value. Hence, there are an infinite number of possible solutions to the system. Over \\(\\FF\\), the situation is different because a free variable can only take on one of the values 0 and 1. Hence, if the system is consistent and has \\(f\\) free variables, it will have \\(2^f\\) possible solutions. So, if no free variables exist, a consistent system will have one unique solution.\nIf \\(f\\) is large, the number of possible solutions is explosively large! We supply a method [gauss::op(i)]to address quite a lot of those in an indexed manner. The solution_count() method gives you the number of solutions we can access that way — it will return 0 for an inconsistent system, 1 for a full-rank system, and \\(\\min(2^f, 2^{63})\\) for the general case where there are some free variables (the \\(2^{63}\\) number assumes that std::size_t is a 64-bit integer).\nExample\n#include &lt;bit/bit.h&gt;\nint\nmain()\n{\n    std::size_t m = 12;\n\n    auto A = bit::matrix&lt;&gt;::random(m);\n    auto b = bit::vector&lt;&gt;::random(m);\n    std::cout &lt;&lt; \"Solving the system A.x = b for the following A & b:\\n\";\n    print(A, b);\n\n    // Create a solver object for the system\n    bit::gauss&lt;&gt; solver(A, b);\n\n    // Print some general information\n    std::cout &lt;&lt; \"Number of equations in the system: \" &lt;&lt; solver.equation_count() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Rank of the matrix A:              \" &lt;&lt; solver.rank()           &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Number of free variables:          \" &lt;&lt; solver.free_count()     &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Number of solutions to A.x = b:    \" &lt;&lt; solver.solution_count() &lt;&lt; '\\n';\n}\nOutput (depends on the values of the random inputs)\nSolving the system A.x = b for the following A & b:\n101100101100    1\n111100010101    0\n100101011000    0\n111100101000    0\n011011111000    0\n110001110100    1\n110011011001    1\n110100010011    1\n000110101001    1\n110001011000    0\n110111010010    0\n100000010011    1\nNumber of equations in the system: 12\nRank of the matrix A:              10\nNumber of free variables:          2\nNumber of solutions to A.x = b:    4\n\nSee Also\ngauss::operator()\ngauss::operator(i)\nbit::solve\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/gauss/functor.html",
    "href": "content/gauss/functor.html",
    "title": "bit::gauss — Solution Access",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods that find solutions for the system \\(A \\cdot x = b\\).\n1bit::vector operator()() const;\n2bit::vector operator()(std::size_t i) const;\n\n1\n\nReturn a random solution amongst all the possible solutions for the system \\(A \\cdot x = b\\).\n\n2\n\nReturn a specific solution (solution number i if you like) for the system \\(A \\cdot x = b\\).\n\n\n\n\n\n\n\n\nBeware of systems with no solutions\n\n\n\nBoth these methods throw an exception if the system has no solutions. You can avoid that by first calling the gauss::solution_countmethod.\n\n\nIf the system is consistent (so at least one solution) with \\(m\\) independent equations for \\(n\\) unknowns and \\(n &gt; m\\), then it has \\(f = n-m\\) free variables.\nA gauss object transforms (a copy of) \\(A\\) into reduced row echelon form, which allows it to check whether or not the system is consistent quickly and to compute just how many independent equations there really are in the system and hence compute \\(f\\).\nOver \\(\\FF\\), a free variable can take on one of the two values 0 and 1. Hence, if the system is consistent and has \\(f\\) free variables, it will have \\(2^f\\) possible solutions. So, if no free variables exist, a consistent system will have one unique solution.\nIf \\(f\\) is large, the number of possible solutions is explosively large! The first call above will always get you one of those randomly picked solutions. Successive calls may return different solutions.\nThe second call above allows you to address (a large number of) the possible solutions in an indexed manner. The solution_count() method gives you the number of solutions we can access this way. It will return 0 for an inconsistent system, 1 for a full-rank system, and \\(\\min(2^f, 2^{63})\\) for the general case where there are some free variables (the \\(2^{63}\\) number assumes that std::size_t is a 64-bit integer).\nIf solver is our gauss object, then the call solver(n) will return solution “number” n where n is one of those addressable solutions.\n\n\n\n\n\n\nRange checking\n\n\n\nThe n must be less than gauss::solution_countor an exception is thrown.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint\nmain()\n{\n    std::size_t m = 12;\n\n    auto A = bit::matrix&lt;&gt;::random(m);\n    auto b = bit::vector&lt;&gt;::random(m);\n    std::cout &lt;&lt; \"Solving the system A.x = b for the following A & b:\\n\";\n    print(A, b);\n\n    // Create a solver object for the system\n    bit::gauss&lt;&gt; solver(A, b);\n\n    // Print some general information\n    std::size_t num_solutions = solver.solution_count();\n    std::cout &lt;&lt; \"Number of equations in system:   \" &lt;&lt; solver.equation_count() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Rank of the matrix A:            \" &lt;&lt; solver.rank()           &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Number of free variables:        \" &lt;&lt; solver.free_count()     &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Number of solutions to A.x = b:  \" &lt;&lt; num_solutions           &lt;&lt; '\\n';\n\n    // Iterate through all the solutions we can address & check each one is an actual solution\n    for (std::size_t ns = 0; ns &lt; num_solutions; ++ns) {\n        auto x = solver(ns);\n        auto Ax = bit::dot(A, x);\n        std::cout &lt;&lt; \"Solution: \" &lt;&lt; x &lt;&lt; \" has A.x = \" &lt;&lt;  Ax &lt;&lt; \" \";\n        std::cout &lt;&lt; (b == Ax ? \"matches rhs b.\" : \"DOES NOT match rhs b!!!\") &lt;&lt; \"\\n\";\n    }\n\n    // Maybe there were no solutions?\n    if (num_solutions == 0) std::cout &lt;&lt; \"This system is inconsistent and has NO solutions!\\n\";\n}\nOutput for a consistent system (details depends on the values of the random inputs)\nSolving the system A.x = b for the following A & b:\n101010000100    1\n110100000110    1\n110001101001    0\n000100111010    1\n101100110000    1\n101000010110    1\n011000100110    0\n101011110000    0\n001001111111    1\n001100101111    1\n111101001000    1\n111111101101    1\nNumber of equations in system:   12\nRank of the matrix A:            11\nNumber of free variables:        1\nNumber of solutions to A.x = b:  2\nSolution: [0 0 0 0 1 0 1 0 1 0 1 0] has A.x = [1 1 0 1 1 1 0 0 1 1 1 1] matches rhs b.\nSolution: [1 0 1 1 1 1 0 0 1 0 1 1] has A.x = [1 1 0 1 1 1 0 0 1 1 1 1] matches rhs b.\nOutput for an inconsistent system (details depends on the values of the random inputs)\nSolving the system A.x = b for the following A & b:\n111011010010    1\n001110000011    1\n011110000001    1\n001001011111    1\n110001101011    1\n100111110011    0\n001101100010    1\n010000010101    1\n110011001100    1\n110011100100    1\n001011111111    0\n010010111001    1\nNumber of equations in system:   12\nRank of the matrix A:            10\nNumber of free variables:        2\nNumber of solutions to A.x = b:  0\nThis system is inconsistent and has NO solutions!\n\nSee Also\nbit::solve\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/gauss/constructors.html",
    "href": "content/gauss/constructors.html",
    "title": "bit::gauss — Construction",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\n1gauss(const bit::matrix &A, const bit::vector &b);\n\ngauss\n2gauss_for(const bit::matrix &A, const bit::vector &b);\n\n1\n\nInstance constructor.\n\n2\n\nNon-member factory constructor.\n\n\nThese construct a gauss object for the system \\(A \\cdot x = b\\) where \\(A\\) is a square bit-matrix, and \\(b\\) is a bit-vector of the same size as there are rows in \\(A\\).\nOn construction, a gauss computes the reduced row-echelon form of \\(A\\) by using elementary row operations. It performs the same operations to a copy of the input bit-vector \\(b\\). Once done, it can readily compute the rank of \\(A\\), check the system for consistency, calculate the number of free variables, etc.\n\n\n\n\n\n\nEfficiency\n\n\n\nIf \\(A\\) is \\(n \\times n\\), then construction is an \\(\\mathcal{O}(n^3)\\) operation (though due to the nature of \\(\\FF\\), things are done in blocks at a time). There are potentially sub-cubic ways of doing this work using various block-iterative methods that have not yet been implemented.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint\nmain()\n{\n    std::size_t m = 12;\n\n    auto A = bit::matrix&lt;&gt;::random(m);\n    auto b = bit::vector&lt;&gt;::random(m);\n    std::cout &lt;&lt; \"Solving the system A.x = b for the following A & b:\\n\";\n    print(A, b);\n\n    // Create a solver object for the system\n    auto solver = bit::gauss(A, b);\n\n    // Print some general information\n    std::cout &lt;&lt; \"Number of equations in the system: \" &lt;&lt; solver.equation_count() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Rank of the matrix A:              \" &lt;&lt; solver.rank()           &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Number of free variables:          \" &lt;&lt; solver.free_count()     &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Number of solutions to A.x = b:    \" &lt;&lt; solver.solution_count() &lt;&lt; '\\n';\n\n    // Also have a look at the echelon form of A and the equivalently transformed b\n    std::cout &lt;&lt; \"The echelon forms of A & b are:\\n\";\n    print(solver.lhs(), solver.rhs());\n}\nOutput (depends on the values of the random inputs)\nSolving the system A.x = b for the following A & b:\n011100100101    0\n000111011100    1\n111101000011    1\n010000111110    1\n110011110000    1\n101100100100    1\n011010110010    0\n010010000111    1\n101110110001    0\n001100101110    1\n100000011010    1\n111111010100    1\nNumber of equations in the system: 12\nRank of the matrix A:              11\nNumber of free variables:          1\nNumber of solutions to A.x = b:    2\nThe echelon forms of A & b are:\n100000000000    1\n010000000000    0\n001000000000    1\n000100000000    0\n000010000100    0\n000001000000    0\n000000100100    1\n000000010000    1\n000000001000    0\n000000000010    1\n000000000001    0\n000000000000    0\n\n\n\n Back to top"
  },
  {
    "objectID": "content/notes/design.html",
    "href": "content/notes/design.html",
    "title": "Library Design Notes",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Library Design"
    ]
  },
  {
    "objectID": "content/notes/design.html#motivation",
    "href": "content/notes/design.html#motivation",
    "title": "Library Design Notes",
    "section": "Motivation",
    "text": "Motivation\nWe want bit to be an efficient linear algebra library for GF(2), also known as \\(\\FF\\), which is the set with just two elements 0 & 1. In \\(\\FF\\), all arithmetic operations are mod 2 to keep everything closed in the set \\(\\{0,1\\}\\).\nBecause arithmetic is always mod 2, addition/subtraction becomes the XOR operation while multiplication/division becomes AND. A primary goal of the bit library is to use those equivalences to perform most interactions on and between bit-vectors and bit-matrices very efficiently by working on whole blocks of elements at a time.\nOf course, there are already several very well-known linear algebra libraries in C++ such as Eigen. Those packages efficiently handle the standard numeric types (floats, doubles, integers, etc.), but none handle \\(\\FF\\) all that well. They will allow you to create vectors and matrices of integers where all the elements are 0 or 1, but there is no built-in knowledge in those libraries that arithmetic in \\(\\FF\\) is mod 2.\nFor example, you might use Eigen to create an integer matrix of all 0’s and 1’s and then use a built-in function from that library to extract the characteristic polynomial. Modding the coefficients of that polynomial with 2 gets the appropriate version for \\(\\FF\\). Technically, this works, but you will run into overflow problems for even relatively modest-sized matrices with just a few hundred rows and columns. You could use an underlying BitInt type that never overflows, but calculations will become dog slow for larger bit-matrices, which doesn’t help much.\nFor linear algebra problems over \\(\\FF\\), this specialized bit library is a better way to go and one to consider if, for example, your interest is in some areas of cryptography or random number generation.",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Library Design"
    ]
  },
  {
    "objectID": "content/notes/design.html#the-bit-vector-class",
    "href": "content/notes/design.html#the-bit-vector-class",
    "title": "Library Design Notes",
    "section": "The Bit-Vector Class",
    "text": "The Bit-Vector Class\nThe standard library already has std::bitset, an efficient bitset class. That class is familiar and well thought through, sp our bit::vector replicates and extends much of that primary interface.\nHowever, all std::bitset objects have a fixed size determined at compile time, which is too restrictive for our use case. The well-known Boost library adds a dynamic version boost::dynamic_bitset where the bitset size can be set and changed at runtime.\n\n\n\n\n\n\nDynamic sizing\n\n\n\nOur bit::vector class is also dynamically sized at runtime.\n\n\nThe types defined in the standard library and Boost are for bitsets instead of bit-vectors. For example, they print in bit-order with the least significant element/bit on the right.\nMore importantly, those classes don’t have any methods for linear algebra. Neither does the standard library’s vector class std::vector.\n\nStorage\nEach element in a bit-vector is either 0 or 1, so optimally, it should use a single bit of storage. In a bit::vector, we pack the individual bits into blocks where a block is some unsigned integer type that the user can choose.\nThe default is a 64-bit unsigned integer—the standard word size underlying many computer architectures. However, it might be that you are allocating a huge number of small bit-vectors, so the class lets you choose a smaller unsigned type for the storage blocks and even interpose a custom memory allocator so you might have code like:\nusing vector_type = bit::vector&lt;std::uint8_t&gt;;\nor even\nusing vector_type = bit::vector&lt;std::uint8_t, my_allocator&gt;;\nIn any case, there are just two data members in the bit::vector class:\n1std::size_t m_size = 0;\n2std::vector&lt;Block, Allocator&gt; m_block;\n\n1\n\nThe number of elements in this bit-vector.\n\n2\n\nThe elements are packed into a std::vector of blocks.\n\n\nThe number of blocks allocated depends on the size of the bit-vector.\nThe std::vector&lt;Block&gt; data member handles any memory allocations and de-allocations. These days, it is often the case in C++ that one can completely omit the need to manually manage memory using the new and delete operators and instead use one of the containers in the standard library.\n\n\n\n\n\n\nNote\n\n\n\nIn a bit::vector, if there are \\(d\\) binary digits in a block where by default \\(d = 64\\), then bit-vector element \\(v_i\\) is located at bit i%d of the block indexed i/d.\n\n\nRedundant storage It is worth pointing out that even though this is indeed a compact storage scheme for bit-vectors, some redundant bits are likely in our container of blocks.\nFor example, if \\(\\mathbf{v}\\) has, say, \\(75\\) elements, it will inevitably consume multiple words of storage. If we are using the defaults, then \\(\\mathbf{v}\\) will take up two 64-bit blocks, and hence there will be \\(2*64 - 75 = 53\\) bits of surplus storage.\nMost of the time, the space wasted in those extra bits is not material. If you create vast numbers, particularly of smaller bit-vectors, you can choose a different block type to minimize the wastage.\n\n\n\n\n\n\nRedundant bits need to be zeroed out\n\n\n\nNo matter which block type is employed, for efficiency’s sake, redundant bits must all be set to the value 0 initially and kept at 0 as the bit-vector is operated on.\n\n\n\n\nEfficiency\nThe primary efficiency in bit comes from the fact that most methods work block-by-block instead of element-by-element — a simple form of parallel processing. If you are using the default 64-bit blocks, then essentially, 64 elements in the bit-vector are operated on in a single instruction.\nFor example, the instance method to count the number of set bits in a bit::vector will look something like:\nconstexpr std::size_t count() const\n{\n    std::size_t sum = 0;\n    for (auto b : m_block) sum += std::popcount(b);\n    return sum;\n}\nThis code iterates through the blocks and uses a standard function to count the set bits in each one. It is much faster than iterating through all the individual elements/bits.\nMethods like this one only work because we carefully ensure that any redundant bits in the block representation of the bit-vector are all zeros. The class’s clean() instance method quickly sets the extra bits in the highest order block to zeros.\n\n\nA More Complex Example\nConsider a bit-vector \\(\\mathbf{v}\\) with \\(n\\) elements: \\[\n    \\mathbf{v} = \\lbrack v_0, v_1, \\ldots, v_{n-2}, v_{n-1} \\rbrack.\n\\] The \\(n\\) elements are packed into \\(m \\lt n\\) blocks where each block has \\(d\\) binary digits. The layout has the form: \\[\n    \\newcommand {\\bar}  {\\;\\bigg\\rvert\\;}\n    \\mathbf{v} \\sim \\bar 0 \\ldots 0 b_{n-1} \\ldots \\bar \\ldots \\bar b_{2d-1} b_{2d-2} \\ldots b_{d+1} b_d \\bar b_{d-1} b_{d-2} \\ldots b_1 b_0.\n\\] Here, we denote the word boundaries by vertical bars and the individual bits by \\(b_{n-1} b_{n-2} \\ldots b_1 b_0\\) where element \\(v_i \\rightarrow b_i\\). We also show that the highest-order block may be left padded with zeros.\nNow consider a block-by-block algorithm for shifting a bit-vector by some places to the right.\nThe single block of storage case: Start with the straightforward example of a three element bit-vector \\(\\mathbf{v} = [v_0, v_1, v_2]\\) which we shift right one place \\(\\mathbf{v}\\) to get: \\[\n    \\mathbf{v} \\gg 1 = [0, v_0, v_1],\n\\] i.e., we push the last element \\(v_2\\) out of the bit-vector on the right and push in a zero on the left.\nIf we are using 8-bit blocks, then \\(\\mathbf{v}\\) fits in a single block with 5 bits to spare \\(\\mathbf{v} \\sim 0 0 0 0 0 b_2 b_1 b_0\\). Similarly, \\(\\mathbf{v} \\gg 1 \\sim 0 0 0 0 0 0 b_1 b_0 0\\).\nSo right shifting \\(\\mathbf{v}\\) is equivalent to left shifting the block representation of \\(\\mathbf{v}\\) to get \\(0 0 0 0 0 b_2 b_1 b_0 0\\) followed by a cleanup operation that zeros out that redundant bit at slot index 3.\nWhat happens if \\(\\mathbf{v}\\) needs multiple blocks of storage? Suppose that \\(n = 10\\) so \\(\\mathbf{v} = [v_0, v_1, \\ldots, v_8, v_9]\\) then the storage layout is \\[\n    \\mathbf{v} \\sim 0 0 0 0 0 0 b_9 b_8 \\bar b_7 b_6 \\ldots b_1 b_0.\n\\] Right shifting by one place pushes the elements of \\(\\mathbf{v}\\) one spot to the right. So \\(v_9\\) is pushed out, and an extra 0 is pushed in to yield \\(\\mathbf{v} \\gg 1 = [0, v_0, v_1, \\ldots, v_8]\\) with the storage layout \\[\n    \\mathbf{v} \\gg 1 \\sim 0 0 0 0 0 0 b_8 b_7 \\bar b_6 b_5 \\ldots b_0 0.\n\\] In the block representation, we left shift each block by 1. There is an added complication: for each higher-order block, we need to set its least significant bit to the value of the most significant bit in the block one slot down. And, of course, we have to do the usual cleanup operation on the highest-order block to zero out the redundant bits.\nNext, suppose we are right-shifting by two places: \\[\n    \\mathbf{v} \\gg 2 =  [0, 0, v_0, v_1, \\ldots, v_7] \\sim 0 0 0 0 0 0 b_7 b_6 \\bar b_5 b_4 \\ldots b_0 0 0.\n\\] So right shifting \\(\\mathbf{v}\\) by two slots is equivalent to left shifting each block by two places. There is an added step where the two least significant bits in each higher-order block are set to the two most significant bits in the next lower block. And, of course, we also need to zero out the redundant bits in the highest-order block.\nShifting by an arbitrary number of places: Each block has \\(d\\) binary digits. Shifting \\(\\mathbf{v}\\) by an arbitrary number of places, \\(p\\), to the right, can be split into two stages.\nIf \\(p\\) is large enough, we can start by first left-shifting whole blocks at once by \\(\\pi = p/d\\) slots. So for each block \\(B_k\\) we set \\(B_k \\leftarrow B_{k-\\pi}\\). That efficiently handles a large part of the shift for larger values of \\(p\\).\nWe then can finish by using the earlier ideas to shift \\(\\mathbf{v}\\) by less than a whole block \\(p \\% d\\) places.\n\n\n\n\n\n\nThe order matters\n\n\n\nWe need to be careful to do things in the correct order. In particular, for right shifts of bit-vectors, we are left shifting the bits we need to work through the block representation from the highest order index down.",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Library Design"
    ]
  },
  {
    "objectID": "content/notes/design.html#the-bit-matrix-class",
    "href": "content/notes/design.html#the-bit-matrix-class",
    "title": "Library Design Notes",
    "section": "The Bit-Matrix Class",
    "text": "The Bit-Matrix Class\nThere is just one data member in a bit::matrix\nstd::vector&lt;vector_type&gt; m_row;\nHere vector_type is just a shortcut for bit::vector&lt;Block, Allocator&gt;.\nSo a bit::matrix is stored in row-major mode where each row is a single bit::vector. Therefore, arranging computations to work row by row instead of column by column is typically much more efficient. The library’s many instance methods and free functions involving bit-matrices take this into account.\nRemember that our primary aim is doing linear algebra over \\(\\FF\\). If, instead, the aim was to minimize storage, one would store the bit-matrix as a single long bit-vector with appropriate index operations. However, in that case, matrix operations would often need to be done element-by-element, which is much slower than doing things block-by-block as we do in bit.\nLike bit-vectors, bit-matrices are sized dynamically at runtime, and the row elements are packed into blocks of some unsigned integral type. That template parameter defaults to 64-bit words (it might be reasonable to use a smaller type if your use case involves the creation of many small matrices).\n\n\n\n\n\n\nSome methods only work on square matrices\n\n\n\nArbitrary \\(m \\times n\\) bit-matrices are supported, but some methods only make sense for square matrices where \\(n = m\\).\n\n\n\nAlternative Ideas\nApart from using column-major versus row-major mode, the other potentially sensible idea would be to base the whole library on bit-matrices where bit-vectors are either \\(n \\times 1\\) or \\(1 \\times n\\) bit-matrices.",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Library Design"
    ]
  },
  {
    "objectID": "content/notes/design.html#assertions",
    "href": "content/notes/design.html#assertions",
    "title": "Library Design Notes",
    "section": "Assertions",
    "text": "Assertions\nIn the development cycle, it can be helpful to confirm that indices are in bounds and perform other range checks. However, those checks are expensive and can slow down numerical code by orders of magnitude. We don’t want those verifications accidentally left “on” in our production code.\nFor this reason, we include our versions of the standard [std::assert] macro.\n\n\n\n\n\n\nAssertions have messages\n\n\n\nOur assertions come with the ability to print an explanation of what caused any failure.\n\n\nThe most commonly used form in the library is bit_debug_assert(...). This form expands to nothing unless the programmer sets the BIT_DEBUG flag at compile time. That is typically done automatically only for debug software builds and is never done for release/optimized builds.\nThere is also a version bit_always_assert(...) for checks that should always be carried out no matter what flags are passed to the compiler. Typically these are for assertions where the cost of the check is cheap compared to the cost of the work done in the method.",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Library Design"
    ]
  },
  {
    "objectID": "content/notes/gf2.html",
    "href": "content/notes/gf2.html",
    "title": "Working in GF(2)",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Working in GF(2)"
    ]
  },
  {
    "objectID": "content/notes/gf2.html#introduction",
    "href": "content/notes/gf2.html#introduction",
    "title": "Working in GF(2)",
    "section": "Introduction",
    "text": "Introduction\nbit is a header-only C++ library that provides classes for bit-vectors and bit-matrices.\nIn the jargon of professional mathematics, the classes make it possible to perform linear algebra over GF(2), the simplest Galois field with just two elements 0 & 1. In GF(2), also commonly known as \\(\\FF\\), addition/subtraction and multiplication/division operations are all done mod two, which keeps everything closed in the set {0,1}.\nThis document contains some technical notes on the joys and travails of mathematics using vectors and matrices where the elements are all just zeros and ones and where all arithmetic is mod 2.",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Working in GF(2)"
    ]
  },
  {
    "objectID": "content/notes/gf2.html#some-things-are-different",
    "href": "content/notes/gf2.html#some-things-are-different",
    "title": "Working in GF(2)",
    "section": "Some things are different!",
    "text": "Some things are different!\nOver \\(\\R\\), the only self-orthogonal vector is the zero vector.\nIf \\(\\mathbf{x}\\) is a vector over \\(\\R\\) then \\[\n\\mathbf{x} \\cdot \\mathbf{x} = 0 \\iff \\mathbf{x} = \\mathbf{0},\n\\] Put another way, the only vector of size 0 over \\(\\R\\) is the zero vector.\nThat is not true for vectors over \\(\\FF\\).\nFor example, if \\(\\mathbf{v} = \\{1, 1\\}\\) is thought of as a vector over \\(\\FF\\) then \\[\n\\mathbf{v} \\cdot \\mathbf{v} = \\{1, 1\\} \\cdot \\{1, 1\\} = 1 + 1 = 2 \\rightarrow 0 \\text{ mod 2}.\n\\] So \\(\\mathbf{v}\\) is non-zero but self-orthogonal.\nLet \\(\\mathbf{v}\\) be a general \\(n\\)-dimensional vector over \\(\\FF\\) then \\[\n\\mathbf{v} \\cdot \\mathbf{v} = v_1 v_1 + v_2 v_2 + \\cdots v_n v_n.\n\\] Now \\[\nv_i v_i =\n    \\begin{cases}\n        1 & \\text{if} & v_i = 1, \\\\\n        0 & \\text{if} & v_i = 0\n    \\end{cases}\n\\] It follows that \\[\n\\mathbf{v} \\cdot \\mathbf{v} = v_1 + v_2 + \\cdots v_n,\n\\] where of course those additions in \\(\\FF\\) are done modulo 2. Hence \\[\n\\mathbf{v} \\cdot \\mathbf{v} =\n    \\begin{cases}\n        0 & \\text{if the number of ones in the vector is even}, \\\\\n        1 & \\text{if the number of ones in the vector is odd}.\n    \\end{cases}\n\\] Half of all vectors over \\(\\FF\\) will be self-orthogonal!\n\n\n\n\n\n\nGram-Schmidt doesn’t work\n\n\n\nSome of the best-known algorithms for linear algebra over \\(\\R\\) rely on Gram-Schmidt. A critical step in Gram-Schmidt is to normalize a vector by simply dividing each element by the norm \\(\\lVert \\mathbf{x}  \\rVert = \\sqrt{\\mathbf{x} \\cdot \\mathbf{x}}\\). However, this will never work in \\(\\FF\\) as that norm will be zero 50% of the time. All those algorithms must be modified to work for vectors and matrices over \\(\\FF\\).",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Working in GF(2)"
    ]
  },
  {
    "objectID": "content/notes/gf2.html#some-things-are-simpler",
    "href": "content/notes/gf2.html#some-things-are-simpler",
    "title": "Working in GF(2)",
    "section": "Some things are simpler",
    "text": "Some things are simpler\nRecall that if \\(A x = b\\) represents a system of linear equations over \\(\\R\\), you can accomplish quite a lot using three elementary row operations.\n\nElementary Row Operations for \\(\\R\\)\n\nswap rows:\n\nSwap the positions of any two rows.\n\nscale row:\n\nMultiply a row by a non-zero number.\n\nadd or subtract rows:\n\nAdd one row to another row.\n\n\n\nHowever, in \\(\\FF\\), the only non-zero scalar is one, and addition is the same as subtraction, so for matrices over \\(\\FF\\), there are just two elementary row operations:\nElementary Row Operations for \\(\\FF\\)\n\nswap rows:\n\nSwap the positions of any two rows.\n\nadd rows:\n\nAdd one row to another row.",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Working in GF(2)"
    ]
  },
  {
    "objectID": "content/notes/gf2.html#gaussian-elimination-in-ff",
    "href": "content/notes/gf2.html#gaussian-elimination-in-ff",
    "title": "Working in GF(2)",
    "section": "Gaussian Elimination in \\(\\FF\\)",
    "text": "Gaussian Elimination in \\(\\FF\\)\nSuppose that \\(A\\) is an \\(n \\times n\\) matrix over \\(\\FF\\) and \\(b\\) is a compatibly sized bit-vector where we are interested in finding an \\(x\\) satisfying \\(A \\cdot x = b\\). Then the pseudocode for Gaussian elimination looks like:\n\n\n\\begin{algorithm} \\caption{Gaussian Elimination in $F_2$} \\begin{algorithmic} \\Procedure{Solve}{$A, b, n$} \\For {$j = 0$ \\To $n - 1$} \\State $s = j$ \\While {$A(s,j) = 0$} \\State $s = s + 1$ \\EndWhile \\If {$s &gt; n$} \\Continue \\EndIf \\If {$ s \\ne j$} \\State swap rows $s$ and $j$ in the matrix $A$ \\State swap elements $s$ and $j$ in the vector $b$ \\EndIf \\For {$i = j+1$ \\To $n$} \\If {$A(i,j) == 1$} \\State replace row $i$ in $A$ with the sum of rows $i$ and $j$ \\State replace element $i$ in $b$ with the sum of elements $i$ and $j$ \\EndIf \\EndFor \\EndFor \\EndProcedure \\end{algorithmic} \\end{algorithm}",
    "crumbs": [
      "Home",
      "Technical Notes",
      "Working in GF(2)"
    ]
  },
  {
    "objectID": "content/lu/queries.html",
    "href": "content/lu/queries.html",
    "title": "bit::lu — Queries",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe provide access to the information that a lu object can provide for the underlying bit-matrix \\(A\\).\n1constexpr bool        singular()      const;\n2constexpr bool        non_singular()  const;\n3constexpr bool        determinant()   const;\n4constexpr std::size_t rank()          const;\n\n1\n\nReturn true if the bit-matrix A is singular.\n\n2\n\nReturn true if the bit-matrix A is not singular.\n\n3\n\nReturn the determinant of the bit-matrix A.\n\n4\n\nReturns the rank of the bit-matrix A.\n\n\nThe LU Decomposition will work for any square bit-matrix and can be used to extract the rank of the bit-matrix. Some other methods in lu will fail for singular bit-matrices (no inversions possible, etc.)\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    std::size_t m = 12;\n\n    auto A = bit::matrix&lt;&gt;::random(m);\n    auto lu = bit::lu(A);\n    auto L = lu.L();\n    auto U = lu.U();\n    std::cout &lt;&lt; \"bit::matrix A, L, and U:\\n\";\n    bit::print(A, L, U);\n    std::cout &lt;&lt; \"A is singular? \" &lt;&lt; (lu.singular() ? \"YES\" : \"NO\") &lt;&lt; \"\\n\";\n\n    // Check that P.A = L.U\n    auto PA = A;\n    lu.permute(PA);\n    auto LU = bit::dot(L,U);\n    std::cout &lt;&lt; \"P.A and L.U:\\n\";\n    bit::print(PA, LU);\n    std::cout &lt;&lt; \"P.A == L.U? \" &lt;&lt; (PA == LU ? \"YES\" : \"NO\") &lt;&lt; \"\\n\";\n}\nOutput (depends on the values of the random inputs)\nbit::matrix A, L, and U:\n001111101100    100000000000    111001010000\n111001010000    110000000000    011001100000\n111000011010    001000000000    001111101100\n000111100101    000100000000    000111100101\n100000110000    101010000000    000010111010\n110110101110    100001000000    000001001010\n110100000110    101000100000    000000010010\n011100110101    011100010000    000000010100\n101101101111    111010001000    000000001001\n010101110011    011011001100    000000000110\n010001111101    010110001010    000000000011\n001001000011    001101000001    000000000000\nA is singular? YES\nP.A and L.U:\n111001010000    111001010000\n100000110000    100000110000\n001111101100    001111101100\n000111100101    000111100101\n110100000110    110100000110\n111000011010    111000011010\n110110101110    110110101110\n010001111101    010001111101\n101101101111    101101101111\n010101110011    010101110011\n011100110101    011100110101\n001001000011    001001000011\nP.A == L.U? YES\n\nSee Also\nlu::L\nlu::U\nlu::LU\nlu::row_swaps\nlu::permutation_vector\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/lu/functor.html",
    "href": "content/lu/functor.html",
    "title": "bit::lu — Solutions",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe can use the LU Decomposition of \\(A\\) to solve the system \\(A \\cdot x = b\\):\n1std::optional&lt;bit::vector&gt; operator()(const bit::vector &b) const;\n2std::optional&lt;bit::matrix&gt; operator()(const bit::matrix &B) const;\n\n1\n\nIf \\(A\\) is non-singular this solves the system \\(A \\cdot x = b\\).\n\n2\n\nIf \\(A\\) is non-singular this solves the systems \\(A \\cdot X = B\\).\n\n\nIn the second case, each column of the bit-matrix B is considered a separate right-hand side, and the corresponding column of \\(X\\) is the solution vector.\nOnce you have the LU Decomposition of \\(A\\), solving systems like these is relatively painless. If \\(A\\) is \\(n \\times n\\) each system solution takes just \\(\\mathcal{O}(n^2)\\) operations.\nThese methods return std::nullopt if the underlying bit-matrix \\(A\\) is singular. You can avoid that by first calling the lu::singular method.\n\n\n\n\n\n\nSize checking\n\n\n\nBoth methods throw an exception if the number of elements in \\(b\\) or rows in \\(B\\) does not match the number of rows in \\(A\\). They could instead return a std::nullopt, but a dimension mismatch is likely an indication of a coding error somewhere.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint\nmain()\n{\n    // Number of trials\n    std::size_t trials = 32;\n\n    // Each trial will run on a bit-matrix of this size\n    std::size_t N = 16;\n\n    // Number of non-singular matrices\n    std::size_t singular = 0;\n\n    // Start the trials\n    for (std::size_t n = 0; n &lt; trials; ++n) {\n\n        // Create a random matrix & vector\n        auto A = bit::matrix&lt;&gt;::random(N);\n        auto b = bit::vector&lt;&gt;::random(N);\n\n        // LU decompose the matrix & solve A.x = b\n        auto LU = bit::lu(A);\n        if (auto x = LU(b); x) {\n            auto Ax = bit::dot(A, *x);\n            std::cout &lt;&lt; \"x: \"   &lt;&lt; x-&gt;to_string() &lt;&lt; \"; \";\n            std::cout &lt;&lt; \"A.x: \" &lt;&lt; Ax.to_string() &lt;&lt; \"; \";\n            std::cout &lt;&lt; \"b: \"   &lt;&lt; b.to_string()  &lt;&lt; \"; \";\n            std::cout &lt;&lt; \"A.x == b? \" &lt;&lt; (Ax == b ? \"YES\" : \"NO\") &lt;&lt; \"\\n\";\n        }\n\n        // Count the number of singular matrices we come across\n        if (LU.singular()) singular++;\n    }\n\n    // Stats\n1    auto p = bit::matrix&lt;&gt;::probability_singular(N);\n    std::cout &lt;&lt; \"\\n\"\n              &lt;&lt; \"Singularity stats ...\\n\";\n    std::cout &lt;&lt; \"bit::matrix size: \" &lt;&lt; N &lt;&lt; \" x \" &lt;&lt; N &lt;&lt; \"\\n\"\n              &lt;&lt; \"P[singular]: \" &lt;&lt; 100 * p &lt;&lt; \"%\\n\"\n              &lt;&lt; \"Trials:      \" &lt;&lt; trials &lt;&lt; \"\\n\"\n              &lt;&lt; \"Singular:    \" &lt;&lt; singular &lt;&lt; \" times\\n\"\n              &lt;&lt; \"Expected:    \" &lt;&lt; int(p * double(trials)) &lt;&lt; \" times\\n\";\n    return 0;\n}\n\n1\n\nSee matrix::probability_singular\n\n\nOutput for a consistent system (details depend on the values of the random inputs)\nx: 0100010101110000; A.x: 0101011111010111; b: 0101011111010111; A.x == b? YES\nx: 0110111000000101; A.x: 0001100110100101; b: 0001100110100101; A.x == b? YES\nx: 1001000000111000; A.x: 0111110110111101; b: 0111110110111101; A.x == b? YES\nx: 1011010000110100; A.x: 0100001001010100; b: 0100001001010100; A.x == b? YES\nx: 0110100100110100; A.x: 1001111001100001; b: 1001111001100001; A.x == b? YES\nx: 0101000101111100; A.x: 1001100000011101; b: 1001100000011101; A.x == b? YES\nx: 0110000100100100; A.x: 0010100110010110; b: 0010100110010110; A.x == b? YES\nx: 1011001101010000; A.x: 0010011101110000; b: 0010011101110000; A.x == b? YES\nx: 1101101110001111; A.x: 0011010110110010; b: 0011010110110010; A.x == b? YES\nx: 0110101001101110; A.x: 1011010001011010; b: 1011010001011010; A.x == b? YES\nx: 1000011100010001; A.x: 0100111110001101; b: 0100111110001101; A.x == b? YES\n\nSingularity stats\nbit::matrix size: 16 x 16\nP[singular]: 71.1207%\nTrials:      32\nSingular:    21 times\nExpected:    22 times\n\nSee Also\nlu::singular\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/lu/invert.html",
    "href": "content/lu/invert.html",
    "title": "bit::lu — Invert a Bit-Matrix",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe can use the LU Decomposition of \\(A\\) to find \\(A^{-1}\\)\nstd::optional&lt;bit::matrix&gt; invert() const;\nThis returns std::nullopt if \\(A\\) is singular otherwise returns \\(A^{-1}\\).\nExample\n#include &lt;bit/bit.h&gt;\nint\nmain()\n{\n    // Number of trials\n    std::size_t trials = 100;\n\n    // Each trial will run on a bit-matrix of this size\n    std::size_t N = 30;\n\n    // Number of non-singular matrices\n    std::size_t singular = 0;\n\n    // Start the trials\n    for (std::size_t n = 0; n &lt; trials; ++n) {\n\n        // Create a random matrix & decompose it\n        auto A = bit::matrix&lt;&gt;::random(N);\n        auto LU = bit::lu(A);\n\n        // See if we can invert the matrix, and if so, check A.A_inv == I\n        if (auto A_inv = LU.invert(); A_inv) {\n            auto I = bit::dot(A, *A_inv);\n            std::cout &lt;&lt; \"A.Inverse[A] == I? \" &lt;&lt; (I.is_identity() ? \"YES\" : \"NO\") &lt;&lt; \"\\n\";\n        }\n\n        // Count the number of singular matrices we come across\n        if (LU.singular()) singular++;\n    }\n\n    // Stats\n1    auto p = bit::matrix&lt;&gt;::probability_singular(N);\n    std::cout &lt;&lt; \"\\n\"\n              &lt;&lt; \"Singularity stats ...\\n\";\n    std::cout &lt;&lt; \"bit::matrix size: \" &lt;&lt; N &lt;&lt; \" x \" &lt;&lt; N &lt;&lt; \"\\n\"\n              &lt;&lt; \"P[singular]: \" &lt;&lt; 100 * p &lt;&lt; \"%\\n\"\n              &lt;&lt; \"Trials:      \" &lt;&lt; trials &lt;&lt; \"\\n\"\n              &lt;&lt; \"Singular:    \" &lt;&lt; singular &lt;&lt; \" times\\n\"\n              &lt;&lt; \"Expected:    \" &lt;&lt; int(p * double(trials)) &lt;&lt; \" times\\n\";\n    return 0;\n}\n\n1\n\nSee matrix::probability_singular\n\n\nOutput for a consistent system (details depend on the random inputs)\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\nA.Inverse[A] == I? YES\n\nSingularity stats\nbit::matrix size: 30 x 30\nP[singular]: 71.1212%\nTrials:      100\nSingular:    68 times\nExpected:    71 times\n\nSee Also\nlu::singular\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/lu/constructors.html",
    "href": "content/lu/constructors.html",
    "title": "bit::lu — Constructors",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nConstruct a lu object either directly or using a factory function.\nThe object performs the LU Decomposition of an input square bit-matrix.\nlu(const bit::matrix &A);\nOn construction, the object finds a unit lower triangular bit-matrix \\(L\\), an upper triangular bit-matrix \\(U\\), and a permutation matrix \\(P\\) such that \\[\nP \\cdot A = L \\cdot U.\n\\] In practice, we pack the \\(L\\) and \\(U\\) matrices into a single bit-matrix of the same size as \\(A\\). The permutation matrix \\(P\\) is also stored compactly — see lu::permute.\nThe decomposition always works even if \\(A\\) is singular, but other lu methods will not.\n\n\n\n\n\n\nGeneralizations\n\n\n\nThere are generalizations of the LU Decomposition that handle rectangular matrices, but we have not implemented those yet.\n\n\n\n\n\n\n\n\nEfficiency\n\n\n\nIf \\(A\\) is \\(n \\times n\\), then construction is an \\(\\mathcal{O}(n^3)\\) operation (though due to the nature of \\(\\FF\\), things are done in blocks at a time). There are sub-cubic ways of doing this work using various block-iterative methods, but those methods have not been implemented here yet.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    std::size_t m = 12;\n\n    auto A = bit::matrix&lt;&gt;::random(m);\n    auto lu = bit::lu(A);\n    auto L = lu.L();\n    auto U = lu.U();\n    std::cout &lt;&lt; \"bit::matrix A, L, and U:\\n\";\n    bit::print(A, L, U);\n    std::cout &lt;&lt; \"A is singular? \" &lt;&lt; (lu.singular() ? \"YES\" : \"NO\") &lt;&lt; \"\\n\";\n\n    // Check that P.A = L.U\n    auto PA = A;\n    lu.permute(PA);\n    auto LU = bit::dot(L,U);\n    std::cout &lt;&lt; \"P.A and L.U:\\n\";\n    bit::print(PA, LU);\n    std::cout &lt;&lt; \"P.A == L.U? \" &lt;&lt; (PA == LU ? \"YES\" : \"NO\") &lt;&lt; \"\\n\";\n}\nOutput (depends on the values of the random inputs)\nbit::matrix A, L, and U:\n001111101100    100000000000    111001010000\n111001010000    110000000000    011001100000\n111000011010    001000000000    001111101100\n000111100101    000100000000    000111100101\n100000110000    101010000000    000010111010\n110110101110    100001000000    000001001010\n110100000110    101000100000    000000010010\n011100110101    011100010000    000000010100\n101101101111    111010001000    000000001001\n010101110011    011011001100    000000000110\n010001111101    010110001010    000000000011\n001001000011    001101000001    000000000000\nA is singular? YES\nP.A and L.U:\n111001010000    111001010000\n100000110000    100000110000\n001111101100    001111101100\n000111100101    000111100101\n110100000110    110100000110\n111000011010    111000011010\n110110101110    110110101110\n010001111101    010001111101\n101101101111    101101101111\n010101110011    010101110011\n011100110101    011100110101\n001001000011    001001000011\nP.A == L.U? YES\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/polynomial_mod.html",
    "href": "content/vector/polynomial_mod.html",
    "title": "bit::vector — Computing \\(x^N \\textrm{ mod } p(x)\\)",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nIf \\(p(x)\\) is an arbitrary polynomial over \\(\\FF\\) \\[\np(x) = p_{m-1} x^{m-1} + \\cdots + p_1 x + p_0.\n\\] Then for any power \\(N\\) we can write \\[\nx^N= q(x) p(x) + r(x)\n\\] where \\(q(x)\\) is some quotient polynomial and the degree of the remainder polynomial \\(r(x)\\) is strictly less than the degree of \\(p(x)\\).\nIn standard notation, we write \\[\nr(x) = x^N \\textrm{ mod } p(x).\n\\]\nWe have a function that computes the coefficients of the polynomial \\(r(x)\\).\nbit::vector\npolynomial_mod(std::size_t n, const bit::vector &p, bool is_exp = false);\nFor the sake of clarity, the usual template parameters are taken as read.\nThe elements of the input bit-vector p are the coefficients of a polynomial \\(p(x)\\).\nBy default, \\(N = n\\), but if the last argument is_exp is true, then \\(N = 2^n\\).\nThat allows us to handle large values of \\(N\\) that would overflow standard integer types, e.g., \\(N=2^{100}\\).\n\n\n\n\n\n\nEfficiency\n\n\n\nThe method works by repeated multiplication and squaring and is efficient for large values of \\(N\\).\n\n\n\n\n\n\n\n\nWhy would we ever need this?\n\n\n\nComputing \\(x^N \\textrm{ mod } p(x)\\) for very large \\(N\\) can be used to jump far ahead in the random number streams produced by many pseudorandom generators — see this paper.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    std::size_t N = 447'124'345;\n    auto        p = bit::vector&lt;&gt;::from(1234019u);\n    auto        r = bit::polynomial_mod(N, p);\n    std::cout &lt;&lt; \"r(x) = x^\" &lt;&lt; N &lt;&lt; \" mod p(x)\\n\";\n    std::cout &lt;&lt; \"p(x) = \" &lt;&lt; bit::polynomial(p) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"r(x) = \" &lt;&lt; bit::polynomial(r) &lt;&lt; '\\n';\n    return 0;\n}\nOutput\nr(x) = x^447124345 mod p(x)\np(x) = 1 + x^1 + x^5 + x^6 + x^10 + x^12 + x^14 + x^15 + x^17 + x^20\nr(x) = 1 + x^4 + x^7 + x^9 + x^10 + x^12 + x^16 + x^18 + x^19\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/swap_elements.html",
    "href": "content/vector/swap_elements.html",
    "title": "bit::vector — Swap Elements",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have a method to swap the values of two individual elements/bits in a bit-vector.\n1constexpr bit::vector &swap(std::size_t i, std::size_t j) const;\n\n1\n\nSwaps the values at element i and element j.\n\n\n\n\n\n\n\n\nRange checking\n\n\n\nBy default, the method does not check whether the indices are in bounds, and if they aren’t, the behavior is undefined (but bound to be bad)!\nSet the BIT_DEBUG flag at compile time to check this condition — any violation will cause the program to abort with a helpful message.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::vector&lt;&gt; v(2);\n    v(0) = 0; v(1) = 1;\n    std::cout &lt;&lt; \"Before swap v = \" &lt;&lt; v &lt;&lt; \"\\n\";\n    v.swap_elements(0,1);\n    std::cout &lt;&lt; \"After  swap v = \" &lt;&lt; v &lt;&lt; \"\\n\";\n}\nOutput\nBefore swap v = [0 1]\nAfter  swap v = [1 0]\n\nSee Also\nvector::swap\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/stream.html",
    "href": "content/vector/stream.html",
    "title": "bit::vector — Stream Operators",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\nMethods to insert or extract a bit-vector from a stream.\nThe input stream operator will throw a std::invalid_argument exception on parse failures."
  },
  {
    "objectID": "content/vector/stream.html#valid-strings",
    "href": "content/vector/stream.html#valid-strings",
    "title": "bit::vector — Stream Operators",
    "section": "Valid Strings",
    "text": "Valid Strings\n\nThere are two principal ways we can encode a bit-vector as a string:\n\nBinary String Encodings\nThe straightforward character encoding for a bit-vector is a binary string containing just 0’s and 1’s, e.g., “10101”. Each character in a binary string represents a single element in the bit-vector.\nBy default, we encode bit-vectors to binary strings in vector order \\(v_0 v_1  \\cdots v_{n-1}\\). However, methods that read or write binary strings typically have an extra boolean argument, bit_order. This argument always defaults to false, but if present and set to true, then the binary string will encode the bit-vector in bit-order where the least significant bit v0 is on the right so \\(v_{n-1} \\cdots v_1 v_0\\). Hex-strings ignore the bit_order parameter.\n\n\nHex String Encodings\nThe other supported encoding for bit-vectors is a compact hex type string containing just the 16 hex characters 0123456789ABCDEF. For example, the string “3ED02”. We allow for hex strings with an optional prefix “0x” or “0X,” e.g. “0x3ED02”.\nHex strings are not affected by a bit_order argument — we ignore that argument.\nEach hex character naturally translates to four elements in a bit::vector. The hex string 0x0 is equivalent to the binary string 0000, and so on, up to string 0xF which is the same as the binary 1111.\nThe hex pair 0x0F will be interpreted in the vector as 00001111. Of course, this is the advantage of hex. It is a more compact format that occupies a quarter of the space needed to write out the equivalent binary string.\nHowever, what happens if you want to encode a vector whose size is not a multiple of 4? We handle that by allowing the final character in the string to have a base that is not 16. To accomplish that, we allow for an optional suffix, which must be one of _2, _4, or _8. If present, the prefix gives the base for just the preceding character in the otherwise hex-based string. If there is no suffix, the final character is assumed to be hex like all the others.\nSo the string 0x1 (no suffix, so the last character is the default hex base 16) is equivalent to 0001. On the other hand, the string 0x1_8 (the last character is base 8) is equivalent to 001. Similarly, the string 0x1_4 (the last character is base 4) is equivalent to 01 and finally, the string 0x1_2 (the previous character is base 2) is comparable to 1\nIn the string 0x3ED01_8, the first four characters 3, E, D, and 0 are interpreted as hex values, and each will consume four slots in the vector. However, that final 1_8 is parsed as an octal 1, which takes up three slots 001. Therefore, this vector has size 19 (i.e., 4*4 + 3).\n\n\n\n\n\n\nCareful with that final suffix character\n\n\n\nIf the suffix is present, the final character must fit inside the base given by that suffix. The string 0x3_8 is OK, but trying to parse 0x3_2 will result in a std::nullopt return value because the final character is not either 0 or 1, which are the only valid options for something that is supposed to be base 2.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    // Read from a stream until we have a parse error ...\n    while (true) {\n        bit::vector&lt;&gt; v;\n        std::cout &lt;&lt; \"bit::vector? \";\n        try {\n            std::cin &gt;&gt; v;\n            std::cout &lt;&lt; \"Parsed as \" &lt;&lt; v &lt;&lt; std::endl;\n        }\n        catch (...) {\n            std::cout &lt;&lt; \"Couldn't parse that input as a bit::vector! Quitting ...\" &lt;&lt; std::endl;\n            break;\n        }\n    }\n}\n\nInput and Output:\nbit::vector? 111\nParsed as [1 1 1]\nbit::vector? 0b111\nParsed as [1 1 1]\nbit::vector? 0x111\nParsed as [1 0 0 0 1 0 0 0 1 0 0 0]\nbit::vector? 0x111_8\nParsed as [1 0 0 0 1 0 0 0 1 0 0]\nbit::vector? 0x111_4\nParsed as [1 0 0 0 1 0 0 0 1 0]\nbit::vector? 0x111_2\nParsed as [1 0 0 0 1 0 0 0 1]\nbit::vector? q\nCouldn't parse that input as a bit::vector! Quitting ...\n\n\n\nSee Also\nvector::to_string\nvector::to_bit_order\nvector::to_hex\nvector::formatter"
  },
  {
    "objectID": "content/vector/specials.html",
    "href": "content/vector/specials.html",
    "title": "bit::vector — Some Special Bit-Vectors",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nFactory methods to construct some special bit-vectors:\n1static constexpr bit::vector zeros(std::size_t n);\n2static constexpr bit::vector ones(std::size_t n);\n3static constexpr bit::vector unit(std::size_t n, std::size_t i);\n4static constexpr bit::vector checker_board(std::size_t n, int first = 1);\n\n1\n\nReturns a bit-vector of size n where all the elements are set to 0.\n\n2\n\nReturns a bit-vector of size n where all the elements are set to §.\n\n3\n\nReturns the i’th unit bit-vector of size n.\n\n4\n\nReturns a bit-vector of size n with a pattern that 1010101... or 0101010...\n\n\nThe \\(i^\\mathrm{th}\\) unit bit-vector of size \\(n\\) is all zeros apart from the i’th element, which is 1.\n\n\n\n\n\n\nBounds checking\n\n\n\nThe method unit(n, i) requires \\(i &lt; n\\). This condition is always checked unless the NDEBUG flag is set, as it generally is for release builds.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    std::size_t n = 16;\n\n    auto v0 = bit::vector&lt;&gt;::zeros(n);\n    auto v1 = bit::vector&lt;&gt;::ones(n);\n    auto v2 = bit::vector&lt;&gt;::checker_board(n, 1);\n    auto v3 = bit::vector&lt;&gt;::checker_board(n, 0);\n    std::cout &lt;&lt; \"All zeros:              \" &lt;&lt; v0 &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"All ones:               \" &lt;&lt; v1 &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Checker-board from 1:\\t\" &lt;&lt; v2 &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Checker-board from 0:\\t\" &lt;&lt; v3 &lt;&lt; \"\\n\";\n    // The unit vectors\n    for(std::size_t i = 0; i &lt; n; ++i)\n    {\n        auto u = bit::vector&lt;&gt;::unit(n, i);\n        std::cout &lt;&lt; \"Unit bit-vector \" &lt;&lt; i &lt;&lt; \":\\t\" &lt;&lt; u &lt;&lt; \"\\n\";\n    }\n}\nOutput\nAll zeros:              [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\nAll ones:               [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\nChecker-board from 1:   [1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0]\nChecker-board from 0:   [0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1]\nUnit bit-vector 0:      [1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\nUnit bit-vector 1:      [0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\nUnit bit-vector 2:      [0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0]\nUnit bit-vector 3:      [0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0]\nUnit bit-vector 4:      [0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0]\nUnit bit-vector 5:      [0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0]\nUnit bit-vector 6:      [0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0]\nUnit bit-vector 7:      [0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0]\nUnit bit-vector 8:      [0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0]\nUnit bit-vector 9:      [0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0]\nUnit bit-vector 10:     [0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0]\nUnit bit-vector 11:     [0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0]\nUnit bit-vector 12:     [0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0]\nUnit bit-vector 13:     [0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0]\nUnit bit-vector 14:     [0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0]\nUnit bit-vector 15:     [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1]\n\nSee Also\nvector::random\nvector::from\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/shift.html",
    "href": "content/vector/shift.html",
    "title": "bit::vector — Binary Shift Operators",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods to perform binary left and right shifts for the elements in a bit-vector — shifting in zeros as needed.\n1constexpr bit::vector &operator&lt;&lt;=(std::size_t p);\n2constexpr bit::vector &operator&gt;&gt;=(std::size_t p);\n\n3constexpr bit::vector operator&lt;&lt;(std::size_t p) const;\n4constexpr bit::vector operator&gt;&gt;(std::size_t p) const;\n\n1\n\nLeft-shift the elements of this bit-vector p places.\n\n2\n\nRight-shift the elements of this bit-vector p places.\n\n3\n\nReturns a bit-vector that is this one left shifted by p places\n\n4\n\nReturns a bit-vector that is this one right shifted by p places\n\n\nThe first two methods are destructive (i.e., operate in-place) and return a reference to *this, so can be chained with other calls.\nLike most things in the bit library, the methods operate on the elements of the bit-vector in vector-order. So if \\(v\\) is our bit-vector \\[\nv = \\left[v_0, v_1, \\ldots, v_{n-2}, v_{n-1} \\right],\n\\] then left shifting pushes out the element \\(v_0\\) and pushes in a new zero element on the right: \\[\nv \\ll 1 = \\left[v_1, \\ldots, v_{n-2}, v_{n-1}, 0 \\right].\n\\] Similarly, right shifting pushes out the element \\(v_{n-1}\\) and pushes in a new zero element on the left: \\[\nv \\gg 1 = \\left[0, v_0, v_1, \\ldots, v_{n-2}, \\right].\n\\]\n\n\n\n\n\n\nVector-order vs. bit-order\n\n\n\nThus, right shifts are equivalent to left shifts, considering the elements in bit-order. Similarly, the left shifts are equivalent to right shifts, considering the elements in bit-order.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto v = bit::vector&lt;&gt;::ones(12);\n\n    std::cout &lt;&lt; \"Left shift:\\n\";\n    std::cout &lt;&lt; \"v:        \" &lt;&lt; v         &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v &lt;&lt; 1:   \" &lt;&lt; (v &lt;&lt; 1)  &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v &lt;&lt; 4:   \" &lt;&lt; (v &lt;&lt; 4)  &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v &lt;&lt; 9:   \" &lt;&lt; (v &lt;&lt; 9)  &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v &lt;&lt; 13:  \" &lt;&lt; (v &lt;&lt; 13) &lt;&lt; '\\n';\n    std::cout &lt;&lt; '\\n';\n\n    std::cout &lt;&lt; \"Right shift:\\n\";\n    std::cout &lt;&lt; \"v:        \" &lt;&lt; v         &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v &gt;&gt; 1:   \" &lt;&lt; (v &gt;&gt; 1)  &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v &gt;&gt; 4:   \" &lt;&lt; (v &gt;&gt; 4)  &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v &gt;&gt; 9:   \" &lt;&lt; (v &gt;&gt; 9)  &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v &gt;&gt; 13:  \" &lt;&lt; (v &gt;&gt; 13) &lt;&lt; '\\n';\n    std::cout &lt;&lt; '\\n';\n}\nOutput\nLeft shift:\nv:        [1 1 1 1 1 1 1 1 1 1 1 1]\nv &lt;&lt; 1:   [1 1 1 1 1 1 1 1 1 1 1 0]\nv &lt;&lt; 4:   [1 1 1 1 1 1 1 1 0 0 0 0]\nv &lt;&lt; 9:   [1 1 1 0 0 0 0 0 0 0 0 0]\nv &lt;&lt; 13:  [0 0 0 0 0 0 0 0 0 0 0 0]\n\nRight shift:\nv:        [1 1 1 1 1 1 1 1 1 1 1 1]\nv &gt;&gt; 1:   [0 1 1 1 1 1 1 1 1 1 1 1]\nv &gt;&gt; 4:   [0 0 0 0 1 1 1 1 1 1 1 1]\nv &gt;&gt; 9:   [0 0 0 0 0 0 0 0 0 1 1 1]\nv &gt;&gt; 13:  [0 0 0 0 0 0 0 0 0 0 0 0]\n\nSee Also\nvector::operator&=\nvector::operator^=\nvector::operator|=\nvector::operator+=\nvector::operator-=\nvector::operator*=\nvector::operator~\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/reference.html",
    "href": "content/vector/reference.html",
    "title": "bit::vector::reference — Proxy Class",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\nbit::vector::reference is a publicly accessible nested proxy class that lets users interact with individual elements/bits in a bit-vector.\nIt is needed because standard C++ types cannot target down to the bit level of precision.\nThe primary use of this class is to provide an l-value that can be returned from operator[] and operator() in the bit::vector class."
  },
  {
    "objectID": "content/vector/reference.html#member-functions",
    "href": "content/vector/reference.html#member-functions",
    "title": "bit::vector::reference — Proxy Class",
    "section": "Member Functions",
    "text": "Member Functions\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nconstructor\nThe bit-vector methods operator[] and operator() automatically construct a bit::vector::reference as needed.\n\n\noperator=\nAssigns a bool to the referenced element.\n\n\noperator bool\nReturn the value of the referenced element.\n\n\nset\nSets the referenced element in the bit-vector to 1.\n\n\nreset\nSets the referenced element in the bit-vector to 0.\n\n\nset\nFlips the referenced element in the bit-vector from 1 to 0 and vice versa.\n\n\noperator&=\nLogical AND of the referenced element with a bool on the right-hand side.\n\n\noperator^=\nLogical XOR of the referenced element with a bool on the right-hand side.\n\n\noperator|=\nLogical OR of the referenced element with a bool on the right-hand side.\n\n\noperator-=\nLogical DIFF of the referenced element with a bool on the right-hand side.\n\n\noperator~\nFlips the value of the referenced element from 0 to 1 and vice versa.\n\n\n\n\n\nSee Also\nvector::element\nvector::operator[]\nvector::operator()\nvector::front\nvector::back"
  },
  {
    "objectID": "content/vector/riffled.html",
    "href": "content/vector/riffled.html",
    "title": "bit::vector — Riffling",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have instance methods that make a copy of the bit-vector with its elements interleaved with zeros.\nconstexpr bit::vector riffled() const;\nThis method creates a new bit-vector, a copy of the current bit-vector with interleaved zeros. For example, if the current bit-vector has elements [a b c d], the returned bit-vector will have elements [a 0 b 0 c 0 d].\nconstexpr void riffled(bit::vector& dst) const;\nThis method turns dst into a copy of the current bit-vector with interleaved zeros. For example, if the current bit-vector has elements [a b c d], then, on return, the dst bit-vector will have elements [a 0 b 0 c 0 d]. It is helpful for algorithms that require repeated riffling and where we want to reuse the dst storage.\n\n\n\n\n\n\nOne reason this might be useful\n\n\n\nIf you think of a bit-vector \\(\\mathbf{p}\\) as being the coefficients in a polynomial over \\(\\FF\\): \\[\np(x) = p_0 + p_1 x + p_2 x^2 + \\cdots\n\\] It is easy to verify that the polynomial \\(p(x)^2\\) has coefficients that are the riffled version of \\(\\mathbf{p}\\). For example, if \\(p(x) = a + bx\\) then \\[\np(x)^2 = a^2 + 2 a b x + b^2 x^2\n\\] In \\(\\FF\\), you drop all multiples of 2, and it follows that \\[\np(x)^2 = a + b x^2\n\\] The general case follows by induction.\n\n\nThe riffled version of a bit-vector of size \\(n \\ge 2\\) will have size \\(2n-1\\). The riffled version of a bit-vector of size \\(n &lt; 2\\) will be \\(n\\).\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    using vector_type = bit::vector&lt;std::uint8_t&gt;;\n    std::size_t N = 17;\n    auto u = vector_type::ones(N);\n    auto v = u.riffled();\n    std::cout &lt;&lt; \"u           = \" &lt;&lt; u &lt;&lt; \" has size \" &lt;&lt; u.size() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"u.riffled() = \" &lt;&lt; v &lt;&lt; \" has size \" &lt;&lt; v.size() &lt;&lt; '\\n';\n}\nOutput\nu           = [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1] has size 17\nu.riffled() = [1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1] has size 33\n\nSee Also\npolynomial::squared\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/capacity.html",
    "href": "content/vector/capacity.html",
    "title": "bit::vector — Storage Capacity",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nHow many elements can a bit-vector store in its current state?\n1constexpr std::size_t capacity() const;\n2constexpr std::size_t unused() const;\n\n1\n\nReturns the number of elements the bit-vector can store in its current state.\n\n2\n\nReturns the spare capacity in the bit-vector in its current state, i.e., capacity() - size().\n\n\nWe may not be using all the storage for some bit-vectors. For example, if we construct a small bit::vector with, say, eight elements and use the default Block of uint64_t, we will have at least a single storage block, so a capacity of 64. Thus, there are 56 spare slots — we can append 56 more elements to the vector before allocating more storage.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto v = bit::vector&lt;&gt;::checker_board(8);\n    std::cout &lt;&lt; \"bit::vector \"     &lt;&lt; v            &lt;&lt; \": \";\n    std::cout &lt;&lt; \"size \"            &lt;&lt; v.size()     &lt;&lt; \", \";\n    std::cout &lt;&lt; \"capacity \"        &lt;&lt; v.capacity() &lt;&lt; \", \";\n    std::cout &lt;&lt; \"unused capacity \" &lt;&lt; v.unused()   &lt;&lt; \".\\n\";\n}\nOutput\nbit::vector [0 1 0 1 0 1 0 1]: size 8, capacity 64, unused capacity 56\n\nSee Also\nvector::reserve\nvector::description\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/blocks.html",
    "href": "content/vector/blocks.html",
    "title": "bit::vector — Access the Block Store",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\nThe methods referenced on this page allow you to access what might be termed the implementation details in the bit::vector class. As such, they probably should be considered advanced and something of a last resource!\nThe primary use case is to implement functionality that should eventually make it into the core bit::vector interface."
  },
  {
    "objectID": "content/vector/blocks.html#construction-from-a-prefilled-store",
    "href": "content/vector/blocks.html#construction-from-a-prefilled-store",
    "title": "bit::vector — Access the Block Store",
    "section": "Construction from a prefilled store",
    "text": "Construction from a prefilled store\nSometimes, none of the standard construction methods we provide in vector::constructors work for your application. For those cases, we provide a method to take a block store of bits you have prefilled in some manner and then use those bits directly to construct a bit::vector.\ntemplate&lt;typename T&gt;\n    requires std::same_as&lt;std::remove_cvref_t&lt;T&gt;, block_store_type&gt;\n1explicit constexpr bit::vector(std::size_t n, T&& blocks, bool is_clean = false);\n\n1\n\nCreate a bit-vector by copying or moving a pre-filled container of blocks.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nYour block store must match the block_store_type of the bit::vector you wish to construct. It must also have precisely the correct size — if you are constructing a bit-vector of size n, the store size must equal the value returned from blocks_needed(n).\n\n\nSuppose my_store is a prefilled store of bits you wish to use to construct a bit-vector of size n. If you invoke the constructor as:\nbit::vector v(n, std::move(my_store));\nThen my_store is moved directly into place as the bit-vector’s elements. This construction makes no copies of the blocks and will be very efficient. However, if you use this route, my_store will no longer be valid after the call.\nOn the other hand, if you invoke the constructor as:\nbit::vector v(n, my_store);\nThen my_store is copied into the bit-vector and remains valid after the call, though unconnected from the bit-vector.\n\n\n\n\n\n\nTip\n\n\n\nThe constructor takes an optional third is_clean argument. If false (the default), the constructor cleans out any junk bits in the final block of the store arguments. You can preempt that cleaning call if you are sure those bits are all zero.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    using vector_type = bit::vector&lt;std::uint8_t&gt;;\n    using block_store_type = vector_type::block_store_type;\n\n1    std::size_t n = 22;\n    block_store_type blocks(vector_type::blocks_needed(n));\n    std::fill(blocks.begin(), blocks.end(), std::numeric_limits&lt;vector_type::block_type&gt;::max());\n\n2    vector_type u{n, blocks};\n    std::cout &lt;&lt; \"bit::vector(\" &lt;&lt; n &lt;&lt; \", blocks)            = \" &lt;&lt; u    &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"post-construction blocks size      = \" &lt;&lt; blocks.size() &lt;&lt; '\\n';\n\n3    vector_type v{22, std::move(blocks)};\n    std::cout &lt;&lt; \"bit::vector(\" &lt;&lt; n &lt;&lt; \", std::move(blocks)) = \" &lt;&lt; u    &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"post-construction blocks size      = \" &lt;&lt; blocks.size() &lt;&lt; '\\n';\n}\n\n1\n\nFill three 8-bit blocks with ones.\n\n2\n\nCopy 22 of those bits to a bit-vector and automatically clean out the two junk ones at the end.\n\n3\n\nMove all the blocks into a bit-vector and automatically clean out the two junk ones at the end.\nNow, after the move, the original blocks store is empty!\n\n\nOutput\nbit::vector(22, blocks)            = [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\npost-construction blocks size      = 3\nbit::vector(22, std::move(blocks)) = [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\npost-construction blocks size      = 0\n\nSee Also\nvector::constructors"
  },
  {
    "objectID": "content/vector/convolution.html",
    "href": "content/vector/convolution.html",
    "title": "bit::vector — Convolutions",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nComputes the convolution of two bit-vectors.\ntemplate&lt;std::unsigned_integral Block, typename Allocator&gt;\nconstexpr bit::vector&lt;Block, Allocator&gt;\n1convolution(const bit::vector&lt;Block, Allocator&gt; &u,\n            const bit::vector&lt;Block, Allocator&gt; &v);\n\n1\n\nNon-member function that returns the convolution of the two bit-vectors u and v.\n\n\nIf \\(\\mathbf{u}\\) has size \\(m\\) and \\(\\mathbf{v}\\) has size \\(n\\) then these methods return a bit-vector \\(\\mathbf{w}\\) of size \\(m+n-1\\) whose elements are given by the formula \\[\nw_k = \\sum_j u_j v_{k - j + 1}.\n\\] The sum is over all values of \\(j\\) such that the indices for \\(u\\) and \\(v\\) in that formula are valid. In the case of bit-vectors, products are replaced by logical AND and sums by the logical XOR operation.\nOne use for convolution is to do polynomial multiplication:\nInterpreting \\(u_i\\) and \\(v_i\\) as the polynomial coefficients: \\[\n\\begin{align}\nu(x) &= u_0 + u_1 x + \\cdots + u_{m-1} x^{m-1} \\\\\nv(x) &= v_0 + v_1 x + \\cdots + v_{n-1} x^{n-1}\n\\end{align}\n\\] Then the \\(w_k\\) are the coefficients for the product polynomial\n\\[\nu(x) v(x) \\equiv w(x) = w_0 + w_1 x + \\cdots + w_{m+n-1} x^{m+n-1}.\n\\]\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto u = bit::vector&lt;&gt;::ones(3);\n    auto v = bit::vector&lt;&gt;::ones(2);\n    std::cout &lt;&lt; u &lt;&lt; \" convolved with \" &lt;&lt; v &lt;&lt; \" yields \" &lt;&lt; bit::convolution(u, v) &lt;&lt; '\\n';\n}\nOutput\n[1 1 1] convolved with [1 1] yields [1 0 0 1]\nNote, in terms of polynomials, we are computing the product: \\[\n(1 + x + x^2)(1+ x) = 1 + 2x + 2x^2 + x^3.\n\\] However, in \\(\\FF\\), all arithmetic is mod 2, so the two middle terms are zero for all \\(x\\). Hence the product polynomial in \\(\\FF\\) is \\(1 + x^3\\) and we get the coefficients [1 0 0 1] exactly as shown.\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/index.html",
    "href": "content/vector/index.html",
    "title": "The bit::vector Class",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]",
    "crumbs": [
      "Home",
      "Bit-Vectors",
      "Introduction"
    ]
  },
  {
    "objectID": "content/vector/index.html#introduction",
    "href": "content/vector/index.html#introduction",
    "title": "The bit::vector Class",
    "section": "Introduction",
    "text": "Introduction\nA bit::vector represents a vector over GF(2) (also known as \\(\\FF\\)) the simplest Galois Field that has just two elements usually denoted 0 & 1, or as the booleans true & false, or as the bits set & unset. Arithmetic over \\(\\FF\\) is mod 2, so addition/subtraction becomes the XOR operation while multiplication/division becomes AND.\nThe bit::vector class is a hybrid between a std::vector and a std::bitset, along with extra mathematical features to facilitate linear algebra.\nWe often refer to a bit::vector object as a bit-vector.\nOne can dynamically size and resize a bit::vector as needs dictate. A std::bitset, on the other hand, has a fixed size determined at compile time. Boost has a boost::dynamic_bitset class that allows for runtime resizing, as its name suggests. However, that class does not support algebraic operations.\nIt is worth noting that by default, a bit::vector prints in vector-order. For example, a bit-vector of size four will print as \\(v_0 v_1 v_2 v_3\\) with the elements in increasing order with the least significant vector element, \\(v_0\\), coming first on the left. Contrast that to a std::bitset, which always prints in bit-order. The equivalent std::bitset with four elements prints as \\(b_3 b_2 b_1 b_0\\) with the least significant bit \\(b_0\\) printed last on the right.\nOf course, for many applications, printing in bit-order makes perfect sense. A size four bit-vector initialized with the hex number 0x1 will print as 1000. A std::bitset prints the same value as 0001, which will be more natural in some settings. For this reason, bit::vector also supports conversions to a string in bit-order, though it is not the default.\nIt isn’t the default because our main aim here is linear algebra. In particular, bit-order is unnatural for matrices over \\(\\FF\\). It is too confusing to print a matrix in anything but the natural order with the (0,0) element at the top left and proceed from there.\nA bit::vector packs its elements into an array of some unsigned integer type defined by the class template parameter Block. The default Block is an unsigned 64-bit word. Most of the methods defined in the bit::vector class operate on whole blocks simultaneously, so they are very efficient.",
    "crumbs": [
      "Home",
      "Bit-Vectors",
      "Introduction"
    ]
  },
  {
    "objectID": "content/vector/index.html#declaration",
    "href": "content/vector/index.html#declaration",
    "title": "The bit::vector Class",
    "section": "Declaration",
    "text": "Declaration\nLike everything in the library, this class is in the bit namespace and is defined in the header &lt;bit/vector.h&gt; as follows:\nnamespace bit {\n  template&lt;std::unsigned_integral Block = std::uint64_t,\n           Allocator = std::allocator&lt;Block&gt;&gt;\n  class vector;\n}\nThe two template parameters add some visual clutter, but they both have reasonable defaults and disappear entirely in most uses. For example, your code might have a simple line like:\nbit::vector v{32};\nThis code creates a vector with 32 elements set to 0 by default. The bit-vector’s 32 elements are packed into a single 64-bit word, so this example has some spare capacity.\n\nTemplate Parameters\n\n\n\n\nParameter\nDescription\n\n\n\n\nBlock = std::uint64_t\nThe elements of a bit-vector are packed into blocks of some std::unsigned_integral type. The default size is 64 bits.\n\n\nAllocator = std::allocator&lt;Block&gt;\nThe default Allocator should be just fine for most purposes, but you can use your custom type to handle all memory allocation/destruction for blocks.\n\n\n\n\nThe default Block is 64-bits, the native size for many modern CPUs.\nOf course, if you need to use many smaller bit-vectors and have concerns about conserving space, you might use a different Block. Perhaps if the bit-vectors all fit in 8 bits, you might have code along the lines:\nusing vector_type = bit::vector&lt;uint8_t&gt;;\nvector_type v = ...\n\n\n\n\n\n\nUse a single Block type throughout your code!\n\n\n\nIn theory, there is no reason that one couldn’t intermingle operations between, say, a bit::vector&lt;std::uint32_t&gt; and a bit::vector&lt;std::uint64_t&gt; but doing so efficiently significantly increases code complexity, and the library doesn’t support this.",
    "crumbs": [
      "Home",
      "Bit-Vectors",
      "Introduction"
    ]
  },
  {
    "objectID": "content/vector/index.html#class-constants-and-types",
    "href": "content/vector/index.html#class-constants-and-types",
    "title": "The bit::vector Class",
    "section": "Class Constants and Types",
    "text": "Class Constants and Types\n\n\n\n\n\n\n\n\nItem\nDescription\n\n\n\n\nblock_type\nWe use a specific std::unsigned_integral type to store the bit-vector elements in blocks. The default is std::uint64_t, where we store 64 elements per block.\n\n\nallocator_type\nThe block store vector uses this type of memory manager. The default is a std::allocator&lt;block_type&gt;.\n\n\nnpos\nA class constant of type std::size_t used to indicate search failures, etc.\n\n\nreference\nA proxy sub-class representing an individual vector element (a single bit).\n\n\n\n\nOccasionally, you may need to use more implementation-specific types:\n\n\n\n\n\n\n\n\nItem\nDescription\n\n\n\n\nbits_per_block\nThe number of bit-vector elements each block can hold. The default is 64.\n\n\nblock_store_type\nWe store the blocks in a container of this type, a std::vector&lt;block_type&gt;.\n\n\nblocks_needed(n)\nClass method returning the number of blocks needed to store a bit-vector of size n.",
    "crumbs": [
      "Home",
      "Bit-Vectors",
      "Introduction"
    ]
  },
  {
    "objectID": "content/vector/index.html#instance-methods",
    "href": "content/vector/index.html#instance-methods",
    "title": "The bit::vector Class",
    "section": "Instance Methods",
    "text": "Instance Methods\n\nConstruction\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nvector::constructors\nConstruct bit-vectors in various ways.\n\n\nvector::random\nFactory method constructs a bit-vector with a random fill.\n\n\nvector::zeros\nFactory method to construct bit-vectors with all the bits set to 0.\n\n\nvector::ones\nFactory method to construct bit-vectors with all the bits set to 1.\n\n\nvector::unit\nFactory method to construct a unit bit-vector.\n\n\nvector::checker_board\nFactory method to construct bit-vectors with bits in a checker-board pattern 1010101…​ or 0101010…\n\n\nvector::from\nFactory methods that construct bit-vectors from the bits in an integer or from strings.\n\n\n\n\n\n\nElement Access\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nvector::element\nAccess an element in a bit-vector.\n\n\nvector::operator()\nAccess an element in a bit-vector.\n\n\nvector::operator[]\nAccess an element in a bit-vector.\n\n\nvector::test\nCheck the status of a particular element in a bit-vector.\n\n\nvector::front\nAccess the first element of a bit-vector.\n\n\nvector::back\nAccess the final element of a bit-vector.\n\n\nvector::all\nAre all the bits in the bit-vector set to 1?\n\n\nvector::any\nAre any bits in the bit-vector set to 1?\n\n\nvector::none\nAre none of the bits in the bit-vector set to 1?\n\n\nvector::count\nCount the set bits in a bit-vector.\n\n\nvector::count0\nCount the unset bits in a bit-vector.\n\n\nvector::count1\nCount the set bits in a bit-vector.\n\n\nvector::parity\nParity is the number of set bits mod 2.\n\n\nvector::sub\nExtracts a sub-vector as a distinct copy of some of elements in a bit-vector.\n\n\nvector::blocks\nAccess the underlying block store as a std::vector&lt;Block&gt;.\n\n\nvector::allocator\nRead-only access to the underlying Allocator for the block store.\n\n\n\n\n\n\nBlock Access\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nvector::bits_per_block\nThe number of bit-vector elements that can fit in one storage block.\n\n\nvector::block_store_type\nWe store the underlying blocks in this type of container.\n\n\nvector::blocks_needed\nComputes the number of blocks needed to store a particular bit-vector.\n\n\nvector::allocator\nThe memory manager for the block store.\n\n\nvector::block_count\nThe number of blocks in the block store.\n\n\nvector::block\nAccess an individual block.\n\n\nvector::block_index_for\nReturns the index of the block holding a particular bit-vector element.\n\n\nvector::bit_index_for\nReturns the specific bit inside that block where that particular bit-vector element resides.\n\n\nvector::blocks\nAccess the underlying block store as a block_store_type\n\n\nvector::clean\nThis sets any extra/junk bits in the last occupied block to 0.\n\n\nvector::block_constructor\nConstruct a bit::vector by copying or moving a prefilled block_store_type of blocks.\n\n\n\n\n\n\nIteration\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nvector::if_set_call\nCalls a function for each set index.\n\n\nvector::first_set\nReturns the index location of the first set bit.\n\n\nvector::next_set\nReturns the index location of the next set bit.\n\n\nvector::final_set\nReturns the index location of the final set bit.\n\n\nvector::prev_set\nReturns the index location of the previous set bit.\n\n\nvector::set_indices\nReturns the index locations of the set bits.\n\n\nvector::unset_indices\nReturns the index locations of the unset bits.\n\n\n\n\n\n\nCapacity\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nvector::size\nReturns the number of elements in the bit-vector\n\n\nvector::empty\nQueries whether the bit-vector is empty.\n\n\nvector::capacity\nHow many bits can a bit-vector hold before it resizes?\n\n\nvector::unused\nHow many bits can be added before a bit-vector resizes?\n\n\nvector::reserve\nReserves storage for a bit-vector without changing its size().\n\n\nvector::shrink_to_fit\nTries to reduce memory usage by freeing unused memory.\n\n\n\n\n\n\nModifiers\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nvector::clear\nClears all the elements from the bit-vector so its size() becomes 0.\n\n\nvector::push\nPushes an element onto the end of the bit-vector.\n\n\nvector::pop\nRemoves the last element from the bit-vector\n\n\nvector::append\nAdds elements/bits from various sources to the end of the bit-vector.\n\n\nvector::resize\nResizes the bit-vector, padding out any added values with zeros.\n\n\nvector::swap_elements\nSwaps the values of two elements in the bit-vector.\n\n\nvector::swap\nSwaps the contents of the bit-vector with another.\n\n\nvector::replace\nMethods to replace some sub-vectors of the bit-vector with other values.\n\n\nvector::set\nSet various ranges of elements in the bit-vector to 1.\n\n\nvector::reset\nSet various ranges of elements in the bit-vector to 0.\n\n\nvector::flip\nFlip various ranges of elements in the bit-vector from 0 to 1 and vice versa.\n\n\nvector::set_if\nSets elements in a bit-vector based on the return value from a function of the element index.\n\n\nvector::flip_if\nFlips values in a bit-vector based on the return value from a function of the element index.\n\n\nvector::operator&=\nElement-by-element logical AND in-place between this bit-vector and another of equal size.\n\n\nvector::operator^=\nElement-by-element logical XOR in-place between this bit-vector and another of equal size.\n\n\nvector::operator|=\nElement-by-element logical OR in-place between this bit-vector and another of equal size.\n\n\nvector::operator+=\nElement-by-element logical XOR in-place between this bit-vector and another of equal size.\n\n\nvector::operator-=\nElement-by-element logical XOR in-place between this bit-vector and another of equal size.\n\n\nvector::operator*=\nElement-by-element logical AND in-place between this bit-vector and another of equal size.\n\n\nvector::operator~\nFlips the values of all elements in this bit-vector.\n\n\nvector::operator&lt;&lt;=\nLeft shift the elements of this bit-vector in-place.\n\n\nvector::operator&gt;&gt;=\nRight shift the elements of this bit-vector in-place.\n\n\nvector::operator&lt;&lt;\nReturns a left-shifted copy of this bit-vector.\n\n\nvector::operator&gt;&gt;\nReturns a right-shifted copy of this bit-vector.\n\n\n\n\n\n\nString Conversions\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nvector::to_string\nReturns a binary-string representation using configurable characters for set and unset elements. The elements are in vector order.\n\n\nvector::to_pretty_string\nReturns a formatted representation e.g. [1 1 0 1 0 1].\n\n\nvector::to_bit_order\nReturns a binary-string representation using configurable characters for set and unset elements. The least significant bit is on the right.\n\n\nvector::to_hex\nReturns a compact hex string representation of the bit-vector.\n\n\nvector::polynomial\nInterprets the elements of a bit-vector as the coefficients of a polynomial over \\(\\FF\\) and returns a string representation of that polynomial.\n\n\nvector::description\nWrites some descriptive data about the bit-vector to a stream.\n\n\n\n\n\n\nOther Instance Methods\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nvector::trimmed_right\nReturns a copy of a bit-vector with any trailing zeros removed.\n\n\nvector::trimmed_left\nReturns a copy of a bit-vector with any leading zeros removed.\n\n\nvector::trimmed\nReturns a copy of a bit-vector with any leading or trailing zeros removed.\n\n\nvector::riffled\nReturns a copy of a bit-vector with any added interleaved zeros.\n\n\nvector::dot\nReturns the dot product of this bit-vector with another of equal size.\n\n\nvector::unit_floor\nReturns a unit bit-vector with its 1 at the location of our final set bit.\n\n\nvector::unit_ceil\nReturns a unit bit-vector with its 1 at the location one slot past our final set bit.\n\n\n\n\n\n\nDebugging\nYou can set a compile-time flag BIT_DEBUG to enable range checking and other assertions. These checks can have a substantial performance impact so typically are only used during development.\n\n\n\n\n\n\n\n\nMacro\nDescription\n\n\n\n\nBIT_DEBUG\nThis compile-time flag enables extra safety checks.\n\n\nbit_debug_assert\nThese assertions are only checked if you set the BIT_DEBUG flag at compile time.\n\n\nbit_always_assert\nThese assertions are always checked.",
    "crumbs": [
      "Home",
      "Bit-Vectors",
      "Introduction"
    ]
  },
  {
    "objectID": "content/vector/index.html#non-member-functions",
    "href": "content/vector/index.html#non-member-functions",
    "title": "The bit::vector Class",
    "section": "Non-member Functions",
    "text": "Non-member Functions\n\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nvector::copy\nSeveral functions of the general form bit::copy(src, dst) where the src argument(s) is a source of bits and the dst argument(s) is a destination for those bits.\n\n\nvector::diff\nLogical DIFF for two equal-sized bit-vectors.\n\n\nvector::join\nJoins two or three bit-vectors to create a new one.\n\n\nvector::dot\nReturns the dot product of two equal sized bit-vectors.\n\n\nvector::convolution\nReturns the convolution of two bit-vectors.\n\n\nvector::polynomial\nInterprets the elements of a bit-vector as the coefficients of a polynomial over \\(\\FF\\) and returns a string representation of that polynomial.\n\n\nvector::operator&\nElement-by-element logical AND between two equal-sized bit-vectors.\n\n\nvector::operator^\nElement-by-element logical XOR between two equal-sized bit-vectors.\n\n\nvector::operator|\nElement-by-element logical OR between two equal-sized bit-vectors.\n\n\nvector::operator+\nElement-by-element logical XOR between two equal-sized bit-vectors.\n\n\nvector::operator-\nElement-by-element logical XOR between two equal-sized bit-vectors.\n\n\nvector::operator*\nElement-by-element logical AND between two equal-sized bit-vectors.\n\n\nvector::stream&lt;&lt;\nStream input for bit-vectors.\n\n\nvector::stream&gt;&gt;\nStream output for bit-vectors.\n\n\nvector::formatter\nConnect the bit::vector class to std::format and friends.",
    "crumbs": [
      "Home",
      "Bit-Vectors",
      "Introduction"
    ]
  },
  {
    "objectID": "content/vector/sub.html",
    "href": "content/vector/sub.html",
    "title": "bit::vector — Extract a Sub-Vector",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods to extract a sub-vector as a stand-alone, distinct copy of elements from this bit-vector.\n1constexpr bit::vector sub(std::size_t begin, std::size_t len) const;\n2constexpr bit::vector sub(int len) const;\n\n1\n\nReturns a bit-vector of size len, a copy of the elements starting at begin.\n\n2\n\nReturns a copy of the first len elements if len &gt; 0 or the final abs(len) elements if len &lt; 0.\n\n\n\n\n\n\n\n\nRange checking\n\n\n\nbegin has to be a valid index, and abs(len) elements must be available for copying. Set the BIT_DEBUG flag at compile time to check this condition — any violation will cause the program to abort with a helpful message.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    auto v = bit::vector&lt;&gt;::random(12);\n    std::cout &lt;&lt; \"v:           \" &lt;&lt; v           &lt;&lt; \"\\n\";\n2    std::cout &lt;&lt; \"v.sub(0, 4): \" &lt;&lt; v.sub(0, 4) &lt;&lt; \"\\n\";\n3    std::cout &lt;&lt; \"v.sub(4):    \" &lt;&lt; v.sub(4)    &lt;&lt; \"\\n\";\n4    std::cout &lt;&lt; \"v.sub(-4):   \" &lt;&lt; v.sub(-4)   &lt;&lt; \"\\n\";\n5    std::cout &lt;&lt; \"v.sub(8, 4): \" &lt;&lt; v.sub(8, 4) &lt;&lt; \"\\n\";\n}\n\n1\n\nConstruct a vector of size 12 with a random fill.\n\n2\n\nExtract four elements starting at index 0.\n\n3\n\nDo the same thing using a shorthand notation.\n\n4\n\nExtract the final four elements using the shorthand notation.\n\n5\n\nDo the same thing by copying four elements starting at index 8.\n\n\nOutput\nv:           [0 1 0 0 1 0 1 0 0 1 1 0]\nv.sub(0, 4): [0 1 0 0]\nv.sub(4):    [0 1 0 0]\nv.sub(-4):   [0 1 1 0]\nv.sub(8, 4): [0 1 1 0]\n\nSee Also\nvector::replace\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/indices.html",
    "href": "content/vector/indices.html",
    "title": "bit::vector — Index Locations",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nFind the indices of the set or unset bits in a bit-vector.\n1std::vector&lt;std::size_t&gt; set_indices() const;\n2std::vector&lt;std::size_t&gt; unset_indices() const;\n\n1\n\nReturns the index locations of the set bits in order.\n\n2\n\nReturns the index locations of the unset bits in order.\n\n\nExample\n#include &lt;bit/bit.h&gt;\n#include &lt;iterator&gt;\nint main()\n{\n1    auto v = bit::vector&lt;&gt;::checker_board(19);\n    auto set_indices   = v.set_indices();\n    auto unset_indices = v.unset_indices();\n\n2    std::ostream_iterator&lt;std::size_t&gt; iter(std::cout,\" \");\n\n    std::cout &lt;&lt; \"Bit-vector \" &lt;&lt; v.to_string() &lt;&lt; \" has set indices at locations:\\n\";\n    std::copy (set_indices.begin(), set_indices.end(), iter);\n    std::cout &lt;&lt; '\\n';\n\n    std::cout &lt;&lt; \"Bit-vector \" &lt;&lt; v.to_string() &lt;&lt; \" has unset indices at locations:\\n\";\n    std::copy (unset_indices.begin(), unset_indices.end(), iter);\n    std::cout &lt;&lt; '\\n';\n}\n\n1\n\nCreates a checker-board patterned bit-vector of size 19 and then extracts the set & unset index locations.\n\n2\n\nUse a stream iterator to print those indices.\n\n\nOutput\nBit-vector 0101010101010101010 has set indices at locations:\n1 3 5 7 9 11 13 15 17\nBit-vector 0101010101010101010 has unset indices at locations:\n0 2 4 6 8 10 12 14 16 18\n\nSee Also\nvector::if_set_call\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/trimmed.html",
    "href": "content/vector/trimmed.html",
    "title": "bit::vector — Trim Trailing/Leading Zeros",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods that return a copy of the bit-vector with either the trailing zeros removed, the leading zeros removed, or both the trailing and leading zeros removed.\n1constexpr bit::vector trimmed_right() const;\n2constexpr bit::vector trimmed_left() const;\n3constexpr bit::vector trimmed() const;\n\n1\n\nReturn a copy of this bit-vector with any trailing zeros removed.\n\n2\n\nReturn a copy of this bit-vector with any leading zeros removed.\n\n3\n\nReturn a copy of this bit-vector with any trailing and leading zeros removed.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    auto v0 = bit::vector&lt;&gt;::zeros(6);\n2    auto v1 = bit::vector&lt;&gt;::ones(12);\n3    auto v3 = bit::join(v0, v1, v0);\n    auto vr = v3.trimmed_right();\n    auto vl = v3.trimmed_left();\n    auto vt = v3.trimmed();\n\n    std::cout &lt;&lt; \"bit-vector:    size \" &lt;&lt; v3.size() &lt;&lt; \" \" &lt;&lt; v3 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"trimmed right: size \" &lt;&lt; vr.size() &lt;&lt; \" \" &lt;&lt; vr &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"trimmed left:  size \" &lt;&lt; vl.size() &lt;&lt; \" \" &lt;&lt; vl &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"trimmed:       size \" &lt;&lt; vt.size() &lt;&lt; \" \" &lt;&lt; vt &lt;&lt; '\\n';\n}\n\n1\n\nConstruct a bit-vector of size six that is all zeros.\n\n2\n\nConstruct a bit-vector of size twelve that is all ones.\n\n3\n\nJoins those to create a bit-vector with six zeros, twelve ones, and then six more zeros.\n\n\nOutput\nbit-vector:    size 24 [0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0]\ntrimmed right: size 18 [0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1]\ntrimmed left:  size 18 [1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0]\ntrimmed:       size 12 [1 1 1 1 1 1 1 1 1 1 1 1]\n\nSee Also\nvector::replace\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/reserve.html",
    "href": "content/vector/reserve.html",
    "title": "bit::vector — Change the Capacity",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nPotentially change the vector::capacity of a bit-vector.\n1constexpr bit::vector &reserve(std::size_t n);\n2constexpr bit::vector &shrink_to_fit();\n\n1\n\nIncreases the bit-vector’s vector::capacity to hold n elements.\nDoes nothing if n elements fit inside the current capacity.\n\n2\n\nThis is a request to minimize the unused/excess vector::capacity. May do nothing.\n\n\nThe idea is to make it as efficient as possible to append a (known) large number of elements to a bit-vector by allocating the needed storage up-front rather than in pieces.\nThese methods return *this, so you can chain them with other calls.\nThese methods do not change a bit-vector’s size(). No elements are added or deleted.\n\n\n\n\n\n\nReferences can disappear\n\n\n\nIf the capacity does change, all the old values are unaltered. However, any references are then invalidated.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto v = bit::vector&lt;&gt;::checker_board(8);\n1    std::cout &lt;&lt; v &lt;&lt; \": size \" &lt;&lt; v.size() &lt;&lt; \", capacity \" &lt;&lt; v.capacity() &lt;&lt; '\\n';\n2    v.reserve(99);\n3    std::cout &lt;&lt; v &lt;&lt; \": size \" &lt;&lt; v.size() &lt;&lt; \", capacity \" &lt;&lt; v.capacity() &lt;&lt; '\\n';\n4    v.shrink_to_fit();\n    std::cout &lt;&lt;  v &lt;&lt; \": size \" &lt;&lt; v.size() &lt;&lt; \", capacity \" &lt;&lt; v.capacity() &lt;&lt; '\\n';\n}\n\n1\n\nWe’re using the default 64-bit blocks, so v can hold 64 elements (though it only has eight at present).\n\n2\n\nGet v “ready” to hold 99 elements.\n\n3\n\nAs the blocks are all 64-bits, we need two for those 99 elements; therefore, the capacity increases to 128.\n\n4\n\nChanged our mind and want to shrink v to a minimum size. Note that the elements in v never changed!\n\n\nOutput\n[1 0 1 0 1 0 1 0]: size 8, capacity 64\n[1 0 1 0 1 0 1 0]: size 8, capacity 128\n[1 0 1 0 1 0 1 0]: size 8, capacity 64\n\nSee Also\nvector::reserve\nvector::description\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/append.html",
    "href": "content/vector/append.html",
    "title": "bit::vector — Appending Elements",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods that add bits/elements taken from various sources to the end of a bit-vector.\n1constexpr bit::vector &append(bool src);\n2constexpr bit::vector &append(const bit::vector &src);\n\n1\n\nAppends a single value to the end of the bit-vector. It is a synonym for the vector::push method.\n\n2\n\nAppends all the elements from src to the end of the bit-vector.\n\n\ntemplate&lt;std::unsigned_integral Src&gt;\n1constexpr bit::vector &append(Src src);\n\ntemplate&lt;std::unsigned_integral Src&gt;\n2constexpr bit::vector &append(std::initializer_list&lt;Src&gt; src);\n\ntemplate&lt;std::unsigned_integral Src&gt;\n3constexpr bit::vector &append(const std::vector&lt;Src&gt;& src);\n\ntemplate&lt;typename Iter&gt;\n4constexpr bit::vector &append(Iter b, Iter e);\n\ntemplate&lt;std::size_t N&gt;\n5explicit constexpr bit::vector &append(const std::bitset&lt;N&gt; &bs);\n\n1\n\nAppends the bits from a single word src, which is some unsigned integer type.\n\n2\n\nTakes an initializer-style list of unsigned integers and appends their bits to the vector.\n\n3\n\nTakes a std::vector of unsigned integers and appends their bits to the vector.\n\n4\n\nTakes any iteration of unsigned integers and appends their bits to the vector.\n\n5\n\nAppends all N bits from a std:::bitset&lt;N&gt; to the vector.\n\n\nThese methods return a reference to *this so they can be chained with other calls.\n\nTemplate Parameters\n\n\n\n\n\n\n\n\nParameter\nDescription\n\n\n\n\nSrc\nThe type of the unsigned integers whose bits are getting appended to the vector. There is no requirement that Src and Block are the same. For example, we can add the bits from a list of 32-bit unsigned integers while the storage scheme for the vector remains the default 64-bit type.\n\n\nIter\nAn iterator–might be the type returned by any std::cbegin(collection) etc. Iter::value_type should be some unsigned integer type.\n\n\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    bit::vector v;\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v.to_string() &lt;&lt; '\\n';\n2    v.append(uint8_t(0));\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v.to_string() &lt;&lt; '\\n';\n3    v.append({uint8_t(255), uint8_t(0)});\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v.to_string() &lt;&lt; '\\n';\n4    std::vector&lt;uint8_t&gt; vec{255, 0};\n    v.append(vec);\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v.to_string() &lt;&lt; '\\n';\n5    v.append(vec.cbegin(), vec.cend());\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v.to_string() &lt;&lt; '\\n';\n6    std::bitset&lt;8&gt; bs(255);\n    v.append(bs);\n    std::cout &lt;&lt; \"v: \" &lt;&lt; v.to_string() &lt;&lt; '\\n';\n}\n\n1\n\nDefault constructor makes an empty vector.\n\n2\n\nAppends eight zeros.\n\n3\n\nAppends a list of eight 1-bits and eight 0-bits.\n\n4\n\nAppends a std::vector with eight 1-bits and eight 0-bits.\n\n5\n\nAppends a std::vector with eight 1-bits and eight 0-bits using the usual iterators.\n\n6\n\nAppends a std::bitset with eight 1-bits.\n\n\nOutput\nv:\nv: 00000000\nv: 000000001111111100000000\nv: 0000000011111111000000001111111100000000\nv: 00000000111111110000000011111111000000001111111100000000\nv: 0000000011111111000000001111111100000000111111110000000011111111\n\n\nSee Also\nvector::push\nvector::clear\nvector::join\nvector::copy\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/random.html",
    "href": "content/vector/random.html",
    "title": "bit::vector — Random Fills",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nFactory method to construct a bit-vector whose elements come from independent random draws from a Bernoulli distribution\nstatic bit::vector random(std::size_t n, double prob_one = 0.5);\nReturns a bit-vector of size n.\nThe probability that an element in the bit-vector is 1 is prob_one. The default probability value is 0.5, so element values are determined by tossing a fair coin a total of n times.\nAt the extremes, if this parameter is 1.0, the elements will all be 1; if it is 0.0, the elements will all be 0.\n\n\n\n\n\n\nThe probability value needs to be valid\n\n\n\nThis method throws a std::invalid_argument exception if the prob_one argument is not in the valid range \\([0, 1]\\).\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto v = bit::vector&lt;&gt;::random(16);\n    std::cout &lt;&lt; v &lt;&lt; std::endl;\n}\nOutput (will vary from run to run)\n[1 0 1 1 0 1 1 1 0 0 1 1 1 0 1 0]\n\nSee Also\nvector::constructors\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/push-pop.html",
    "href": "content/vector/push-pop.html",
    "title": "bit::vector — Add/Remove Elements",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods to add or remove single elements from the end of the bit-vector.\n1constexpr bit::vector &push(bool one = false);\n2constexpr bit::vector &append(bool);\n3constexpr bit::vector &pop();\n\n1\n\nAdds a single element to the end of the bit-vector. The element will default to 0 unless one == true.\n\n2\n\nThis is a synonym for push() and adds a single bool to the end of the bit-vector. Several other vector::append methods exist, so the synonym seems natural.\n\n3\n\nRemove the last element from the bit-vector & shrink it if possible; do nothing if the bit-vector is empty.\n\n\nThese methods both return a reference to *this and can be chained with other calls.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n   bit::vector&lt;&gt; v;\n1   v.push(true);\n   std::cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; '\\n';\n2   v.push();\n   std::cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; '\\n';\n   v.pop();\n   std::cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; '\\n';\n   v.pop();\n   std::cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; '\\n';\n3   v.pop();\n   std::cout &lt;&lt; \"v: \" &lt;&lt; v &lt;&lt; '\\n';\n}\n\n1\n\nAdding a 1 element to the end of the bit-vector.\n\n2\n\nAdding the default element of 0 to the end of the bit-vector.\n\n3\n\nCalling pop() on an empty bit-vector does nothing.\n\n\nOutput\nv: [1]\nv: [1 0]\nv: [1]\nv: []\n1v: []\n\n1\n\nCalling pop() on an empty vector does nothing.\n\n\n\nSee Also\nvector::append\nvector::clear\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/set.html",
    "href": "content/vector/set.html",
    "title": "bit::vector — Change All Elements",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods to set elements in a bit-vector to 1, reset them to 0, or flip them from 0 to 1 and vice versa. These methods can work on the entire bit-vector, on individual elements, or on blocks of contiguous elements.\n1constexpr bit::vector &set(std::size_t i);\nconstexpr bit::vector &reset(std::size_t i);\nconstexpr bit::vector &flip(std::size_t i);\n\n2constexpr bit::vector &set(std::size_t first,   std::size_t len);\nconstexpr bit::vector &reset(std::size_t first, std::size_t len);\nconstexpr bit::vector &flip(std::size_t first,   std::size_t len);\n\n3constexpr bit::vector &set();\nconstexpr bit::vector &reset();\nconstexpr bit::vector &flip();\n\n1\n\nSets, resets, or flips the value of the single element at index i.\n\n2\n\nSets, resets, or flips the value of len elements starting at index first.\n\n3\n\nSets, resets, or flips the elements’ values.\n\n\n\n\n\n\n\n\nSizes must be compatible\n\n\n\nThe len elements starting at first must fit in the valid range for the bit-vector.\nSet the BIT_DEBUG flag at compile time to check this condition — any violation will cause the program to abort with a helpful message.\n\n\nThese methods return a reference to *this, so they can be chained with other calls.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    std::size_t n = 4;\n    std::size_t i = 0;\n\n    bit::vector&lt;&gt; v(n);\n\n    std::cout &lt;&lt; \"Setting ranges of elements to 1:\\n\";\n    v.reset();\n    std::cout &lt;&lt; \"Starting with vector of size \" &lt;&lt; v.size() &lt;&lt; \": \" &lt;&lt; v &lt;&lt; '\\n';\n    for (i = 0; i &lt; v.size(); ++i) {\n        std::size_t len, maxLen = v.size() - i + 1;\n        for (len = 1; len &lt; maxLen; ++len) {\n            v.reset();\n            std::cout &lt;&lt; \"Setting \" &lt;&lt; len &lt;&lt; \" element(s) starting at position: \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; v.set(i, len) &lt;&lt; '\\n';\n        }\n    }\n    std::cout &lt;&lt; '\\n';\n\n    std::cout &lt;&lt; \"Setting ranges of elements to 0:\\n\";\n    v.set();\n    std::cout &lt;&lt; \"Starting with a vector of size \" &lt;&lt; v.size() &lt;&lt; \": \" &lt;&lt; v &lt;&lt; '\\n';\n    for (i = 0; i &lt; v.size(); ++i) {\n        std::size_t len, maxLen = v.size() - i + 1;\n        for (len = 1; len &lt; maxLen; ++len) {\n            v.set();\n            std::cout &lt;&lt; \"Resetting \" &lt;&lt; len &lt;&lt; \" element(s) starting at position: \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; v.reset(i, len) &lt;&lt; '\\n';\n        }\n    }\n    std::cout &lt;&lt; '\\n';\n\n    std::cout &lt;&lt; \"Flipping ranges of elements from 1 to 0:\\n\";\n    v.set();\n    std::cout &lt;&lt; \"Starting with vector of size \" &lt;&lt; v.size() &lt;&lt; \": \" &lt;&lt; v &lt;&lt; '\\n';\n    for (i = 0; i &lt; v.size(); ++i) {\n        // v.set();\n        std::size_t len, maxLen = v.size() - i + 1;\n        for (len = 1; len &lt; maxLen; ++len) {\n            v.set();\n            std::cout &lt;&lt; \"Flipping \" &lt;&lt; len &lt;&lt; \" element(s) starting at position: \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; v.flip(i, len) &lt;&lt; '\\n';\n        }\n    }\n    std::cout &lt;&lt; '\\n';\n\n    return 0;\n}\nOutput\nSetting ranges of elements to 1:\nStarting with a vector of size 4: [0 0 0 0]\nSetting 1 element(s) starting at position: 0: [1 0 0 0]\nSetting 2 element(s) starting at position: 0: [1 1 0 0]\nSetting 3 element(s) starting at position: 0: [1 1 1 0]\nSetting 4 element(s) starting at position: 0: [1 1 1 1]\nSetting 1 element(s) starting at position: 1: [0 1 0 0]\nSetting 2 element(s) starting at position: 1: [0 1 1 0]\nSetting 3 element(s) starting at position: 1: [0 1 1 1]\nSetting 1 element(s) starting at position: 2: [0 0 1 0]\nSetting 2 element(s) starting at position: 2: [0 0 1 1]\nSetting 1 element(s) starting at position: 3: [0 0 0 1]\n\nSetting ranges of elements to 0:\nStarting with a vector of size 4: [1 1 1 1]\nResetting 1 element(s) starting at position: 0: [0 1 1 1]\nResetting 2 element(s) starting at position: 0: [0 0 1 1]\nResetting 3 element(s) starting at position: 0: [0 0 0 1]\nResetting 4 element(s) starting at position: 0: [0 0 0 0]\nResetting 1 element(s) starting at position: 1: [1 0 1 1]\nResetting 2 element(s) starting at position: 1: [1 0 0 1]\nResetting 3 element(s) starting at position: 1: [1 0 0 0]\nResetting 1 element(s) starting at position: 2: [1 1 0 1]\nResetting 2 element(s) starting at position: 2: [1 1 0 0]\nResetting 1 element(s) starting at position: 3: [1 1 1 0]\n\nFlipping ranges of elements from 1 to 0:\nStarting with a vector of size 4: [1 1 1 1]\nFlipping 1 element(s) starting at position: 0: [0 1 1 1]\nFlipping 2 element(s) starting at position: 0: [0 0 1 1]\nFlipping 3 element(s) starting at position: 0: [0 0 0 1]\nFlipping 4 element(s) starting at position: 0: [0 0 0 0]\nFlipping 1 element(s) starting at position: 1: [1 0 1 1]\nFlipping 2 element(s) starting at position: 1: [1 0 0 1]\nFlipping 3 element(s) starting at position: 1: [1 0 0 0]\nFlipping 1 element(s) starting at position: 2: [1 1 0 1]\nFlipping 2 element(s) starting at position: 2: [1 1 0 0]\nFlipping 1 element(s) starting at position: 3: [1 1 1 0]\n\nSee Also\nvector::set_if\nvector::flip_if\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/description.html",
    "href": "content/vector/description.html",
    "title": "bit::vector — Descriptive Data",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe can output some descriptive data about a bit-vector to a stream. The data is used primarily for debugging purposes.\nconstexpr void description(std::ostream &s, +\n                           const std::string &head = \"\", +\n1                           const std::string &foot = \"\\n\") const;\nconstexpr void description(const std::string &head = \"\", +\n2                           const std::string &foot = \"\\n\") const;\n\n1\n\nPrints data to an arbitrary stream.\n\n2\n\nPrints the same data to std::cout.\n\n\nYou can send along some arbitrary text that gets prepended or appended to the description of the bit-vector. See the example below.\n\n\n\n\n\n\nDon’t depend on the format\n\n\n\nThe format of the output may change from time to time.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    auto v25 = bit::vector&lt;&gt;::random(32, 0.25);\n    v25.description(\"Random fill with p = 0.25\");\n}\n\n1\n\nbit::vector of size 32 randomly filled where the probability of getting set elements is 25%.\n\n\nOutput (varies from run to run)\n1Random fill with p = 0.25::\nbit-vector: 10010000000000000100001001000001\nas hex-string:      90002428\nnumber of bits:     32\nnumber of set bits: 6\nbit capacity:       64\nunused capacity:    32\nbits-per-block:     64\nblocks used:        1\nblocks capacity:    1\n\n1\n\nThe optional user-supplied header line.\n\n\n\nSee Also\nvector::to_string\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/vector/constructors.html",
    "href": "content/vector/constructors.html",
    "title": "bit::vector — Construction",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\nConstructors for a bit-vector."
  },
  {
    "objectID": "content/vector/constructors.html#construction-from-non-strings",
    "href": "content/vector/constructors.html#construction-from-non-strings",
    "title": "bit::vector — Construction",
    "section": "Construction from non-strings",
    "text": "Construction from non-strings\nHere are some examples of constructing a bit::vector from non-string data.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    bit::vector           v1;\n2    bit::vector           v2(32);\n    std::vector&lt;uint16_t&gt; vec{65535, 0};\n3    bit::vector           v3(vec.cbegin(), vec.cend());\n4    bit::vector           v4(32, [](size_t k) { return (k + 1) % 2; });\n    std::bitset&lt;32&gt;       bs(65535);\n5    bit::vector           v5(bs);\n    std::cout &lt;&lt; \"v1 = \" &lt;&lt; v1.to_string()    &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v2 = \" &lt;&lt; v2.to_string()    &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v3 = \" &lt;&lt; v3.to_string()    &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v4 = \" &lt;&lt; v4.to_string()    &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"bs = \" &lt;&lt; bs                &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v5 = \" &lt;&lt; v5.to_string()    &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v5 = \" &lt;&lt; v5.to_bit_order() &lt;&lt; \" in bit-order!\\n\";\n}\n\n1\n\nDefault constructor makes an empty bit-vector.\n\n2\n\nbit::vector of size 32 whose elements default to 0.\n\n3\n\nbit::vector constructed from an iteration over a std::vector containing two 16-bit integers.\n\n4\n\nbit::vector constructed using a lambda that returns true if the element index is even.\n\n5\n\nbit::vector constructed from a std::bitset.\n\n\nOutput\nv1 =\nv2 = 00000000000000000000000000000000\nv3 = 11111111111111110000000000000000\nv4 = 10101010101010101010101010101010\n1bs = 00000000000000001111111111111111\n2v5 = 11111111111111110000000000000000\n3v5 = 00000000000000001111111111111111 in bit-order!\n\n1\n\nNote that the std::bitset prints with in bit-order.\n\n2\n\nThis bit::vector has the same elements but prints in vector-order.\n\n3\n\nWe can also print a bit::vector in bit-order if required."
  },
  {
    "objectID": "content/vector/constructors.html#construction-from-strings",
    "href": "content/vector/constructors.html#construction-from-strings",
    "title": "bit::vector — Construction",
    "section": "Construction from strings",
    "text": "Construction from strings\n\nThere are two principal ways we can encode a bit-vector as a string:\n\nBinary String Encodings\nThe straightforward character encoding for a bit-vector is a binary string containing just 0’s and 1’s, e.g., “10101”. Each character in a binary string represents a single element in the bit-vector.\nBy default, we encode bit-vectors to binary strings in vector order \\(v_0 v_1  \\cdots v_{n-1}\\). However, methods that read or write binary strings typically have an extra boolean argument, bit_order. This argument always defaults to false, but if present and set to true, then the binary string will encode the bit-vector in bit-order where the least significant bit v0 is on the right so \\(v_{n-1} \\cdots v_1 v_0\\). Hex-strings ignore the bit_order parameter.\n\n\nHex String Encodings\nThe other supported encoding for bit-vectors is a compact hex type string containing just the 16 hex characters 0123456789ABCDEF. For example, the string “3ED02”. We allow for hex strings with an optional prefix “0x” or “0X,” e.g. “0x3ED02”.\nHex strings are not affected by a bit_order argument — we ignore that argument.\nEach hex character naturally translates to four elements in a bit::vector. The hex string 0x0 is equivalent to the binary string 0000, and so on, up to string 0xF which is the same as the binary 1111.\nThe hex pair 0x0F will be interpreted in the vector as 00001111. Of course, this is the advantage of hex. It is a more compact format that occupies a quarter of the space needed to write out the equivalent binary string.\nHowever, what happens if you want to encode a vector whose size is not a multiple of 4? We handle that by allowing the final character in the string to have a base that is not 16. To accomplish that, we allow for an optional suffix, which must be one of _2, _4, or _8. If present, the prefix gives the base for just the preceding character in the otherwise hex-based string. If there is no suffix, the final character is assumed to be hex like all the others.\nSo the string 0x1 (no suffix, so the last character is the default hex base 16) is equivalent to 0001. On the other hand, the string 0x1_8 (the last character is base 8) is equivalent to 001. Similarly, the string 0x1_4 (the last character is base 4) is equivalent to 01 and finally, the string 0x1_2 (the previous character is base 2) is comparable to 1\nIn the string 0x3ED01_8, the first four characters 3, E, D, and 0 are interpreted as hex values, and each will consume four slots in the vector. However, that final 1_8 is parsed as an octal 1, which takes up three slots 001. Therefore, this vector has size 19 (i.e., 4*4 + 3).\n\n\n\n\n\n\nCareful with that final suffix character\n\n\n\nIf the suffix is present, the final character must fit inside the base given by that suffix. The string 0x3_8 is OK, but trying to parse 0x3_2 will result in a std::nullopt return value because the final character is not either 0 or 1, which are the only valid options for something that is supposed to be base 2.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    bit::vector v1(\"111\");\n2    bit::vector v2(\"0b111\");\n3    bit::vector v3(\"0x111\");\n4    bit::vector v4(\"0xF1\");\n5    bit::vector v5(\"0xF1_8\");\n6    bit::vector v6(\"0xF1_4\");\n7    bit::vector v7(\"0xF1_2\");\n\n    std::cout &lt;&lt; \"v1 = \" &lt;&lt; v1 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v2 = \" &lt;&lt; v2 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v3 = \" &lt;&lt; v3 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v4 = \" &lt;&lt; v4 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v5 = \" &lt;&lt; v5 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v6 = \" &lt;&lt; v6 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"v7 = \" &lt;&lt; v7 &lt;&lt; '\\n';\n}\n\n1\n\nConstruction from a string without a prefix. All characters are 0’s and 1’s so the string is interpreted as being binary,\n\n2\n\nConstruction from the identical binary string with the prefix 0b.\n\n3\n\nConstruction from the same digits, but each one is now interpreted as a hex character thanks to the 0x prefix\n\n4\n\nConstruction where the final character has no suffix, so by default, it is parsed as a hex/base-16 number.\n\n5\n\nConstruction where the final character has a suffix _8 so, parsed as a base-8 number.\n\n6\n\nConstruction where the final character has a suffix _4 so, parsed as a base-4 number.\n\n7\n\nConstruction where the final character has a suffix _2 so, parsed as a base-2 number.\n\n\nOutput\nv1 = [1 1 1]\nv2 = [1 1 1]\nv3 = [1 0 0 0 1 0 0 0 1 0 0 0]\nv4 = [1 1 1 1 1 0 0 0]\nv5 = [1 1 1 1 1 0 0]\nv6 = [1 1 1 1 1 0]\nv7 = [1 1 1 1 1]\n\n\nSee Also\nvector::from\nvector::block_constructor"
  },
  {
    "objectID": "content/polynomial/arithmetic.html",
    "href": "content/polynomial/arithmetic.html",
    "title": "bit::polynomial — Arithmetic",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\nWe have methods to perform arithmetic on a polynomial in-place and non-member functions that perform arithmetic between polynomials."
  },
  {
    "objectID": "content/polynomial/arithmetic.html#polynomials-versus-bit-vectors",
    "href": "content/polynomial/arithmetic.html#polynomials-versus-bit-vectors",
    "title": "bit::polynomial — Arithmetic",
    "section": "Polynomials versus bit-vectors",
    "text": "Polynomials versus bit-vectors\nWhile our polynomials are wrappers around their bit-vector of coefficients, we cannot just forward the addition operator to those data members. Vector addition requires equal-sized arguments, but we can add polynomials with different degrees.\nPolynomial multiplication involves convolving the two coefficient vectors in question.\nNote that in \\(\\FF\\), subtraction is the same as addition.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto p0 = bit::polynomial&lt;&gt;::random(3);\n    auto q = bit::polynomial&lt;&gt;::random(5);\n    auto p1 = p0;\n    p1 += q;\n    auto p2 = p0;\n    p2 *= q;\n    std::cout &lt;&lt; std::format(\"({}) + ({})   = {}\\n\", p0, q, p0 + q);\n    std::cout &lt;&lt; std::format(\"({}) - ({})   = {}\\n\", p0, q, p0 - q);\n    std::cout &lt;&lt; std::format(\"({}) += ({}) -&gt; {}\\n\", p0, q, p1);\n    std::cout &lt;&lt; std::format(\"({}) * ({})   = {}\\n\", p0, q, p0 * q);\n    std::cout &lt;&lt; std::format(\"({}) *= ({}) -&gt; {}\\n\", p0, q, p2);\n}\nOutput\n(x^1 + x^3) + (x^3 + x^4 + x^5)   = x^1 + x^4 + x^5\n(x^1 + x^3) - (x^3 + x^4 + x^5)   = x^1 + x^4 + x^5\n(x^1 + x^3) += (x^3 + x^4 + x^5) -&gt; x^1 + x^4 + x^5\n(x^1 + x^3) * (x^3 + x^4 + x^5)   = x^4 + x^5 + x^7 + x^8\n(x^1 + x^3) *= (x^3 + x^4 + x^5) -&gt; x^4 + x^5 + x^7 + x^8\n\nSee Also\npolynomial::squared\npolynomial::times_x"
  },
  {
    "objectID": "content/polynomial/stream.html",
    "href": "content/polynomial/stream.html",
    "title": "bit::polynomial — Stream Operator",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe supply the customary method to send a bit-polynomial to an output stream.\ntemplate&lt;std::unsigned_integral Block, typename Allocator&gt;\nstd::ostream &\noperator&lt;&lt;(std::ostream &s, const bit::polynomial&lt;Block, Allocator&gt; &rhs);\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto p = bit::polynomial&lt;&gt;::random(12);\n1    std::cout &lt;&lt; \"p(x) = \" &lt;&lt; p &lt;&lt; '\\n';\n2    std::cout &lt;&lt; \"p(y) = \" &lt;&lt; p.to_string(\"y\") &lt;&lt; '\\n';\n3    std::cout &lt;&lt; std::format(\"p(y) = {:y}\\n\", p);\n}\n\n1\n\nThis uses the output stream operator and the polynomial variable will always be the default x.\n\n2\n\nYou can use the polynomial::to_string method to customize the polynomial variable.\n\n3\n\nYou can also use the polynomial::formatter class to customize the polynomial variable.\n\n\nOutput\np(x) = 1 + x^1 + x^8 + x^10 + x^12\np(y) = 1 + y^1 + y^8 + y^10 + y^12\np(y) = 1 + y^1 + y^8 + y^10 + y^12\n\nSee Also\npolynomial::to_string\npolynomial::formatter\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/polynomial/reference.html",
    "href": "content/polynomial/reference.html",
    "title": "bit::polynomial::reference — Proxy Class",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\nbit::polynomial::reference is a publicly accessible nested proxy class that lets users interact with individual polynomial coefficients naturally.\nThe primary use of this class is to provide an l-value that can be returned from operator[] in the bit::polynomial class.\nIt is needed because the bit::polynomial class stores a cached degree variable that may need to get updated if you write to an individual coefficient.\nProfiling shows that precomputing the polynomial degree can significantly improve the efficiency of the class for at least some exacting use cases."
  },
  {
    "objectID": "content/polynomial/reference.html#member-functions",
    "href": "content/polynomial/reference.html#member-functions",
    "title": "bit::polynomial::reference — Proxy Class",
    "section": "Member Functions",
    "text": "Member Functions\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nconstructor\nThe bit-polynomial operator[] method automatically constructs a bit::polynomial::reference as needed.\n\n\noperator=\nAssigns a bool to the referenced coefficient.\n\n\nto_bool\nReturn the value of the referenced coefficient as a boolean.\n\n\noperator bool\nCasts the referenced coefficient to a boolean value.\n\n\nset_to(val)\nSets the value of the referenced polynomial coefficient to the passed argument.\n\n\nset\nSets the referenced polynomial coefficient to 1.\n\n\nreset\nSets the referenced polynomial coefficient to 0.\n\n\nflip\nFlips the referenced referenced polynomial coefficient from 1 to 0 and vice versa.\n\n\n\n\n\nSee Also\npolynomial::operator[]\npolynomial::get\npolynomial::set\npolynomial::reset"
  },
  {
    "objectID": "content/polynomial/degree.html",
    "href": "content/polynomial/degree.html",
    "title": "bit::polynomial — Polynomial Degree",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\nWe have methods to query and make use of a polynomial’s degree:"
  },
  {
    "objectID": "content/polynomial/degree.html#degree-versus-size",
    "href": "content/polynomial/degree.html#degree-versus-size",
    "title": "bit::polynomial — Polynomial Degree",
    "section": "Degree versus Size",
    "text": "Degree versus Size\nThe size of a polynomial as returned by the polynomial::size method is the number of its coefficients. The degree of a polynomial is the index of its highest non-trivial power term. For example, \\[\np(x) = x + x^3,\n\\] has a degree 3 and a size that is at least 4. If we write out all the coefficients it might be that \\[\np(x) = 0 + 1*x + 0*x^2 + 1*x^3 + 0*x4 + 0*x5,\n\\] with two trailing zero coefficients \\(p_4 = p_5 = 0\\) so the polynomial has size 6. In this case, the query p.monic() will return false and p.make_monic() will eliminate those.\n\n\n\n\n\n\nThe make_monic() method does not alter the memory footprint\n\n\n\nCalling make_monic on a non-zero polynomial simply ensures that size() == degree() + 1. No memory is released by this operation — see the polynomial::shrink_to_fit method."
  },
  {
    "objectID": "content/polynomial/degree.html#efficiency",
    "href": "content/polynomial/degree.html#efficiency",
    "title": "bit::polynomial — Polynomial Degree",
    "section": "Efficiency",
    "text": "Efficiency\nOperations on and between polynomials generally can ignore trailing zero coefficients. This can be an important efficiency consideration in some cases.\nAlgorithms and methods in the bit::polynomial class allow for this and internally work efficiently even if the polynomials are not monic. They do that by reimplementing some of the core bit::vector functionality to only consider underlying storage blocks up to and including the one containing the highest non-trivial power.\nIf you are implementing some new piece of functionality it might be efficient to call make_monic() as appropriate. You may well start out having only monic polynomials where there are no such junk elements but in the course of a method, those can easily get introduced.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    // lambda: Turns the degree of a polynomial into a string.\n    auto deg = [](auto& p) { return p.degree() == bit::polynomial&lt;&gt;::ndeg ? \"NONE\" : std::format(\"{}\", p.degree()); };\n\n    bit::polynomial&lt;&gt; p;\n    std::cout &lt;&lt; std::format(\"Polynomial p(x) = {} with coefficients {:p}.\\n\", p, p.coefficients());\n    std::cout &lt;&lt; std::format(\"Size: {}, degree: {}, monic: {}.\\n\\n\", p.size(), deg(p), p.monic());\n\n    p.resize(7);\n    std::cout &lt;&lt; std::format(\"Polynomial p(x) = {} with coefficients {:p}.\\n\", p, p.coefficients());\n    std::cout &lt;&lt; std::format(\"Size: {}, degree: {}, monic: {}.\\n\\n\", p.size(), deg(p), p.monic());\n\n    p[1] = p[3] = 1;\n    std::cout &lt;&lt; std::format(\"Polynomial p(x) = {} with coefficients {:p}.\\n\", p, p.coefficients());\n    std::cout &lt;&lt; std::format(\"Size: {}, degree: {}, monic: {}.\\n\\n\", p.size(), deg(p), p.monic());\n\n    p.make_monic();\n    std::cout &lt;&lt; std::format(\"Polynomial p(x) = {} with coefficients {:p}.\\n\", p, p.coefficients());\n    std::cout &lt;&lt; std::format(\"Size: {}, degree: {}, monic: {}.\\n\\n\", p.size(), deg(p), p.monic());\n\n    p[1] = 0;\n    std::cout &lt;&lt; std::format(\"Polynomial p(x) = {} with coefficients {:p}.\\n\", p, p.coefficients());\n    std::cout &lt;&lt; std::format(\"Size: {}, degree: {}, monic: {}.\\n\\n\", p.size(), deg(p), p.monic());\n\n    p[3] = 0;\n    std::cout &lt;&lt; std::format(\"Polynomial p(x) = {} with coefficients {:p}.\\n\", p, p.coefficients());\n    std::cout &lt;&lt; std::format(\"Size: {}, degree: {}, monic: {}.\\n\", p.size(), deg(p), p.monic());\n}\nOutput\nPolynomial p(x) = 0 with coefficients [].\nSize: 0, degree: NONE, monic: false.\n\nPolynomial p(x) = 0 with coefficients [0 0 0 0 0 0 0].\nSize: 7, degree: NONE, monic: false.\n\nPolynomial p(x) = x^1 + x^3 with coefficients [0 1 0 1 0 0 0].\nSize: 7, degree: 3, monic: false.\n\nPolynomial p(x) = x^1 + x^3 with coefficients [0 1 0 1].\nSize: 4, degree: 3, monic: true.\n\nPolynomial p(x) = x^3 with coefficients [0 0 0 1].\nSize: 4, degree: 3, monic: true.\n\nPolynomial p(x) = 0 with coefficients [0 0 0 0].\nSize: 4, degree: NONE, monic: false.\n\nSee Also\npolynomial::size\npolynomial::resize\npolynomial::empty\npolynomial::clear\npolynomial::zero\npolynomial::nonzero\npolynomial::to_string\npolynomial::shrink_to_fit"
  },
  {
    "objectID": "content/polynomial/access.html",
    "href": "content/polynomial/access.html",
    "title": "bit::polynomial — Coefficient Access",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods to access the coefficients of the polynomial either individually or as a whole.\n1constexpr bool          operator[](std::size_t i) const;\n2constexpr reference     operator[](std::size_t i);\n\n3constexpr bool          get(std::size_t i) const;\n4constexpr polynomial&   set(std::size_t i, bool val=true)\n5constexpr polynomial&   reset(std::size_t i)\n\n6constexpr polynomial&   set()\n7constexpr polynomial&   reset()\n\n8constexpr const vector_type& coefficients() const;\n9constexpr polynomial& set_coefficients(vector_type&  c);\n10constexpr polynomial& set_coefficients(vector_type&& c);\n\n1\n\nRead-only access to coefficient i.\n\n2\n\nReturns a polynomial::reference object — allows modification of coefficient i.\n\n3\n\nAnother way to get read-only access to coefficient i..\n\n4\n\nSet the value of coefficient i to val.\n\n5\n\nSet the value of coefficient i to false.\n\n6\n\nSets all the polynomial coefficients to 1.\n\n7\n\nSets all the polynomial coefficients to 0.\n\n8\n\nRead-only access to all the polynomial coefficients as a bit-vector.\n\n9\n\nSets the polynomial coefficients by copying the passed-in bit-vector.\n\n10\n\nSets the polynomial coefficients by moving the passed-in bit-vector into place.\n\n\n\n\n\n\n\n\nBounds checking\n\n\n\nGenerally, the methods do not check whether the index i is in bounds. The behavior is undefined if it is out of bounds, but it will surely not be good! Set the BIT_DEBUG flag at compile time to check this condition — any violation will cause the program to abort with a helpful message.\n\n\nThe vector_type is simply a bit::vector with the appropriate Block and Allocator template parameters.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::polynomial&lt;&gt; p{6};\n    std::cout &lt;&lt; std::format(\"p(x) = {} has coefficients {:p}\\n\", p, p.coefficients());\n\n    p[0] = p[3] = 1;\n    std::cout &lt;&lt; std::format(\"p(x) = {} has coefficients {:p}\\n\", p, p.coefficients());\n\n    p.reset(3);\n    p.set(5);\n    std::cout &lt;&lt; std::format(\"p(x) = {} has coefficients {:p}\\n\\n\", p, p.coefficients());\n\n    auto v = bit::vector&lt;&gt;::checker_board(10);\n    std::cout &lt;&lt; std::format(\"Before call v = {:p}\\n\", v);\n    p.set_coefficients(v);\n    std::cout &lt;&lt; std::format(\"p.set_coefficients(v) gives p = {}.\\n\", p);\n    std::cout &lt;&lt; std::format(\"After call v = {:p}\\n\\n\", v);\n\n    std::cout &lt;&lt; std::format(\"Before call v = {:p}\\n\", v);\n    p.set_coefficients(std::move(v));\n    std::cout &lt;&lt; std::format(\"p.set_coefficients(std::move(v)) gives p = {}.\\n\", p);\n    std::cout &lt;&lt; std::format(\"After call v = {:p}\\n\", v);\n}\nOutput\np(x) = 0 has coefficients [0 0 0 0 0 0]\np(x) = 1 + x^3 has coefficients [1 0 0 1 0 0]\np(x) = 1 + x^5 has coefficients [1 0 0 0 0 1]\n\nBefore call v = [1 0 1 0 1 0 1 0 1 0]\np.set_coefficients(v) gives p = 1 + x^2 + x^4 + x^6 + x^8.\nAfter call v = [1 0 1 0 1 0 1 0 1 0]\n\nBefore call v = [1 0 1 0 1 0 1 0 1 0]\np.set_coefficients(std::move(v)) gives p = 1 + x^2 + x^4 + x^6 + x^8.\nAfter call v = []\n\nSee Also\npolynomial::reference\npolynomial::size\n[bit_assert]\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/polynomial/times_x.html",
    "href": "content/polynomial/times_x.html",
    "title": "bit::polynomial — Multiplication by \\(x^n\\)",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods that multiply a polynomial by \\(x^n\\) where \\(n\\) defaults to 1.\nconstexpr polynomial&\n1times_x(std::size_t n = 1);\n\nconstexpr polynomial\n2times_x(const polynomial& p, std::size_t n = 1);\n\n1\n\nThis multiplies this polynomial by \\(x^n\\) in place.\n\n2\n\nThis returns a new polynomial that is this one multiplied by \\(x^n\\).\n\n\nThese methods are faster than using the multiplication operator.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto x3 = bit::polynomial&lt;&gt;::power(3);\n    bit::polynomial p{6};\n    p.set();\n\n    std::cout &lt;&lt; std::format(\"p(x)            = {}\\n\", p);\n    std::cout &lt;&lt; std::format(\"x^3 * p(x)      = {}\\n\", x3 * p);\n    std::cout &lt;&lt; std::format(\"p(x).times_x(3) = {}\\n\", p.times_x(3));\n}\nOutput\np(x)            = 1 + x^1 + x^2 + x^3 + x^4 + x^5\nx^3 * p(x)      = x^3 + x^4 + x^5 + x^6 + x^7 + x^8\np(x).times_x(3) = x^3 + x^4 + x^5 + x^6 + x^7 + x^8\n\nSee Also\npolynomial::squared\nvector::operator&gt;&gt;=\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/polynomial/size.html",
    "href": "content/polynomial/size.html",
    "title": "bit::polynomial — Polynomial Size",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\nWe have methods to query and set the size of a polynomial."
  },
  {
    "objectID": "content/polynomial/size.html#size-versus-degree",
    "href": "content/polynomial/size.html#size-versus-degree",
    "title": "bit::polynomial — Polynomial Size",
    "section": "Size versus Degree",
    "text": "Size versus Degree\nIt is important to distinguish between the size of a polynomial and its degree. The size is the number of coefficients, while the degree as returned by the polynomial::degree method is the index of its highest non-trivial power term.\nFor example, \\[\np(x) = x + x^3,\n\\] has a degree 3 and a size that is at least 4. If we write out all the coefficients it might be that \\[\np(x) = 0 + 1*x + 0*x^2 + 1*x^3 + 0*x4 + 0*x5,\n\\] with two trailing zero coefficients \\(p_4 = p_5 = 0\\) so the polynomial has size 6. Those can be eliminated by the polynomial::make_monic method. Even if there are lots of trailing zeros, internally the class methods remain efficient and ignore them.\n\n\n\n\n\n\nThe zero polynomial\n\n\n\nThe zero polynomial might have no coefficients so size() == 0, or it might have lots of zero coefficients and a size() &gt; 0. In either case, the degree will be the special “not a degree” constant polynomial::ndeg.\nMethods usually need to treat the zero-polynomial as a special, generally trivial, edge case."
  },
  {
    "objectID": "content/polynomial/size.html#resizing",
    "href": "content/polynomial/size.html#resizing",
    "title": "bit::polynomial — Polynomial Size",
    "section": "Resizing",
    "text": "Resizing\nThe resize(n) method alters the polynomial to have n coefficients.\nIf n &gt; size() the added coefficients are zeros so the degree of the polynomial is not changed. The memory footprint consumed by the polynomial may increase.\nOn the other hand, if n &lt; size() we drop terms in the polynomial which may lower its degree. However, even if we decrease the polynomial size, no memory is released."
  },
  {
    "objectID": "content/polynomial/size.html#memory-usage",
    "href": "content/polynomial/size.html#memory-usage",
    "title": "bit::polynomial — Polynomial Size",
    "section": "Memory Usage",
    "text": "Memory Usage\nThe capacity() method returns the number of coefficients that a polynomial can have without causing any new memory allocation to happen. The method is a pass-through to the vector::capacity method for the underlying coefficient bit-vector.\nA nonzero polynomial has at least degree() + 1 coefficients but may have many more that as trailing zeros. Beyond that, the coefficient bit-vector can have spare capacity that is only ever reachable by using the resize() method. Resizing up to the capacity causes no memory allocation so is very efficient but of course, having lots of spare capacity can be resource wasteful.\n\n\n\n\n\n\nMemory footprint.\n\n\n\nTo minimize the memory used by a polynomial use the polynomial::shrink_to_fit method.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    // lambda: Turns the degree of a polynomial into a string.\n    auto deg = [](auto& p) { return p.degree() == bit::polynomial&lt;&gt;::ndeg ? \"NONE\" : std::format(\"{}\", p.degree()); };\n\n    bit::polynomial&lt;&gt; p;\n    std::cout &lt;&lt; std::format(\"Polynomial p(x) = {} with coefficients {:p}.\\n\", p, p.coefficients());\n    std::cout &lt;&lt; std::format(\"Size: {}, degree: {}, monic: {}.\\n\\n\", p.size(), deg(p), p.monic());\n\n    p.resize(7);\n    std::cout &lt;&lt; std::format(\"Polynomial p(x) = {} with coefficients {:p}.\\n\", p, p.coefficients());\n    std::cout &lt;&lt; std::format(\"Size: {}, degree: {}, monic: {}.\\n\\n\", p.size(), deg(p), p.monic());\n\n    p[1] = p[3] = 1;\n    std::cout &lt;&lt; std::format(\"Polynomial p(x) = {} with coefficients {:p}.\\n\", p, p.coefficients());\n    std::cout &lt;&lt; std::format(\"Size: {}, degree: {}, monic: {}.\\n\\n\", p.size(), deg(p), p.monic());\n\n    p.resize(3);\n    std::cout &lt;&lt; std::format(\"Polynomial p(x) = {} with coefficients {:p}.\\n\", p, p.coefficients());\n    std::cout &lt;&lt; std::format(\"Size: {}, degree: {}, monic: {}.\\n\\n\", p.size(), deg(p), p.monic());\n\n    p.clear();\n    std::cout &lt;&lt; std::format(\"Polynomial p(x) = {} with coefficients {:p}.\\n\", p, p.coefficients());\n    std::cout &lt;&lt; std::format(\"Size: {}, degree: {}, monic: {}.\\n\", p.size(), deg(p), p.monic());\n}\nOutput\nPolynomial p(x) = 0 with coefficients [].\nSize: 0, degree: NONE, monic: false.\n\nPolynomial p(x) = 0 with coefficients [0 0 0 0 0 0 0].\nSize: 7, degree: NONE, monic: false.\n\nPolynomial p(x) = x^1 + x^3 with coefficients [0 1 0 1 0 0 0].\nSize: 7, degree: 3, monic: false.\n\nPolynomial p(x) = x^1 with coefficients [0 1 0].\nSize: 3, degree: 1, monic: false.\n\nPolynomial p(x) = 0 with coefficients [].\nSize: 0, degree: NONE, monic: false.\n\nSee Also\npolynomial::degree\npolynomial::monic\npolynomial::make_monic\npolynomial::to_string\npolynomial::shrink_to_fit"
  },
  {
    "objectID": "content/polynomial/evaluation.html",
    "href": "content/polynomial/evaluation.html",
    "title": "bit::polynomial — Polynomial Evaluation",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\nWe have methods to evaluate a polynomial for scalar and bit-matrix arguments."
  },
  {
    "objectID": "content/polynomial/evaluation.html#scalar-arguments",
    "href": "content/polynomial/evaluation.html#scalar-arguments",
    "title": "bit::polynomial — Polynomial Evaluation",
    "section": "Scalar Arguments",
    "text": "Scalar Arguments\nLet \\[\np(x) = p_0 + p_1 x + p_2 x^2 + \\cdots + p_{n-1} x^{n-1}.\n\\]\nIn GF(2), arithmetic is mod 2, which means that for any scalar argument \\(x\\) \\[\np(x) = p_0 + p_1 x + p_2 x + \\cdots + p_{n-1} x.\n\\] If \\(x = 0\\), this is just p[0], while if \\(x = 1\\), it is the count of ones (mod 2) in the polynomial coefficients.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::polynomial p{16, [](size_t k) { return (k + 1) % 2; }};\n    std::cout &lt;&lt; std::format(\"p(x) = {}\\np(0) = {:d}, p(1) = {:d}\\n\", p, p(0), p(1));\n\n    bit::polynomial q{17, [](size_t k) { return (k + 1) % 2; }};\n    std::cout &lt;&lt; std::format(\"q(x) = {}\\nq(0) = {:d}, q(1) = {:d}\\n\", q, q(0), q(1));\n}\nOutput\np(x) = 1 + x^2 + x^4 + x^6 + x^8 + x^10 + x^12 + x^14\np(0) = 1, p(1) = 0\nq(x) = 1 + x^2 + x^4 + x^6 + x^8 + x^10 + x^12 + x^14 + x^16\nq(0) = 1, q(1) = 1"
  },
  {
    "objectID": "content/polynomial/evaluation.html#matrix-arguments",
    "href": "content/polynomial/evaluation.html#matrix-arguments",
    "title": "bit::polynomial — Polynomial Evaluation",
    "section": "Matrix Arguments",
    "text": "Matrix Arguments\nIf M is a square bit-matrix then we can evaluate the sum: \\[\np(M) = p_0 I + p_1 M + p_2 M^2 + \\cdots + p_{n-1} M^{n-1}.\n\\] I is the identity matrix with identical dimensions to M. The sum uses Horner’s method.\n\n\n\n\n\n\nThe bit-matrix argument must be square\n\n\n\nThe input matrix must be square, and the bit_always_assert macro checks that pre-condition.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto M = bit::matrix&lt;&gt;::identity(6);\n    std::cout &lt;&lt; std::format(\"Bit-matrix M:\\n{}\\n\", M);\n\n    bit::polynomial p{16, [](size_t k) { return (k + 1) % 2; }};\n    std::cout &lt;&lt; std::format(\"p(M): {:M}\\n{}\\n\", p, p(M));\n\n    bit::polynomial q{17, [](size_t k) { return (k + 1) % 2; }};\n    std::cout &lt;&lt; std::format(\"q(M): {:M}\\n{}\\n\", q, q(M));\n}\nOutput\nBit-matrix M:\n100000\n010000\n001000\n000100\n000010\n000001\np(M): 1 + M^2 + M^4 + M^6 + M^8 + M^10 + M^12 + M^14\n000000\n000000\n000000\n000000\n000000\n000000\nq(M): 1 + M^2 + M^4 + M^6 + M^8 + M^10 + M^12 + M^14 + M^16\n100000\n010000\n001000\n000100\n000010\n000001\n\nSee Also\nmatrix::pow\nmatrix::pow2"
  },
  {
    "objectID": "content/polynomial/split.html",
    "href": "content/polynomial/split.html",
    "title": "bit::polynomial — Polynomial Splitting",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have a method to split a polynomial \\(p(x)\\) of degree \\(n\\) into two polynomials, \\(l(x)\\) and \\(h(x)\\), such that \\[\np(x) = l(x) + x^n h(x),\n\\] where the degree of \\(l(x)\\) is less than \\(n\\).\nconstexpr void split(std::size_t n, polynomial& l, polynomial& h);\nThis method is useful for implementing some polynomial algorithms.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto p = bit::polynomial&lt;&gt;::random(17);\n\n    bit::polynomial lo, hi;\n    std::size_t n = 7;\n    p.split(n, lo, hi);\n    std::cout &lt;&lt; std::format(\"p           = {}\\n\", p);\n    std::cout &lt;&lt; std::format(\"lo          = {}\\n\", lo);\n    std::cout &lt;&lt; std::format(\"hi          = {}\\n\", hi);\n    std::cout &lt;&lt; std::format(\"lo + x^{} hi = {}\\n\", n, lo + hi.times_x(7));\n}\nOutput\np           = 1 + x^1 + x^2 + x^4 + x^10 + x^11 + x^17\nlo          = 1 + x^1 + x^2 + x^4\nhi          = x^3 + x^4 + x^10\nlo + x^7 hi = 1 + x^1 + x^2 + x^4 + x^10 + x^11 + x^17\n\nSee Also\npolynomial::sub\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/polynomial/special.html",
    "href": "content/polynomial/special.html",
    "title": "bit::polynomial — Is the Polynomial Special?",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods to query if this polynomial is “special” in some way.\n1constexpr bool zero()       const;\n2constexpr bool nonzero()    const;\n3constexpr bool one()        const;\n4constexpr bool constant()   const;\n\n1\n\nReturns true if this is any form of the zero polynomial.\n\n2\n\nReturns true as long as this is not the zero polynomial.\n\n3\n\nReturns true if this is the polynomial \\(p(x) = 1\\).\n\n4\n\nReturns true if this is either the zero or the one polynomial.\n\n\n\n\n\n\n\n\nThe zero polynomial\n\n\n\nThe zero polynomial might have no coefficients so size() == 0, or it might have lots of zero coefficients and a size() &gt; 0. In either case, the degree will be the special “not a degree” constant polynomial::ndeg.\nMethods usually need to treat the zero-polynomial as a special, generally trivial, edge case.\n\n\n\nSee Also\npolynomial::size\npolynomial::empty\npolynomial::degree\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/polynomial/constructors.html",
    "href": "content/polynomial/constructors.html",
    "title": "bit::polynomial — Construction",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nConstructors for a bit-polynomial.\n1explicit constexpr bit::polynomial(std::size_t n = 0);\n\n2explicit constexpr bit::polynomial(const vector_type& coeffs);\n\n3explicit constexpr bit::polynomial(const vector_type&& coeffs);\n\nexplicit constexpr\n4bit::polynomial(std::size_t n, std::invocable&lt;std::size_t&gt; auto f);\n\n1\n\nConstructs a zero bit-polynomial with n coefficients all set to 0. The default constructor creates the empty polynomial which is also treated as the zero polynomial.\n\n2\n\nCreate a bit-polynomial by copying a prefilled bit-vector of coefficients.\n\n3\n\nCreate a bit-polynomial by moving a prefilled bit-vector of coefficients.\n\n4\n\nConstruct a bit-polynomial with n elements using a function that takes a std::size_t argument. Coefficient i in the polynomial is set to 1 if f(i) != 0; otherwise it is 0.\n\n\nThe first method above creates the zero polynomial with \\(n\\) coefficients all set to 0. Presumably, at least some of those coefficients will get set to 1 later. The default value \\(n = 0\\) results in the empty polynomial whose coefficient vector takes up almost no memory. The class treats the empty polynomial as another form of the zero polynomial \\(p(x) = 0\\).\nWe also have methods to construct a polynomial from a prefilled bit-vector of coefficients. By default, we will simply copy those coefficients into the polynomial’s store but if the coefficients are no longer needed after polynomial construction then we can save some copying and instead move the coefficients directly into place with code like bit::polynomial p{std::move(coeff)};\nThe last method above is a little convenience constructor used in various test codes.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    bit::polynomial p0;\n    std::cout &lt;&lt; std::format(\"p0(x) = {} has size {} and coefficients {:p}\\n\", p0, p0.size(), p0.coefficients());\n\n2    bit::polynomial p1{11};\n    std::cout &lt;&lt; std::format(\"p1(x) = {} has size {} and coefficients {:p}\\n\", p1, p1.size(), p1.coefficients());\n\n3    auto p2 = bit::polynomial&lt;&gt;::random(7);\n    std::cout &lt;&lt; std::format(\"p2(x) = {} has size {} and coefficients {:p}\\n\", p2, p2.size(), p2.coefficients());\n\n4    bit::polynomial p3{8, [](size_t k) { return (k + 1) % 2; }};\n    std::cout &lt;&lt; std::format(\"p3(x) = {} has size {} and coefficients {:p}\\n\", p3, p3.size(), p3.coefficients());\n}\n\n1\n\nDefault constructor makes an empty polynomial which is treated as a form of the zero polynomial.\n\n2\n\nAnother zero-polynomial—this one has 11 zero coefficients.\n\n3\n\nA random polynomial of degree 7 with eight coefficients and the final one is always 1.\n\n4\n\nA polynomial with every second one set to 0.\n\n\nOutput\np0(x) = 0 has size 0 and coefficients []\np1(x) = 0 has size 11 and coefficients [0 0 0 0 0 0 0 0 0 0 0]\np2(x) = 1 + x^2 + x^3 + x^4 + x^7 has size 8 and coefficients [1 0 1 1 1 0 0 1]\np3(x) = 1 + x^2 + x^4 + x^6 has size 8 and coefficients [1 0 1 0 1 0 1 0]\n\nSee Also\npolynomial::random\npolynomial::power\nvector::constructors\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/all.html",
    "href": "content/matrix/all.html",
    "title": "bit::matrix — Check on Set Bits",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nChecks whether all, any, or none of the elements in a bit-matrix are set (i.e. 1).\n1constexpr bool all() const;\n2constexpr bool any() const;\n3constexpr bool none() const;\n\n1\n\nReturn true if all the elements in the bit-matrix are 1; otherwise, false.\n\n2\n\nReturn true if any elements in the bit-matrix are 1; otherwise, false.\n\n3\n\nReturn true if none of the elements in the bit-matrix are 1; otherwise, false.\n\n\n\n\n\n\n\n\nEmpty bit-matrices\n\n\n\nCalling these methods for an empty bit-matrix is likely an error — if you set the BIT_DEBUG flag at compile time, we throw an exception with a helpful message. If the BIT_DEBUG flag is not set, all() and none() both return true while any() will return false.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::matrix&lt;&gt; m1(\"000 000 000\");\n    bit::matrix&lt;&gt; m2(\"010 101 010\");\n    bit::matrix&lt;&gt; m3(\"111 111 111\");\n\n    std::cout\n        &lt;&lt; \"matrix\\t\\t\" &lt;&lt; \"all\\t\" &lt;&lt; \"any\\t\" &lt;&lt; \"none\\n\"\n        &lt;&lt; m1 &lt;&lt; \"\\t\\t\" &lt;&lt; m1.all() &lt;&lt; '\\t' &lt;&lt; m1.any() &lt;&lt; '\\t' &lt;&lt; m1.none() &lt;&lt; \"\\n\\n\"\n        &lt;&lt; m2 &lt;&lt; \"\\t\\t\" &lt;&lt; m2.all() &lt;&lt; '\\t' &lt;&lt; m2.any() &lt;&lt; '\\t' &lt;&lt; m2.none() &lt;&lt; \"\\n\\n\"\n        &lt;&lt; m3 &lt;&lt; \"\\t\\t\" &lt;&lt; m3.all() &lt;&lt; '\\t' &lt;&lt; m3.any() &lt;&lt; '\\t' &lt;&lt; m3.none() &lt;&lt; \"\\n\";\n}\nOutput\nmatrix          all     any     none\n│0 0 0│\n│0 0 0│\n│0 0 0│         0       0       1\n\n│0 1 0│\n│1 0 1│\n│0 1 0│         0       1       0\n\n│1 1 1│\n│1 1 1│\n│1 1 1│         1       1       0\n\nSee Also\nmatrix::count\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/stream.html",
    "href": "content/matrix/stream.html",
    "title": "bit::matrix — Stream Operators",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nMethods to insert or extract a bit-matrix from a stream.\ntemplate&lt;std::unsigned_integral Block, typename Allocator&gt;\nstd::ostream &\n1operator&lt;&lt;(std::ostream &s, const matrix&lt;Block, Allocator&gt; &M);\n\ntemplate&lt;std::unsigned_integral Block, typename Allocator&gt;\nstd::istream &\n2operator&gt;&gt;(std::istream &s, matrix&lt;Block, Allocator&gt; &M);\n\n1\n\nWrites a binary string representation of a bit-matrix to an output stream.\n\n2\n\nFill a bit-matrix by reading bits encoded as a binary or hex string from a stream.\n\n\nThe input stream operator will throw a std::invalid_argument exception on parse failures.\nThe bit-matrix is printed row-by-row, separated by newlines. Each row is printed as a bit::vector in vector-order so row \\(i\\) is in the order \\(M_{i0}M_{i1}M_{i2}\\cdots\\). The input stream operator can handle other row separators and hex-formatted strings.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    // Read from a stream until we have a parse error ...\n    while (true) {\n        bit::matrix&lt;&gt; m;\n        std::cout &lt;&lt; \"bit::matrix? \";\n        try {\n            std::cin &gt;&gt; m;\n            std::cout &lt;&lt; \"Parsed as:\\n\" &lt;&lt; m &lt;&lt; std::endl;\n        }\n        catch (...) {\n            std::cout &lt;&lt; \"Couldn't parse that input as a bit::matrix! Quitting ...\" &lt;&lt; std::endl;\n            break;\n        }\n    }\n}\n\nInput and Output:\nbit::matrix? 11111 10101 01010; 00100\nParsed as:\n│1 1 1 1 1│\n│1 0 1 0 1│\n│0 1 0 1 0│\n│0 0 1 0 0│\nbit::matrix? 0xff 0xf2 0x3e 0x45\nParsed as:\n│1 1 1 1 1 1 1 1│\n│1 1 1 1 0 1 0 0│\n│1 1 0 0 0 1 1 1│\n│0 0 1 0 1 0 1 0│\nbit::matrix? q\nCouldn't parse that input as a bit::matrix! Quitting ...\n\n\nSee Also\nmatrix::to_string\nmatrix::to_pretty_string\nmatrix::to_hex\nmatrix::print\nmatrix::description\nmatrix::from\nvector::stream&lt;&lt;\nvector::stream&gt;&gt;\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/specials.html",
    "href": "content/matrix/specials.html",
    "title": "bit::matrix — Create Special Bit-Matrices",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe supply factory methods to construct some special well-known bit-matrices.\nstatic constexpr bit::matrix\n1ones(std::size_t r, std::size_t c);\nstatic constexpr bit::matrix\n2ones(std::size_t n);\n\nstatic constexpr bit::matrix\n3zeros(std::size_t r, std::size_t c);\nstatic constexpr bit::matrix\n4zeros(std::size_t n);\n\nstatic constexpr bit::matrix\n5checker_board(std::size_t r, std::size_t c, int first = 1);\nstatic constexpr bit::matrix\n6checker_board(std::size_t n, int first = 1);\n\nstatic constexpr bit::matrix\n7identity(std::size_t n);\n\nstatic constexpr bit::matrix\n8shift(std::size_t n, int p = -1);\n\nstatic constexpr bit::matrix\n9rotate(std::size_t n, int p = -1);\n\n1\n\nReturns an r x c bit-matrix where all the elements are set to 1.\n\n2\n\nReturns an n x n square bit-matrix where all the elements are set to 1.\n\n3\n\nReturns an r x c bit-matrix where all the elements are set to 0.\n\n4\n\nReturns an n x n square bit-matrix where all the elements are set to 0.\n\n5\n\nReturns an r x c bit-matrix where the elements form a checker-board pattern.\n\n6\n\nReturns an n x n square bit-matrix where the elements form a checker-board pattern.\n\n7\n\nReturns the n x n identity bit-matrix (ones on the diagonal, other elements all zero).\n\n8\n\nReturns the n x n bit-matrix that shifts a bit-vector by p slots to the right if p &gt; 0 and the left if p &lt; 0.\n\n9\n\nReturns the n x n bit-matrix that rotates a bit-vector by p slots to the right if p &gt; 0 and the left if p &lt; 0.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto ones = bit::matrix&lt;&gt;::ones(4);\n    std::cout &lt;&lt; \"The all-set matrix:\\n\" &lt;&lt; ones &lt;&lt; \"\\n\\n\";\n\n    auto ident = bit::matrix&lt;&gt;::identity(8);\n    std::cout &lt;&lt; \"The identity matrix:\\n\" &lt;&lt; ident &lt;&lt; \"\\n\\n\";\n\n    auto shiftr = bit::matrix&lt;&gt;::shift(8, 1);\n    std::cout &lt;&lt; \"The shift right one place matrix:\\n\" &lt;&lt; shiftr &lt;&lt; \"\\n\\n\";\n\n    auto shiftl = bit::matrix&lt;&gt;::shift(8, -1);\n    std::cout &lt;&lt; \"The shift left one place matrix:\\n\" &lt;&lt; shiftl &lt;&lt; \"\\n\\n\";\n\n    auto rotr= bit::matrix&lt;&gt;::rotate(8, 1);\n    std::cout &lt;&lt; \"The rotate right one place matrix:\\n\" &lt;&lt; rotr &lt;&lt; \"\\n\\n\";\n\n    auto rotl = bit::matrix&lt;&gt;::rotate(8, -1);\n    std::cout &lt;&lt; \"The rotate left one place matrix:\\n\" &lt;&lt; rotl &lt;&lt; \"\\n\\n\";\n\n    auto u = bit::vector&lt;&gt;::ones(8);\n    std::cout &lt;&lt; \"Product identity matrix with \" &lt;&lt; u &lt;&lt; \" yields \" &lt;&lt; dot(ident,  u) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Product shiftr matrix with   \" &lt;&lt; u &lt;&lt; \" yields \" &lt;&lt; dot(shiftr, u) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Product shiftl matrix with   \" &lt;&lt; u &lt;&lt; \" yields \" &lt;&lt; dot(shiftl, u) &lt;&lt; '\\n';\n\n    u[0] = 0;\n    std::cout &lt;&lt; \"Product rotr matrix with     \" &lt;&lt; u &lt;&lt; \" yields \" &lt;&lt; dot(rotr,   u) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Product rotl matrix with     \" &lt;&lt; u &lt;&lt; \" yields \" &lt;&lt; dot(rotl,   u) &lt;&lt; \"\\n\\n\";\n\n    auto C1 = bit::matrix&lt;&gt;::checker_board(4,1);\n    auto C0 = bit::matrix&lt;&gt;::checker_board(4,0);\n    std::cout &lt;&lt; \"Two checker-board matrices:\\n\";\n    bit::print(C0, C1);\n}\nOutput\nThe all-set matrix:\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\n\nThe identity matrix:\n│1 0 0 0 0 0 0 0│\n│0 1 0 0 0 0 0 0│\n│0 0 1 0 0 0 0 0│\n│0 0 0 1 0 0 0 0│\n│0 0 0 0 1 0 0 0│\n│0 0 0 0 0 1 0 0│\n│0 0 0 0 0 0 1 0│\n│0 0 0 0 0 0 0 1│\n\nThe shift right one place matrix:\n│0 1 0 0 0 0 0 0│\n│0 0 1 0 0 0 0 0│\n│0 0 0 1 0 0 0 0│\n│0 0 0 0 1 0 0 0│\n│0 0 0 0 0 1 0 0│\n│0 0 0 0 0 0 1 0│\n│0 0 0 0 0 0 0 1│\n│0 0 0 0 0 0 0 0│\n\nThe shift left one place matrix:\n│0 0 0 0 0 0 0 0│\n│1 0 0 0 0 0 0 0│\n│0 1 0 0 0 0 0 0│\n│0 0 1 0 0 0 0 0│\n│0 0 0 1 0 0 0 0│\n│0 0 0 0 1 0 0 0│\n│0 0 0 0 0 1 0 0│\n│0 0 0 0 0 0 1 0│\n\nThe rotate right one place matrix:\n│0 1 0 0 0 0 0 0│\n│0 0 1 0 0 0 0 0│\n│0 0 0 1 0 0 0 0│\n│0 0 0 0 1 0 0 0│\n│0 0 0 0 0 1 0 0│\n│0 0 0 0 0 0 1 0│\n│0 0 0 0 0 0 0 1│\n│1 0 0 0 0 0 0 0│\n\nThe rotate left one place matrix:\n│0 0 0 0 0 0 0 1│\n│1 0 0 0 0 0 0 0│\n│0 1 0 0 0 0 0 0│\n│0 0 1 0 0 0 0 0│\n│0 0 0 1 0 0 0 0│\n│0 0 0 0 1 0 0 0│\n│0 0 0 0 0 1 0 0│\n│0 0 0 0 0 0 1 0│\n\nProduct identity matrix with [1 1 1 1 1 1 1 1] yields [1 1 1 1 1 1 1 1]\nProduct shiftr matrix with   [1 1 1 1 1 1 1 1] yields [1 1 1 1 1 1 1 0]\nProduct shiftl matrix with   [1 1 1 1 1 1 1 1] yields [0 1 1 1 1 1 1 1]\nProduct rotr matrix with     [0 1 1 1 1 1 1 1] yields [1 1 1 1 1 1 1 0]\nProduct rotl matrix with     [0 1 1 1 1 1 1 1] yields [1 0 1 1 1 1 1 1]\n\nTwo checker-board matrices:\n0101    1010\n1010    0101\n0101    1010\n1010    0101\n\nSee Also\nmatrix::is_zero\nmatrix::is_ones\nmatrix::is_identity\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/is_special.html",
    "href": "content/matrix/is_special.html",
    "title": "bit::matrix — Is a Bit-Matrix Special?",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nCheck to see if this bit-matrix is “special” in some way.\n1constexpr bool is_zero() const;\n2constexpr bool is_ones() const;\n3constexpr bool is_identity() const;\n4constexpr bool is_square()   const;\n5constexpr bool is_symmetric() const;\n\n1\n\nAre all the bit-matrix elements all 0?\n\n2\n\nAre all the bit-matrix elements all 1?\n\n3\n\nIs this bit-matrix square? Empty bit-matrices are NOT considered to be square.\n\n4\n\nIs this the identity bit-matrix?\n\n5\n\nIs this the bit-matrix symmetric (must be square)\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto ident = bit::matrix&lt;&gt;::identity(8);\n\n    // Little lambda that turns a bool into a string\n    auto b2s = [](bool x) { return x ? \"YES\" : \"NO\"; };\n\n    std::cout &lt;&lt; \"bit-matrix is_zero?      \" &lt;&lt; b2s(ident.is_zero())      &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"bit-matrix is_ones?      \" &lt;&lt; b2s(ident.is_ones())      &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"bit-matrix is_identity?  \" &lt;&lt; b2s(ident.is_identity())  &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"bit-matrix is_square?    \" &lt;&lt; b2s(ident.is_square())    &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"bit-matrix is_symmetric? \" &lt;&lt; b2s(ident.is_symmetric()) &lt;&lt; \"\\n\";\n}\nOutput\nbit-matrix is_zero?      NO\nbit-matrix is_ones?      NO\nbit-matrix is_identity?  YES\nbit-matrix is_square?    YES\nbit-matrix is_symmetric? YES\n\nSee Also\nmatrix::ones\nmatrix::zeros\nmatrix::identity\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/characteristic_polynomial.html",
    "href": "content/matrix/characteristic_polynomial.html",
    "title": "bit::matrix — Characteristic Polynomial",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nFinds the characteristic polynomial of a square bit-matrix.\nbit::vector&lt;Block, Allocator&gt;\ncharacteristic_polynomial(const matrix&lt;Block, Allocator&gt;& A);\nReturns a bit-vector p where the characteristic polynomial for the bit-matrix \\(A\\) is given by \\[\np(\\lambda) = p_0  + p_1 \\lambda + p_2 \\lambda^2 + \\cdots\n\\] The bit-matrix must be non-empty and square; otherwise, the method throws a std::invalid_argument exception.\nDanilevsky’s algorithm is used to compute the characteristic polynomial. We coded the algorithm considering the nature of arithmetic over \\(\\FF\\), which means that the characteristic polynomial of large bit-matrices can be efficiently computed — even for those with millions of entries that would choke more naive implementations.\nExample — identity matrices\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    for(std::size_t i = 1; i &lt; 8; ++i) {\n        auto M = bit::matrix&lt;&gt;::identity(i);\n        auto p = bit::characteristic_polynomial(M);\n        std::cout &lt;&lt; \"Char-poly for the \"\n                  &lt;&lt; i &lt;&lt; \" x \" &lt;&lt; i &lt;&lt; \" identity: \" &lt;&lt; bit::polynomial(p) &lt;&lt; '\\n';\n    }\n}\n\n1\n\nWe generate identity matrices from 1 x 1 to 7 x 7 and get the characteristic polynomial in each case.\n\n\nOutput\nChar-poly for the 1 x 1 identity: 1 + x^1\nChar-poly for the 2 x 2 identity: 1 + x^2\nChar-poly for the 3 x 3 identity: 1 + x^1 + x^2 + x^3\nChar-poly for the 4 x 4 identity: 1 + x^4\nChar-poly for the 5 x 5 identity: 1 + x^1 + x^4 + x^5\nChar-poly for the 6 x 6 identity: 1 + x^2 + x^4 + x^6\nChar-poly for the 7 x 7 identity: 1 + x^1 + x^2 + x^3 + x^4 + x^5 + x^6 + x^7\nWe can easily verify these.\nFor example, if we consider the 7 x 7 identity matrix, it is clear that the characteristic polynomial is given by \\[\np(\\lambda) = (\\lambda - 1)^7 = \\lambda ^7-7 \\lambda ^6+21 \\lambda ^5-35 \\lambda ^4+35 \\lambda ^3-21 \\lambda ^2+7 \\lambda -1\n\\] In \\(\\FF\\), even coefficients are zero, and odd ones, whether positive or negative, are one, so \\(p(\\lambda)\\) becomes \\[\np(\\lambda) = \\lambda ^7 + \\lambda ^6 + \\lambda ^5 + \\lambda ^4 + \\lambda ^3 + \\lambda ^2 + \\lambda + 1\n\\] Therefore, we expect to get the \\(\\FF\\) coefficients as 11111111, which agrees with the output above.\nExample Bit-matrices should satisfy their characteristic polynomial\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    // For this example - turn off BIT_DEBUG and enable optimization here!\n1    auto M = bit::matrix&lt;&gt;::random(512);\n    auto p = bit::characteristic_polynomial(M);\n    std::cout &lt;&lt; \"Characteristic polynomial:\\n\" &lt;&lt; p &lt;&lt; \"\\n\\n\";\n2    auto C = p(M);\n    std::cout &lt;&lt; \"Does the bit-matrix satisfy its characteristic polynomial? \"\n              &lt;&lt; (C.none() ? \"YES\" : \"NO\") &lt;&lt; '\\n';\n}\n\n1\n\nPay attention to the comment! We can handle much larger matrices, but you must enable compiler optimizations.\n\n2\n\nAll matrices should satisfy their characteristic polynomial so \\(p(M)\\) should return the zero bit-matrix.\n\n\nOutput\nCharacteristic polynomial:\nx^1 + x^3 + x^4 + x^5 + x^6 + x^8 + x^11 + x^12 + x^15 + x^18 + x^20 + x^22 + x^24 + x^27 + x^29 + x^30 + x^31 + x^33 + x^34 + x^35 + x^37 + x^38 + x^39 + x^40 + x^41 + x^42 + x^43 + x^45 + x^46 + x^49 + x^50 + x^51 + x^52 + x^53 + x^54 + x^56 + x^57 + x^63 + x^64 + x^65 + x^66 + x^67 + x^70 + x^74 + x^75 + x^76 + x^77 + x^79 + x^81 + x^87 + x^90 + x^91 + x^93 + x^96 + x^97 + x^98 + x^101 + x^104 + x^105 + x^106 + x^111 + x^112 + x^115 + x^119 + x^120 + x^121 + x^122 + x^127 + x^128 + x^129 + x^130 + x^133 + x^135 + x^140 + x^142 + x^144 + x^145 + x^147 + x^148 + x^151 + x^153 + x^154 + x^157 + x^158 + x^159 + x^162 + x^163 + x^164 + x^165 + x^166 + x^171 + x^172 + x^176 + x^177 + x^178 + x^179 + x^180 + x^181 + x^182 + x^186 + x^188 + x^189 + x^191 + x^193 + x^194 + x^196 + x^197 + x^198 + x^201 + x^203 + x^206 + x^210 + x^211 + x^220 + x^221 + x^222 + x^226 + x^227 + x^228 + x^229 + x^230 + x^233 + x^235 + x^236 + x^238 + x^239 + x^240 + x^242 + x^247 + x^250 + x^251 + x^256 + x^257 + x^258 + x^260 + x^261 + x^262 + x^264 + x^265 + x^268 + x^269 + x^270 + x^273 + x^274 + x^278 + x^279 + x^280 + x^282 + x^283 + x^284 + x^285 + x^286 + x^289 + x^292 + x^293 + x^295 + x^296 + x^297 + x^298 + x^306 + x^307 + x^309 + x^314 + x^316 + x^320 + x^324 + x^326 + x^328 + x^330 + x^331 + x^334 + x^335 + x^336 + x^337 + x^341 + x^342 + x^343 + x^345 + x^347 + x^350 + x^351 + x^352 + x^357 + x^360 + x^365 + x^366 + x^369 + x^372 + x^373 + x^376 + x^377 + x^378 + x^379 + x^380 + x^381 + x^382 + x^383 + x^385 + x^386 + x^387 + x^388 + x^389 + x^393 + x^397 + x^400 + x^401 + x^402 + x^405 + x^406 + x^408 + x^409 + x^410 + x^412 + x^413 + x^414 + x^415 + x^417 + x^418 + x^429 + x^431 + x^434 + x^435 + x^436 + x^438 + x^439 + x^441 + x^443 + x^444 + x^445 + x^447 + x^450 + x^451 + x^452 + x^453 + x^455 + x^457 + x^458 + x^459 + x^460 + x^461 + x^463 + x^464 + x^465 + x^468 + x^470 + x^471 + x^472 + x^473 + x^475 + x^480 + x^481 + x^482 + x^483 + x^487 + x^488 + x^490 + x^492 + x^493 + x^498 + x^499 + x^501 + x^502 + x^503 + x^506 + x^509 + x^512\n\nDoes the bit-matrix satisfy its characteristic polynomial? YES\n\nSee Also\npolynomial::operator()\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/access.html",
    "href": "content/matrix/access.html",
    "title": "bit::matrix — Element Access",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods to access the rows, the columns, and the individual elements/bits in a bit-matrix.\nconstexpr bool\n1operator()(std::size_t i, std::size_t j);\n\nconstexpr bool\n2test(std::size_t i, std::size_t j) const;\n\nconstexpr bit::vector::reference\n3operator()(std::size_t i, std::size_t j);\n\nconstexpr const bit::vector&\n4row(std::size_t i) const;\n\nconstexpr bit::vector&\nrow(std::size_t i);\n\nconstexpr const bit::vector&\n5operator[](std::size_t i) const;\n\nconstexpr bit::vector&\noperator[](std::size_t i);\n\nconstexpr bit::vector\n6col(std::size_t j) const;\n\n1\n\nAccesses the element at (i, j).\n\n2\n\nAnother way to access element (i, j).\n\n3\n\nReturns an object of type vector::reference that lets you write to slot (i, j).\n\n4\n\nRead-only & read-write access to the elements in row i of a bit-matrix.\n\n5\n\nSynonyms for the row(i) methods to allow for alternate C style indexing a la matrix[i][j].\n\n6\n\nRead-only access to the elements in column i of a bit-matrix.\n\n\n\n\n\n\n\n\nRange checks\n\n\n\nIn general, these methods do not check whether an index is in bounds, and if it isn’t, the behavior is undefined (but bound to be wrong!) Set the BIT_DEBUG flag at compile time to check this condition — any violation will cause the program to abort with a helpful message.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    std::size_t n = 4;\n    auto mat = bit::matrix&lt;&gt;::random(n);\n    std::cout &lt;&lt; \"bit::matrix:\\n\";\n    std::cout &lt;&lt; mat &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"By rows ...\\n\";\n    for (std::size_t i = 0; i &lt; n; ++i)\n        std::cout &lt;&lt; \"Row \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; mat[i] &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"By columns ...\\n\";\n    for (std::size_t i = 0; i &lt; n; ++i)\n        std::cout &lt;&lt; \"Col \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; mat.col(i) &lt;&lt; '\\n';\n}\nOutput\nbit::matrix:\n│0 1 1 0│\n│0 1 0 0│\n│0 1 1 0│\n│0 1 0 0│\nBy rows ...\nRow 0: [0 1 1 0]\nRow 1: [0 1 0 0]\nRow 2: [0 1 1 0]\nRow 3: [0 1 0 0]\nBy columns ...\nCol 0: [0 0 0 0]\nCol 1: [1 1 1 1]\nCol 2: [1 0 1 0]\n\nSee Also\nvector::reference\n[bit_assert]\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/dot.html",
    "href": "content/matrix/dot.html",
    "title": "bit::matrix — Bit-Matrix Multiplication",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nComputes the dot product of a bit-vector with a bit-matrix, a bit-matrix with a bit-vector, and a bit-matrix with another bit-matrix.\ntemplate&lt;std::unsigned_integral Block, typename Allocator&gt;\nconstexpr const vector&lt;Block, Allocator&gt;\n1dot(const matrix&lt;Block, Allocator&gt; &M, const vector&lt;Block, Allocator&gt; &v);\n\ntemplate&lt;std::unsigned_integral Block, typename Allocator&gt;\nconstexpr const vector&lt;Block, Allocator&gt;\n2dot(const vector&lt;Block, Allocator&gt; &v, const matrix&lt;Block, Allocator&gt; &M);\n\ntemplate&lt;std::unsigned_integral Block, typename Allocator&gt;\nconstexpr const matrix&lt;Block, Allocator&gt;\n3dot(const matrix&lt;Block, Allocator&gt; &M, const matrix&lt;Block, Allocator&gt; &N);\n\n1\n\nComputes \\(M \\cdot v\\)\nIf M is r x c, then v.size() must be c. The returned bit-vector will have size r.\n\n2\n\nComputes \\(v \\cdot M\\)\nIf M is r x c, then v.size() must be r. The returned bit-vector will have size c.\n\n3\n\nComputes \\(M \\cdot N\\)\nIf M is a x b, then N must be b x c for some c. The returned bit-matrix will be a x c.\n\n\nThese dot products are defined by: \\[\n\\begin{aligned}\n    \\left(M \\cdot v\\right)_i       &=  \\sum_j M_{ij} \\times v_j    \\\\\n    \\left(v \\cdot M\\right)_j       &=  \\sum_i v_i \\times M_{ij}    \\\\\n    \\left(M \\cdot N\\right)_{ij}    &=  \\sum_k M_{ik} \\times N_{kj}\n\\end{aligned}\n\\] In the case of \\(\\FF\\), the product is replaced by logical AND, and the sum by the logical XOR operation.\nThe dot product is a critical operation in linear algebra, so it is fortunate that AND’ing and XOR’ing for bit-matrices and bit-vectors can be done very efficiently over blocks of elements simultaneously.\n\n\n\n\n\n\nRange checking\n\n\n\nThe function arguments must have compatible sizes.\nSet the BIT_DEBUG flag at compile time to check this condition — any violation will cause the program to abort with a helpful message.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::vector&lt;&gt; u(6, [](size_t k) { return k % 2; });\n    bit::vector&lt;&gt; v(8, [](size_t k) { return (k + 1)% 2; });\n\n    bit::matrix&lt;&gt; M(6, 8, [](size_t i, size_t j) { return i == j; });\n    bit::matrix&lt;&gt; N(8, 4, [](size_t i, size_t j) { return (i + j)%2; });\n\n    std::cout &lt;&lt; \"bit::matrix M:\\n\" &lt;&lt; M &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"bit::matrix N:\\n\" &lt;&lt; N &lt;&lt; \"\\n\\n\";\n\n    std::cout &lt;&lt; \"dot(\" &lt;&lt; u &lt;&lt; \", M)     = \" &lt;&lt; dot(u, M) &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"dot(M, \" &lt;&lt; v &lt;&lt; \") = \" &lt;&lt; dot(M, v) &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"dot(M, N):\\n\" &lt;&lt; dot(M, N) &lt;&lt; \"\\n\";\n}\nOutput\nbit::matrix M:\n│1 0 0 0 0 0 0 0│\n│0 1 0 0 0 0 0 0│\n│0 0 1 0 0 0 0 0│\n│0 0 0 1 0 0 0 0│\n│0 0 0 0 1 0 0 0│\n│0 0 0 0 0 1 0 0│\n\nbit::matrix N:\n│0 1 0 1│\n│1 0 1 0│\n│0 1 0 1│\n│1 0 1 0│\n│0 1 0 1│\n│1 0 1 0│\n│0 1 0 1│\n│1 0 1 0│\n\ndot([0 1 0 1 0 1], M)     = [0 1 0 1 0 1 0 0]\ndot(M, [1 0 1 0 1 0 1 0]) = [1 0 1 0 1 0]\n\ndot(M, N):\n│0 1 0 1│\n│1 0 1 0│\n│0 1 0 1│\n│1 0 1 0│\n│0 1 0 1│\n│1 0 1 0│\n\nSee Also\npolynomial::operator()\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/index.html",
    "href": "content/matrix/index.html",
    "title": "The bit::matrix Class",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]",
    "crumbs": [
      "Home",
      "Bit-Matrices",
      "Introduction"
    ]
  },
  {
    "objectID": "content/matrix/index.html#introduction",
    "href": "content/matrix/index.html#introduction",
    "title": "The bit::matrix Class",
    "section": "Introduction",
    "text": "Introduction\nA bit::matrix represents a matrix over GF(2) (also known as \\(\\FF\\)) the simplest Galois field that has just two elements usually denoted 0 & 1, or as booleans–true & false, or as bits–set & unset.\nArithmetic in \\(\\FF\\) is mod 2, which means that addition/subtraction becomes the XOR operation while multiplication/division becomes AND.\nWe often refer to an object of the type bit::matrix as a bit-matrix. It is a matrix where all the elements are 0 or 1, and arithmetic is mod 2.\nA bit::matrix is stored in row-major mode where each row is a single bit::vector. Thus, arranging computations to work row by row instead of column by column is typically much more efficient. Primarily, you will be using higher-level methods and functions that consider this.\nThe aim is to facilitate efficient linear algebra over \\(\\FF\\) where the bit-vector class is bit::vector.\nThis bit-matrix class is a std::vector of rows where each row is a single bit-vector. If, instead, the primary aim was to minimize storage, one would store the bit-matrix as a single long bit-vector with appropriate index operations. However, in that case, matrix operations would often need to be done element-by-element, which is much slower than doing things block-by-block, as we do here.\nLike bit-vectors, bit-matrices are sized dynamically at runtime, with the row elements packed into blocks of some unsigned integral type. That template parameter defaults to 64-bit words (it might be reasonable to use a smaller type in some scenarios).\n\n\n\n\n\n\nSquare matrices\n\n\n\nArbitrary \\(m \\times n\\) bit-matrices are supported, but some functions only make sense for square matrices where \\(n = m\\).\n\n\nThe bit::matrix class has many of the same methods defined for bit::vector. We also define functions like dot(lhs, rhs) to handle matrix-vector, vector-matrix, and matrix-matrix multiplication.\nThere are methods to solve linear systems of equations \\(A \\cdot x = b\\).\nDanilevsky’s method to compute characteristic polynomials (and the determinant) for a bit::matrix is available and works for quite large matrices (ones with millions of entries) that would choke a naive implementation that didn’t take into account the nature of arithmetic over GF(2).",
    "crumbs": [
      "Home",
      "Bit-Matrices",
      "Introduction"
    ]
  },
  {
    "objectID": "content/matrix/index.html#declaration",
    "href": "content/matrix/index.html#declaration",
    "title": "The bit::matrix Class",
    "section": "Declaration",
    "text": "Declaration\nLike everything in the library, this class is in the bit namespace. We define it in the header &lt;bit/matrix.h&gt; as follows:\nnamespace bit {\n    template&lt;\n        std::unsigned_integral Block = uint64_t,\n        Allocator = std::allocator&lt;Block&gt;\n    &gt; class bit::matrix;\n}\nThe two template parameters add some visual clutter, but they both have reasonable defaults and disappear in most uses.\nFor example, your code might have a line like:\n    ...\n    bit::matrix M(3,5);\n    ...\nThis code creates a 3 x 5 matrix with 15 elements, all zeros by default.\n\nTemplate Parameters\n\n\n\n\n\n\n\n\nParameter\nDescription\n\n\n\n\nBlock = std::uint64_t\nWe store individual matrix elements/bits by row and pack the rows into blocks. The default Block is an unsigned 64-bit word.\n\n\nAllocator = std::allocator&lt;Block&gt;\nThe default Allocator should be just fine for most purposes, but you can use a custom type to handle all memory allocation/destruction for blocks.\n\n\n\n\nThe default [std::unsigned] for a Block is 64-bits, the native size for many modern CPUs. Of course, if you need to use many smaller bit-matrices and have concerns about conserving space, you might use a different Block. Perhaps if the bit-matrices all fit in 32-bits, you might have code along the lines\n    using matrix_type = bit::matrix&lt;uint32_t&gt;;\n    matrix_type mat = ...\n\n\n\n\n\n\nUse a single Block type throughout your code!\n\n\n\nYou should use just one Block type throughout your code. In theory, there is no reason that one couldn’t intermingle operations between, say, a bit::matrix&lt;uint32_t&gt; and a bit::vector&lt;uint64_t&gt;, but doing so efficiently significantly increases code complexity, and the library doesn’t support this.",
    "crumbs": [
      "Home",
      "Bit-Matrices",
      "Introduction"
    ]
  },
  {
    "objectID": "content/matrix/index.html#class-types",
    "href": "content/matrix/index.html#class-types",
    "title": "The bit::matrix Class",
    "section": "Class Types",
    "text": "Class Types\n\n\n\n\n\n\n\n\nItem\nDescription\n\n\n\n\nvector_type\nAlias for bit::vector — the type used for matrix rows (and columns).",
    "crumbs": [
      "Home",
      "Bit-Matrices",
      "Introduction"
    ]
  },
  {
    "objectID": "content/matrix/index.html#instance-methods",
    "href": "content/matrix/index.html#instance-methods",
    "title": "The bit::matrix Class",
    "section": "Instance Methods",
    "text": "Instance Methods\n\nConstruction\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nmatrix::constructors\nConstruct a bit-matrix in various ways.\n\n\nmatrix::random\nConstruct a bit-matrix with a random fill.\n\n\nmatrix::from\nConstruct a bit-matrix from a string.\n\n\nmatrix::ones\nCreate a bit-matrix with all the elements set to 1.\n\n\nmatrix::zeros\nCreate a bit-matrix with all the elements set to 0.\n\n\nmatrix::checker_board\nCreate a bit-matrix with the elements set to a checker-board pattern.\n\n\nmatrix::identity\nCreate an identity bit-matrix.\n\n\nmatrix::shift\nCreate a bit-matrix that shifts a bit-vector right or left.\n\n\nmatrix::rotate\nCreate a bit-matrix that rotates the elements of a bit-vector.\n\n\nmatrix::companion\nConstruct a companion matrix from its top-row only.\n\n\n\n\n\n\nQueries\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nmatrix::is_zero\nIs this a zero bit-matrix?\n\n\nmatrix::is_ones\nIs this bit-matrix all ones?\n\n\nmatrix::is_identity\nIs this an identity bit-matrix?\n\n\nmatrix::is_square\nIs this bit-matrix square?\n\n\nmatrix::is_symmetric\nIs this bit-matrix symmetric?\n\n\n\n\n\n\nElement Access\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nmatrix::operator()\nAccess a bit-matrix element, a whole row, or an entire column.\n\n\nmatrix::operator[]\nAccess a bit-matrix element, a whole row, or an entire column.\n\n\nmatrix::row\nRead-write access a bit-matrix row.\n\n\nmatrix::col\nRead only access a bit-matrix column.\n\n\nmatrix::test\nCheck the value of a bit-matrix element.\n\n\nmatrix::all\nCheck that all the bit-matrix elements are set.\n\n\nmatrix::any\nCheck if any bit-matrix elements are set.\n\n\nmatrix::all\nCheck that none of the bit-matrix elements are set.\n\n\nmatrix::count\nCounts the set elements in the bit-matrix.\n\n\nmatrix::count_diagonal\nCounts the set elements on the diagonal of the bit-matrix.\n\n\nmatrix::trace\nSum of the elements on the diagonal.\n\n\nmatrix::sub\nExtracts a bit-matrix as a distinct copy of some of the elements of this one. Note that views into a bit-matrix are not supported.\n\n\nmatrix::lower\nReturns a bit-matrix that is a copy of the lower triangular part of this bit-matrix.\n\n\nmatrix::upper\nReturns a bit-matrix that is a copy of the upper triangular part of this bit-matrix.\n\n\nmatrix::strictly_lower\nReturns a bit-matrix that is a copy of the strictly lower triangular part of this bit-matrix.\n\n\nmatrix::strictly_upper\nReturns a bit-matrix that is a copy of the strictly upper triangular part of this bit-matrix.\n\n\n\n\n\n\nCapacity\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nmatrix::rows\nThe number of rows in this bit-matrix.\n\n\nmatrix::cols\nThe number of columns in this bit-matrix.\n\n\nmatrix::size\nThe number of elements in this bit-matrix.\n\n\nmatrix::empty\nCheck whether this matrix has no elements.\n\n\nmatrix::row_capacity\nHow many rows can be added to this bit-matrix without a fresh memory allocation?\n\n\nmatrix::col_capacity\nHow many columns can be added to this bit-matrix without a fresh memory allocation?\n\n\nmatrix::shrink_to_fit\nTries to reduce memory usage by freeing unused memory.\n\n\n\n\n\n\nModifiers\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nmatrix::clear\nClears all the elements so rows(), cols(), and size() all become 0.\n\n\nmatrix::resize\nResizes the bit-matrix, padding out any added values with zeros.\n\n\nmatrix::add_row\nAdds a row to the end of the bit-matrix.\n\n\nmatrix::add_col\nAdds a column to the end of the bit-matrix.\n\n\nmatrix::pop_row\nRemoves the final row of the bit-matrix.\n\n\nmatrix::pop_col\nRemoves the final column of the bit-matrix.\n\n\nmatrix::append\nAugments the bit-matrix in-place by appending columns from a vector or another bit-matrix on the right.\n\n\nmatrix::swap_rows\nSwap two rows.\n\n\nmatrix::swap_cols\nSwap two columns.\n\n\nmatrix::transpose\nTranspose a square bit-matrix in-place.\n\n\nmatrix::replace\nReplace some of the contents of the bit-matrix with other values.\n\n\nmatrix::set\nSets all the elements to 1.\n\n\nmatrix::reset\nSets all the elements to 0.\n\n\nmatrix::flip\nFlips the 1 values to 0 and vice versa.\n\n\nmatrix::set_diagonal\nSets all the diagonal elements to 1.\n\n\nmatrix::reset_diagonal\nSets all the diagonal elements to 0.\n\n\nmatrix::set_if\nSets the values in a bit-matrix based on the return value from a function of each element index-pair.\n\n\nmatrix::flip_if\nFlips the values in a bit-matrix based on the return value from a function of each element index-pair.\n\n\nmatrix::operator&=\nIn-place element-by-element logical AND between this bit-matrix and another of equal dimensions.\n\n\nmatrix::operator^=\nIn-place element-by-element logical XOR between this bit-matrix and another of equal dimensions.\n\n\nmatrix::operator|=\nIn-place element-by-element logical OR between this bit-matrix and another of equal dimensions.\n\n\nmatrix::operator-=\nIn-place element-by-element logical DIFF between this bit-matrix and another of equal dimensions.\n\n\nmatrix::operator~\nFlip all the elements in this bit-matrix.\n\n\nmatrix::operator+=\nIn-place element-by-element logical XOR between this bit-matrix and another of equal dimensions.\n\n\nmatrix::operator-=\nIn-place element-by-element logical XOR between this bit-matrix and another of equal dimensions.\n\n\nmatrix::operator*=\nIn-place element-by-element logical AND between this bit-matrix and another of equal dimensions.\n\n\nmatrix::operator&lt;&lt;=\nIn-place left shift of the rows in this bit-matrix.\n\n\nmatrix::operator&gt;&gt;=\nIn-place right shift of the rows in this bit-matrix.\n\n\nmatrix::operator&lt;&lt;\nReturns a copy of this bit-matrix where the rows are all left shifted.\n\n\nmatrix::operator&gt;&gt;\nReturns a copy of this bit-matrix where the rows are all right shifted.\n\n\nmatrix::to_echelon_form\nChanges this bit-matrix in place to row-echelon form.\n\n\nmatrix::to_reduced_echelon_form\nChanges this bit-matrix in place to reduced row-echelon form.\n\n\n\n\n\n\nString Conversions\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nmatrix::to_string\nReturns a binary string representation of this bit-matrix.\n\n\nmatrix::to_pretty_string\nReturns a formatted binary string representation of this bit-matrix.\n\n\nmatrix::to_hex\nReturns a hex string representation of this bit-matrix.\n\n\nmatrix::to_vector\nPacks this bit-matrix into a bit-vector.\n\n\nmatrix::description\nWrites some descriptive data about the bit-matrix to a stream.\n\n\n\n\n\n\nOther methods\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nmatrix::probability_invertible\nReturns the probability that a “fair” square bit-matrix is invertible.\n\n\nmatrix::probability_singular\nReturns the probability that a “fair” square bit-matrix is singular.\n\n\n\n\n\n\nDebugging\n\n\n\n\n\n\n\n\nMacro\nDescription\n\n\n\n\nBIT_DEBUG\nThis compile-time flag enables extra safety checks.\n\n\nbit_debug_assert\nThese assertions are only checked if the BIT_DEBUG flag is set at compile time.\n\n\nbit_always_assert\nUse this form for checks that must always be performed.",
    "crumbs": [
      "Home",
      "Bit-Matrices",
      "Introduction"
    ]
  },
  {
    "objectID": "content/matrix/index.html#non-member-functions",
    "href": "content/matrix/index.html#non-member-functions",
    "title": "The bit::matrix Class",
    "section": "Non-member Functions",
    "text": "Non-member Functions\n\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nmatrix::operator&\nElement-by-element logical AND between two bit-matrices of equal dimensions.\n\n\nmatrix::operator^\nElement-by-element logical XOR between two bit-matrices of equal dimensions.\n\n\nmatrix::operator|\nElement-by-element logical OR between two bit-matrices of equal dimensions.\n\n\nmatrix::operator-\nElement-by-element logical DIFF between two bit-matrices of equal dimensions.\n\n\nmatrix::operator+\nElement-by-element logical XOR between two bit-matrices of equal dimensions.\n\n\nmatrix::operator-\nElement-by-element logical XOR between two bit-matrices of equal dimensions.\n\n\nmatrix::operator*\nElement-by-element logical AND between two bit-matrices of equal dimensions.\n\n\nmatrix::dot\nReturns the dot product of a bit-matrix with a bit-vector or another bit-matrix.\n\n\nmatrix::append\nReturns an augmented bit-matrix by copying one input and then appending columns from a bit-vector or another bit-matrix on the right of that.\n\n\nmatrix::transpose\nReturns the transpose of an arbitrary rectangular bit-matrix as a new bit-matrix.\n\n\nmatrix::pow\nRaises a square bit-matrix to a power \\(n\\).\n\n\nmatrix::pow2\nRaises a square bit-matrix to a power \\(2^n\\).\n\n\nmatrix::invert\nAttempts to return the inverse of a square bit-matrix.\n\n\nmatrix::echelon_form\nReturns the {row-echelon} form of an arbitrary bit-matrix.\n\n\nmatrix::reduced_echelon_form\nReturns the reduced {row-echelon} form of an arbitrary bit-matrix.\n\n\nmatrix::characteristic_polynomial\nReturns the coefficients of the characteristic polynomial of a square bit-matrix.\n\n\nmatrix::compact_frobenius_form\nReturns the companion matrices that are the diagonal blocks in the Frobenius form of a square bit-matrix.\n\n\nmatrix::print\nPrints multiple bit-matrices or a bit-matrix with potentially multiple bit-vectors side by side to a stream.\n\n\nmatrix::stream&lt;&lt;\nStream input for bit-matrices\n\n\nmatrix::stream&gt;&gt;\nStream output for bit-matrices\n\n\n\n\n\nSee Also\nbit::solve\ngauss::constructors\nlu::constructors",
    "crumbs": [
      "Home",
      "Bit-Matrices",
      "Introduction"
    ]
  },
  {
    "objectID": "content/matrix/companion.html",
    "href": "content/matrix/companion.html",
    "title": "bit::matrix - Companion/Frobenius Matrices",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]"
  },
  {
    "objectID": "content/matrix/companion.html#companion-matrices",
    "href": "content/matrix/companion.html#companion-matrices",
    "title": "bit::matrix - Companion/Frobenius Matrices",
    "section": "Companion Matrices",
    "text": "Companion Matrices\nOur version of a companion matrix is upper Hessenberg with an arbitrary top-row, ones on the sub-diagonal, and zeros everywhere else. These can be compactly stored in top-row-only form and constructed as follows:\nstatic constexpr bit::matrix\n1companion(const bit::vector_type &top_row)\n\n1\n\nFactory method that creates a companion matrix, i.e., a square bit-matrix with the given top row and ones on the sub-diagonal.\n\n\nCompanion matrices are essential because one can readily read off the coefficients of their characteristic polynomials. The following non-class function does just that, returning the coefficients of the characteristic polynomial in a bit::vector:\ntemplate&lt;std::unsigned_integral Block, typename Allocator&gt;\nbit::vector&lt;Block, Allocator&gt;\n1companion_matrix_characteristic_polynomial(const bit::vector&lt;Block, Allocator&gt; &top_row)\n\n1\n\nThis returns the coefficients for the companion matrix characteristic polynomial as bit-vector p where the polynomial is: \\[\np(\\lambda) = p_0  + p_1 \\lambda + p_2 \\lambda^2 + \\cdots\n\\]"
  },
  {
    "objectID": "content/matrix/companion.html#frobenius-matrices",
    "href": "content/matrix/companion.html#frobenius-matrices",
    "title": "bit::matrix - Companion/Frobenius Matrices",
    "section": "Frobenius Matrices",
    "text": "Frobenius Matrices\nA square matrix is in Frobenius form if it is block-diagonal and each of the square diagonal blocks is a companion matrix. One can readily compute the characteristic polynomial of a Frobenius matrix by multiplying together the characteristic polynomials of all the companion matrices.\nA similarity transformation can transform any square matrix to Frobenius form. You can see how we achieve this here.\nThis method is the key to our implementation of the non-member function matrix::characteristic_polynomial, which takes an arbitrary square bit-matrix as input and returns its characteristic polynomial.\nWe supply a non-member function which returns the Frobenius form of the input square bit-matrix:\ntemplate&lt;std::unsigned_integral Block, typename Allocator&gt;\nstd::vector&lt;vector&lt;Block, Allocator&gt;&gt;\n1compact_frobenius_form(const bit::matrix&lt;Block, Allocator&gt; &A)\n\n1\n\nEach element in the return vector is a companion matrix stored in compact top-row-only form.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto top_row = bit::vector&lt;&gt;::ones(12);\n    auto M = bit::matrix&lt;&gt;::companion(top_row);\n    std::cout &lt;&lt; \"Top row: \" &lt;&lt; top_row &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Corresponding companion matrix:\\n\";\n    std::cout &lt;&lt; M &lt;&lt; '\\n';\n}\nOutput\nTop row: [1 1 1 1 1 1 1 1 1 1 1 1]\nCorresponding companion matrix:\n│1 1 1 1 1 1 1 1 1 1 1 1│\n│1 0 0 0 0 0 0 0 0 0 0 0│\n│0 1 0 0 0 0 0 0 0 0 0 0│\n│0 0 1 0 0 0 0 0 0 0 0 0│\n│0 0 0 1 0 0 0 0 0 0 0 0│\n│0 0 0 0 1 0 0 0 0 0 0 0│\n│0 0 0 0 0 1 0 0 0 0 0 0│\n│0 0 0 0 0 0 1 0 0 0 0 0│\n│0 0 0 0 0 0 0 1 0 0 0 0│\n│0 0 0 0 0 0 0 0 1 0 0 0│\n│0 0 0 0 0 0 0 0 0 1 0 0│\n\nSee Also\nmatrix::characteristic_polynomial"
  },
  {
    "objectID": "content/matrix/logical-op-eq.html",
    "href": "content/matrix/logical-op-eq.html",
    "title": "bit::matrix — In-place Logical Operators",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nMethods to perform element-by-element binary AND, XOR, OR, +, -, * with another equal-sized bit-matrix.\n1constexpr bit::matrix &operator&=(const bit::matrix &other);\n2constexpr bit::matrix &operator^=(const bit::matrix &other);\n3constexpr bit::matrix &operator|=(const bit::matrix &other);\n4constexpr bit::matrix &operator+=(const bit::matrix &other);\n5constexpr bit::matrix &operator-=(const bit::matrix &other);\n6constexpr bit::matrix &operator*=(const bit::matrix &other);\n\n1\n\nIn-place binary AND between the elements of *this and other.\n\n2\n\nIn-place binary XOR between the elements of *this and other.\n\n3\n\nIn-place binary OR between the elements of *this and other.\n\n4\n\nIn-place binary XOR the elements of *this and other.\nIn \\(\\FF\\), addition corresponds to XOR.\n\n5\n\nIn-place binary XOR between the elements of *this and other.\nIn \\(\\FF\\), subtraction corresponds to XOR.\n\n6\n\nIn-place binary AND between the elements of *this and other.\nIn \\(\\FF\\), multiplication corresponds to AND.\n\n\nThese methods all return a reference to *this so they can be chained with other calls.\n\n\n\n\n\n\nDimensions must match\n\n\n\nThe two bit-matrices in question must have the same dimensions. Set the BIT_DEBUG flag at compile time to check this condition — any violation will cause the program to abort with a helpful message.\n\n\nThere is one other bit-twiddling method:\n7constexpr bit::matrix operator~() const;\n\n7\n\nReturns a copy of the bit-matrix with all the bits flipped\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::matrix&lt;&gt; m1(4,[](std::size_t i, std::size_t j) { return (i + j) % 2; });\n    auto m2 = bit::matrix&lt;&gt;::ones(4);\n\n    std::cout &lt;&lt; \"m1:\\n\" &lt;&lt; m1  &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m2:\\n\" &lt;&lt; m2  &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m1 &= m2:\\n\"  &lt;&lt; (m1 &= m2)   &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m1 |= m2:\\n\"  &lt;&lt; (m1 |= m2)   &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"m1 ^= m2:\\n\"  &lt;&lt; (m1 ^= m2)   &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"~m1:\\n\"       &lt;&lt; (~m1)        &lt;&lt; '\\n';\n}\nOutput\nm1:\n│0 1 0 1│\n│1 0 1 0│\n│0 1 0 1│\n│1 0 1 0│\nm2:\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\nm1 &= m2:\n│0 1 0 1│\n│1 0 1 0│\n│0 1 0 1│\n│1 0 1 0│\nm1 |= m2:\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\nm1 ^= m2:\n│0 0 0 0│\n│0 0 0 0│\n│0 0 0 0│\n│0 0 0 0│\n~m1:\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\n\nSee Also\nmatrix::operator&\nmatrix::operator|\nmatrix::operator^\nmatrix::operator+\nmatrix::operator-\nmatrix::operator*\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/shrink_to_fit.html",
    "href": "content/matrix/shrink_to_fit.html",
    "title": "bit::matrix — Minimize the Space Used",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nPotentially change the capacity of a bit-matrix.\n1constexpr bit::matrix &shrink_to_fit();\n\n1\n\nThis is a request to minimize the unused/excess matrix::row_capacity and matrix::col_capacity . May do nothing.\n\n\nThe method returns *this, so you can chain it with other calls.\nThe method will not change the dimensions of a bit-matrix (so rows(), cols(), and size() remain unchanged). No elements are added or deleted.\n\n\n\n\n\n\nReferences may get lost\n\n\n\nIf the capacity does change, all the old values are unaltered, but be aware that any pre-existing element references are invalidated.\n\n\n\nSee Also\nmatrix::clear\nmatrix::description\nvector::shrink_to_fit\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/to_vector.html",
    "href": "content/matrix/to_vector.html",
    "title": "bit::matrix — Convert to a Bit-Vector",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have a method that packs the bit-matrix into a bit-vector.\nconstexpr bit::vector&lt;Block, Allocator&gt;\nto_vector(bool by_rows = true) const;\nBy default, this returns a bit-vector with all the elements of the bit-matrix stored row by row. If the argument by_rows is set to false the return bit-vector will have the elements of the bit-matrix stored column by column.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    bit::matrix&lt;&gt; m(4, [](std::size_t i, std::size_t) { return (i)%2; });\n2    auto vrow = m.to_vector();\n3    auto vcol = m.to_vector(false);\n    std::cout &lt;&lt; \"Original:\\n\" &lt;&lt; m    &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"By row: \"    &lt;&lt; vrow &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"By col: \"    &lt;&lt; vcol &lt;&lt; '\\n';\n4    std::cout &lt;&lt; \"From row:\\n\" &lt;&lt; bit::matrix(vrow, 4) &lt;&lt; '\\n';\n5    std::cout &lt;&lt; \"From col:\\n\" &lt;&lt; bit::matrix(vcol, 4, false) &lt;&lt; '\\n';\n}\n\n1\n\nConstruct a bit-matrix with rows that alternate between all zeros and all ones.\n\n2\n\nPack the bit-matrix in a bit-vector row by row.\n\n3\n\nPack the bit-matrix in a bit-vector column by column.\n\n4\n\nReconstitute a bit-matrix from the row-by-row bit-vector.\n\n5\n\nReconstitute a bit-matrix from the column-by-column bit-vector.\n\n\nOutput\nOriginal:\n│0 0 0 0│\n│1 1 1 1│\n│0 0 0 0│\n│1 1 1 1│\nBy row: [0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1]\nBy col: [0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1]\nFrom row:\n│0 0 0 0│\n│1 1 1 1│\n│0 0 0 0│\n│1 1 1 1│\nFrom col:\n│0 0 0 0│\n│1 1 1 1│\n│0 0 0 0│\n│1 1 1 1│\n\nSee Also\nmatrix::constructors for a constructor that reshapes a bit-vector into a bit-matrix.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/append.html",
    "href": "content/matrix/append.html",
    "title": "bit::matrix — Append to a Bit-Matrix",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods to append one or more columns to the right of a bit-matrix.\n1constexpr bit::matrix &append(const bit::vector &v);\n2constexpr bit::matrix &append(const bit::matrix &V);\n\n3bit::matrix join(const bit::matrix& M, const bit::vector& v);\n4bit::matrix join(const bit::matrix& M, const bit::vector& V);\n\n1\n\nbit::matrix \\(M\\) is augmented in place to become \\(M|v\\).\n\n2\n\nbit::matrix \\(M\\) is augmented in place to become \\(M|V\\).\n\n3\n\nReturns a new matrix, the augmented \\(M|v\\).\n\n4\n\nReturns a new matrix, the augmented \\(M|V\\).\n\n\n\n\n\n\n\n\nConsistency\n\n\n\nThe number of rows in v and V must match the number in M.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    std::size_t n_rows = 12;\n    auto M = bit::matrix&lt;&gt;::ones(n_rows);\n    auto v = bit::vector&lt;&gt;::zeros(n_rows);\n    auto V = bit::matrix&lt;&gt;::zeros(n_rows, 5);\n    auto A = bit::join(M,v);\n    auto B = bit::join(M,V);\n    bit::print(M, A, B);\n    return 0;\n}\nOutput\n111111111111    1111111111110   11111111111100000\n111111111111    1111111111110   11111111111100000\n111111111111    1111111111110   11111111111100000\n111111111111    1111111111110   11111111111100000\n111111111111    1111111111110   11111111111100000\n111111111111    1111111111110   11111111111100000\n111111111111    1111111111110   11111111111100000\n111111111111    1111111111110   11111111111100000\n111111111111    1111111111110   11111111111100000\n111111111111    1111111111110   11111111111100000\n111111111111    1111111111110   11111111111100000\n111111111111    1111111111110   11111111111100000\n\nSee Also\nmatrix::replace\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/replace.html",
    "href": "content/matrix/replace.html",
    "title": "bit::matrix — Replace Some Content",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods that replace some of the values in a bit-matrix with those of another.\nconstexpr bit::matrix&\n1replace(std::size_t i0, std::size_t j0, const bit::matrix &with);\n\nconstexpr bit::matrix&\n2replace(std::size_t i0, const bit::matrix &with);\n\nconstexpr bit::matrix&\n3replace(const bit::matrix &with);\n\n1\n\nStarting at index pair (i0,j0), replace the bit-matrix values with those from the bit-matrix with.\n\n2\n\nStarting at index pair (i0,i0), replace the bit-matrix values with those from the bit-matrix with.\n\n3\n\nStarting at index pair (0,0), replace the bit-matrix values with those from the bit-matrix with.\n\n\n\n\n\n\n\n\nSizes must be compatible\n\n\n\nThe sub-matrix with we are copying from must fit inside the existing bit-matrix! Set the BIT_DEBUG flag at compile time to check this condition — any violation will cause the program to abort with a helpful message.\n\n\nThese methods return a reference to *this so they can be chained with other calls.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    auto m = bit::matrix&lt;&gt;::ones(8);\n2    bit::matrix&lt;&gt; w(3);\n    std::cout &lt;&lt; \"m:\\n\" &lt;&lt; m &lt;&lt; '\\n';\n3    m.replace(w);\n    std::cout &lt;&lt; \"m:\\n\" &lt;&lt; m &lt;&lt; '\\n';\n4    m.replace(5,w);\n    std::cout &lt;&lt; \"m:\\n\" &lt;&lt; m &lt;&lt; '\\n';\n5    m.replace(5,0,w);\n    std::cout &lt;&lt; \"m:\\n\" &lt;&lt; m &lt;&lt; '\\n';\n}\n\n1\n\nStart with an 8 x 8 bit-matrix m that is all ones.\n\n2\n\nThe replacement values will always be that 3 x 3 bit-matrix w that is all zeros.\n\n3\n\nReplaces 3 x 3 values in m starting at the upper left element (0,0).\n\n4\n\nReplaces 3 x 3 values in m starting at the element (5,5).\n\n5\n\nReplaces 3 x 3 values in m starting at the element (5,0).\n\n\nOutput\nm:\n│1 1 1 1 1 1 1 1│\n│1 1 1 1 1 1 1 1│\n│1 1 1 1 1 1 1 1│\n│1 1 1 1 1 1 1 1│\n│1 1 1 1 1 1 1 1│\n│1 1 1 1 1 1 1 1│\n│1 1 1 1 1 1 1 1│\n│1 1 1 1 1 1 1 1│\nm:\n│0 0 0 1 1 1 1 1│\n│0 0 0 1 1 1 1 1│\n│0 0 0 1 1 1 1 1│\n│1 1 1 1 1 1 1 1│\n│1 1 1 1 1 1 1 1│\n│1 1 1 1 1 1 1 1│\n│1 1 1 1 1 1 1 1│\n│1 1 1 1 1 1 1 1│\nm:\n│0 0 0 1 1 1 1 1│\n│0 0 0 1 1 1 1 1│\n│0 0 0 1 1 1 1 1│\n│1 1 1 1 1 1 1 1│\n│1 1 1 1 1 1 1 1│\n│1 1 1 1 1 0 0 0│\n│1 1 1 1 1 0 0 0│\n│1 1 1 1 1 0 0 0│\nm:\n│0 0 0 1 1 1 1 1│\n│0 0 0 1 1 1 1 1│\n│0 0 0 1 1 1 1 1│\n│1 1 1 1 1 1 1 1│\n│1 1 1 1 1 1 1 1│\n│0 0 0 1 1 0 0 0│\n│0 0 0 1 1 0 0 0│\n│0 0 0 1 1 0 0 0│\n\nSee Also\nmatrix::sub\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/add-pop.html",
    "href": "content/matrix/add-pop.html",
    "title": "bit::matrix — Add & Remove Rows/Columns",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods to add and remove rows & columns from the end of the bit-matrix.\n1constexpr bit::matrix &add_row();\n2constexpr bit::matrix &add_col();\n3constexpr bit::matrix &pop_row();\n4constexpr bit::matrix &pop_col();\n\n1\n\nAdd a new row of zeros to the end of the bit-matrix.\n\n2\n\nAdd a new column of zeros to the end of the bit-matrix.\n\n3\n\nRemove the last row from the bit-matrix.\n\n4\n\nRemove the last columns from the bit-matrix.\n\n\nThese methods all return a reference to *this so they can be chained with other calls.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto m = bit::matrix&lt;&gt;::ones(2,8);\n    std::cout &lt;&lt; \"m:\\n\" &lt;&lt; m &lt;&lt; '\\n';\n    m.add_row();\n    std::cout &lt;&lt; \"m:\\n\" &lt;&lt; m &lt;&lt; '\\n';\n    m.add_col();\n    std::cout &lt;&lt; \"m:\\n\" &lt;&lt; m &lt;&lt; '\\n';\n    m.pop_row();\n    std::cout &lt;&lt; \"m:\\n\" &lt;&lt; m &lt;&lt; '\\n';\n    m.pop_col();\n    std::cout &lt;&lt; \"m:\\n\" &lt;&lt; m &lt;&lt; '\\n';\n1    m.clear();\n    std::cout &lt;&lt; \"m:\\n\" &lt;&lt; m &lt;&lt; '\\n';\n2    m.add_row();\n    std::cout &lt;&lt; \"m:\\n\" &lt;&lt; m &lt;&lt; '\\n';\n3    m.pop_col();\n    std::cout &lt;&lt; \"m:\\n\" &lt;&lt; m &lt;&lt; '\\n';\n}\n\n1\n\nClears the bit-matrix.\n\n2\n\nAdding a row or a column to an empty bit-matrix does nothing.\n\n3\n\nPopping a row or a column from an empty bit-matrix does nothing.\n\n\nOutput\nm:\n│1 1 1 1 1 1 1 1│\n│1 1 1 1 1 1 1 1│\nm:\n│1 1 1 1 1 1 1 1│\n│1 1 1 1 1 1 1 1│\n│0 0 0 0 0 0 0 0│\nm:\n│1 1 1 1 1 1 1 1 0│\n│1 1 1 1 1 1 1 1 0│\n│0 0 0 0 0 0 0 0 0│\nm:\n│1 1 1 1 1 1 1 1 0│\n│1 1 1 1 1 1 1 1 0│\nm:\n│1 1 1 1 1 1 1 1│\n│1 1 1 1 1 1 1 1│\nm:\n[]\nm:\n[]\nm:\n[]\n\nSee Also\nmatrix::resize\nmatrix::clear\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/swap.html",
    "href": "content/matrix/swap.html",
    "title": "bit::matrix — Swap Two Rows/Columns",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nSwap any two rows or columns in a bit-matrix — a standard operation in some matrix transformation algorithms.\n1constexpr bit::matrix &swap_rows(std::size_t i0, std::size_t i1);\n2constexpr bit::matrix &swap_cols(std::size_t j0, std::size_t j1);\n\n1\n\nSwap rows i0 and i1.\n\n2\n\nSwap columns j0 and j1.\n\n\nThese methods return a reference to *this, so can be chained with other calls.\n\n\n\n\n\n\nBounds checking\n\n\n\nGenerally, these methods do not check whether the indices are in bounds. If they aren’t, the behavior is undefined (but bound to be wrong!) All of them will perform range checking if you set the BIT_DEBUG at compile time. See [bit_assert].\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    bit::matrix&lt;&gt; m(4, 8, [](std::size_t i, std::size_t j) { return (i + j)%2; });\n    std::cout &lt;&lt; \"Original:\\n\"              &lt;&lt; m &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Swapped first 2 rows:\\n\"  &lt;&lt; m.swap_rows(0,1) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"And back:\\n\"              &lt;&lt; m.swap_rows(0,1) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Swapped first 2 cols:\\n\"  &lt;&lt; m.swap_cols(0,1) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"And back:\\n\"              &lt;&lt; m.swap_cols(0,1) &lt;&lt; '\\n';\n}\n\n1\n\nSet up a bit-matrix with a checkerboard pattern of zeros and ones.\n\n\nOutput\nOriginal:\n│0 1 0 1 0 1 0 1│\n│1 0 1 0 1 0 1 0│\n│0 1 0 1 0 1 0 1│\n│1 0 1 0 1 0 1 0│\nSwapped first 2 rows:\n│1 0 1 0 1 0 1 0│\n│0 1 0 1 0 1 0 1│\n│0 1 0 1 0 1 0 1│\n│1 0 1 0 1 0 1 0│\nAnd back:\n│0 1 0 1 0 1 0 1│\n│1 0 1 0 1 0 1 0│\n│0 1 0 1 0 1 0 1│\n│1 0 1 0 1 0 1 0│\nSwapped first 2 cols:\n│1 0 0 1 0 1 0 1│\n│0 1 1 0 1 0 1 0│\n│1 0 0 1 0 1 0 1│\n│0 1 1 0 1 0 1 0│\nAnd back:\n│0 1 0 1 0 1 0 1│\n│1 0 1 0 1 0 1 0│\n│0 1 0 1 0 1 0 1│\n│1 0 1 0 1 0 1 0│\n\nSee Also\nmatrix::replace\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/set.html",
    "href": "content/matrix/set.html",
    "title": "bit::matrix — Alter Elements",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nWe have methods to set elements in a bit-matrix to 1, reset them to 0, or flip them from 0 to 1 and vice versa. These methods can work on the entire bit-matrix, individual elements, or diagonal elements.\n.The entire bit-matrix\n1constexpr bit::matrix &set();\nconstexpr bit::matrix &reset();\nconstexpr bit::matrix &flip();\n\n2constexpr bit::matrix &set(std::size_t i, std::size_t j);\nconstexpr bit::matrix &reset(std::size_t i, std::size_t j);\nconstexpr bit::matrix &flip(std::size_t i, std::size_t j);\n\n3constexpr bit::matrix &set_diagonal(int d = 0);\nconstexpr bit::matrix &reset_diagonal(int d = 0);\nconstexpr bit::matrix &flip_diagonal(int d = 0);\n\n1\n\nSets, resets, or flips the elements in the bit-matrix.\n\n2\n\nSets, resets, or flips the element at the index pair (i, j).\n\n3\n\nSets, resets, or flips the elements on a diagonal.\nBy default, the elements are on the main diagonal.\nIf d &gt; 0, they’re on a super-diagonal, while if d &lt; 0, they’re on a sub-diagonal.\n\n\nAll these methods return a reference to *this so they can be chained with other calls.\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    bit::matrix&lt;&gt; m(4);\n    std::cout &lt;&lt; \"Original:\\n\"            &lt;&lt; m                    &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"set:\\n\"                 &lt;&lt; m.set()              &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"reset:\\n\"               &lt;&lt; m.reset()            &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"flip:\\n\"                &lt;&lt; m.flip()             &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"reset_diagonal():\\n\"    &lt;&lt; m.reset_diagonal()   &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"reset_diagonal(1):\\n\"   &lt;&lt; m.reset_diagonal(1)  &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"flip_diagonal(-1):\\n\"   &lt;&lt; m.flip_diagonal(-1)  &lt;&lt; '\\n';\n}\nOutput\nOriginal:\n│0 0 0 0│\n│0 0 0 0│\n│0 0 0 0│\n│0 0 0 0│\nset:\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\nreset:\n│0 0 0 0│\n│0 0 0 0│\n│0 0 0 0│\n│0 0 0 0│\nflip:\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\n│1 1 1 1│\nreset_diagonal():\n│0 1 1 1│\n│1 0 1 1│\n│1 1 0 1│\n│1 1 1 0│\nreset_diagonal(1):\n│0 0 1 1│\n│1 0 0 1│\n│1 1 0 0│\n│1 1 1 0│\nflip_diagonal(-1):\n│0 0 1 1│\n│0 0 0 1│\n│1 0 0 0│\n│1 1 0 0│\n\nSee Also\nmatrix::set_if\nmatrix::flip_if\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/description.html",
    "href": "content/matrix/description.html",
    "title": "bit::matrix — Descriptive Material",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nDump some descriptive data about a bit-matrix to a stream.\nconstexpr void description(std::ostream &s, +\n                           const std::string &head = \"\", +\n1                           const std::string &foot = \"\\n\") const;\n\nconstexpr void description(const std::string &head = \"\", +\n2                           const std::string &foot = \"\\n\") const;\n\n1\n\nPrints data to an arbitrary stream.\n\n2\n\nPrints the same data to std::cout.\n\n\nYou can send along some arbitrary text that gets prepended or appended to the description of the bit-matrix. See the example below.\n\n\n\n\n\n\nThe output format may change\n\n\n\nThe primary use for these methods is debugging.\nThe format of the descriptive data may change from time to time.\n\n\nExample\n#include &lt;bit/bit.h&gt;\nint main()\n{\n    auto m = bit::matrix&lt;&gt;::random(6);\n    m.description(\"Random fill using a fair coin\");\n}\nOutput\n1Random fill using a fair coin:\nbit-matrix dimension:   6 x 6\nbit-matrix capacity:    6 x 64\nnumber of set elements: 16\n    100000  =  0x10_4\n    111101  =  0xF2_4\n    101001  =  0x52_4\n    101010  =  0x51_4\n    100000  =  0x10_4\n    100101  =  0x92_4\n\n1\n\nThe optional user-supplied header line.\n\n\n\nSee Also\nmatrix::stream&lt;&lt;\nmatrix::print\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/matrix/constructors.html",
    "href": "content/matrix/constructors.html",
    "title": "bit::matrix — Construction",
    "section": "",
    "text": "\\[\n\\newcommand{\\FF}{\\mathbb{F}_2}\n\\newcommand{\\R}{\\mathbb{R}}\n\\]\n\n\n\n\n\n\n\n\n\n\nConstructors for a bit-matrix.\nconstexpr\n1bit::matrix(std::size_t r, std::size_t c);\n\nconstexpr\n2bit::matrix(std::size_t n = 0);\n\nconstexpr\nbit::matrix(const vector_type &v,\n3            std::size_t r = 1, bool by_rows = true);\n\nconstexpr\nbit::matrix(const vector_type &u,\n4            const vector_type &v, bool product = true);\n\nexplicit constexpr\nbit::matrix(std::size_t r, std::size_t c,\n5            std::invocable&lt;std::size_t, std::size_t&gt; auto f);\n\nexplicit constexpr\n6bit::matrix(std::size_t n, &lt;std::size_t, std::size_t&gt; auto f);\n\nexplicit\n7bit::matrix(std::string &src, bool bit_order = false);\n\n1\n\nConstruct an r x c bit-matrix initialized to 0.\nIf either parameter is zero, the bit-matrix will be 0 x 0.\n\n2\n\nConstruct an n x n square bit-matrix with all elements initialized to 0.\nDefault construction creates an empty 0 x 0 bit-matrix.\n\n3\n\nReshape a bit-vector into a bit-matrix with r rows. The constructor uses all the elements of the bit-vector, sor must divide v.size() evenly!\nIf r = 1the constructed bit-matrix has a single row; if r = 0, it will have a single column instead.\nBy default, v stores the elements of the bit-matrix by rows. If by_rows == false, then v stores the elements by columns.\n\n4\n\nConstruct a bit-matrix from the outer product or outer sum of two bit-vectors.\nIf u.size() == m and v.size() == n, the resulting bit-matrix will be m x n.\nIf product == true then mat(i, j) = u(i) & v(j).\nIf product == false then mat(i, j) = u(i) ^ v(j).\n\n5\n\nConstruct an r x c bit-matrix filled using a function call for each index pair (i, j).\n\n6\n\nConstruct an n x n square bit-matrix filled using a function call for each index pair (i, j).\n\n7\n\nConstruct a bit-matrix from a string that contains the elements row by row. + Newlines, white spaces, commas, or semi-colons must separate the rows. Each row should be encoded in a string as documented in the vector::constructors page.\n\n\n\n\n\n\n\n\nExceptions\n\n\n\nIf parse errors exist, these methods throw a std::invalid_argument exception.\n\n\n\nMethod Arguments\n\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nr\nThe number of rows required in the bit-matrix.\n\n\nc\nThe number of columns required in the bit-matrix.\n\n\nn\nThe number of rows & columns required in a square bit-matrix.\n\n\nf\nThis function will be called as f(i, j) for \\(i \\in 0,\\ldots,m-1,  \\; j \\in 0,\\ldots,n-1\\). A non-zero return sets the corresponding element in the bit-matrix to 1.\n\n\nbit_order\nDefaults to false, but if present and set to true, then binary strings for the rows will have the lowest bits on the right. The parameter is ignored for hex-strings.\n\n\n\n\nExample — Construction from non-string data\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    bit::matrix m0;\n2    bit::matrix m1(3, 5);\n3    bit::matrix m2(4);\n\n    std::cout &lt;&lt; \"matrix:       \\n\" &lt;&lt; m0 &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"matrix(3, 5): \\n\" &lt;&lt; m1 &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"matrix(4):    \\n\" &lt;&lt; m2 &lt;&lt; \"\\n\\n\";\n\n4    bit::vector u(16, [](std::size_t i) { return (i + 1) % 2; });\n    std::cout &lt;&lt; \"Constructing a bit-matrix by reshaping bit-vector u: \" &lt;&lt; u &lt;&lt; \"\\n\";\n5    bit::matrix m3(u, 2);\n6    bit::matrix m4(u, 4);\n7    bit::matrix m5(u, 4, false);\n    std::cout &lt;&lt; \"matrix(u, 2) \\n\"        &lt;&lt; m3 &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"matrix(u, 2, true) \\n\"  &lt;&lt; m4 &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"matrix(u, 4, false) \\n\" &lt;&lt; m5 &lt;&lt; \"\\n\\n\";\n\n    u.resize(6);\n    auto v = bit::vector::ones(4);\n    std::cout &lt;&lt; \"Constructing a bit-matrix from the outer product and sum of bit-vector u: \"\n              &lt;&lt; u &lt;&lt; \" and v: \" &lt;&lt; v &lt;&lt; \"\\n\";\n8    bit::matrix m6(u, v);\n9    bit::matrix m7(u, v, false);\n    std::cout &lt;&lt; \"matrix(u, v, true) \\n\"  &lt;&lt; m6 &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"matrix(u, v, false) \\n\" &lt;&lt; m7 &lt;&lt; \"\\n\\n\";\n\n    bit::matrix m8(8, [](size_t i, size_t) { return (i + 1) % 2; });\n    std::cout &lt;&lt; \"matrix(lambda) \\n\" &lt;&lt; m8 &lt;&lt; \"\\n\";\n}\n\n1\n\nDefault constructor makes an empty bit-matrix.\n\n2\n\n3 x 5 bit-matrix initialized to all zeros.\n\n3\n\n4 x 4 square bit-matrix initialized to all zeros.\n\n4\n\nBit-matrix from a bit-vector reshaped into two rows.\n\n5\n\nBit-matrix from a bit-vector reshaped into four rows.\n\n6\n\nBit-matrix from a bit-vector reshaped into four rows where the bit-vector stores the elements column by column.\n\n7\n\nBit-matrix from the outer product of two bit-vectors.\n\n8\n\nBit-matrix from the outer sum of two bit-vectors.\n\n9\n\nBit-matrix from a lambda that sets the even rows to all ones and odd rows to all zeros.\n\n\nOutput\nmatrix:\n[]\nmatrix(3, 5):\n│0 0 0 0 0│\n│0 0 0 0 0│\n│0 0 0 0 0│\n\nmatrix(4):\n│0 0 0 0│\n│0 0 0 0│\n│0 0 0 0│\n│0 0 0 0│\n\nConstructing a bit-matrix by reshaping bit-vector u: [1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0]\nmatrix(u, 2)\n│1 0 1 0 1 0 1 0│\n│1 0 1 0 1 0 1 0│\n\nmatrix(u, 2, true)\n│1 0 1 0│\n│1 0 1 0│\n│1 0 1 0│\n│1 0 1 0│\n\nmatrix(u, 4, false)\n│1 1 1 1│\n│0 0 0 0│\n│1 1 1 1│\n│0 0 0 0│\n\nConstructing a bit-matrix from the outer product and sum of bit-vector u: [1 0 1 0 1 0] and v: [1 1 1 1]\nmatrix(u, v, true)\n│1 1 1 1│\n│0 0 0 0│\n│1 1 1 1│\n│0 0 0 0│\n│1 1 1 1│\n│0 0 0 0│\n\nmatrix(u, v, false)\n│0 0 0 0│\n│1 1 1 1│\n│0 0 0 0│\n│1 1 1 1│\n│0 0 0 0│\n│1 1 1 1│\n\nmatrix(lambda)\n│1 1 1 1 1 1 1 1│\n│0 0 0 0 0 0 0 0│\n│1 1 1 1 1 1 1 1│\n│0 0 0 0 0 0 0 0│\n│1 1 1 1 1 1 1 1│\n│0 0 0 0 0 0 0 0│\n│1 1 1 1 1 1 1 1│\n│0 0 0 0 0 0 0 0│\nExample — Construction from strings\n#include &lt;bit/bit.h&gt;\nint main()\n{\n1    bit::matrix m1(\"111 000 111\");\n2    bit::matrix m2(\"0b111 0b000 0b111\");\n3    bit::matrix m3(\"0x111;0x000;0x111\");\n4    bit::matrix m4(\"0x1, 0x1, 0x1\");\n5    bit::matrix m5(\"0x1_8;0x1_8;0x1_8\");\n6    bit::matrix m6(\"0x1_4;0x1_4;0x1_4\");\n7    bit::matrix m7(\"0x1_2;0x1_2;0x1_2\");\n\n    std::cout &lt;&lt; \"m1: \\n\" &lt;&lt; m1 &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"m2: \\n\" &lt;&lt; m2 &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"m3: \\n\" &lt;&lt; m3 &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"m4: \\n\" &lt;&lt; m4 &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"m5: \\n\" &lt;&lt; m5 &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"m6: \\n\" &lt;&lt; m6 &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"m7: \\n\" &lt;&lt; m7 &lt;&lt; \"\\n\\n\";\n}\n\n1\n\nConstruction from strings separated by white space. All characters are 0’s and 1’s, so we interpret each element as a binary number.\n\n2\n\nConstruction from the same binary strings, each with a binary prefix 0b.\n\n3\n\nConstruction from the same digits, but each is now interpreted as a hex character thanks to the 0x prefix. Here, semi-colons separate rows.\n\n4\n\nConstruction where the final characters have no suffix, so by default, are parsed as a hex/base-16 number. Here, commas separate rows.\n\n5\n\nConstruction where the final characters have a suffix _8 so are parsed as base-8 numbers.\n\n6\n\nConstruction where the final characters have a suffix _4 so are parsed as base-4 numbers.\n\n7\n\nConstruction where the final characters have a suffix _2 so are parsed as base-2 numbers.\n\n\nOutput\nm1:\n│1 1 1│\n│0 0 0│\n│1 1 1│\n\nm2:\n│1 1 1│\n│0 0 0│\n│1 1 1│\n\nm3:\n│1 0 0 0 1 0 0 0 1 0 0 0│\n│0 0 0 0 0 0 0 0 0 0 0 0│\n│1 0 0 0 1 0 0 0 1 0 0 0│\n\nm4:\n│1 0 0 0│\n│1 0 0 0│\n│1 0 0 0│\n\nm5:\n│1 0 0│\n│1 0 0│\n│1 0 0│\n\nm6:\n│1 0│\n│1 0│\n│1 0│\n\nm7:\n│1│\n│1│\n│1│\n\n\nSee Also\nvector::constructors\nmatrix::to_string\n\n\n\n\n Back to top"
  }
]